<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 图论 | hnnwang's Blog]]></title>
  <link href="http://whn757397540.github.io/blog/categories/tu-lun/atom.xml" rel="self"/>
  <link href="http://whn757397540.github.io/"/>
  <updated>2015-03-16T17:06:28+08:00</updated>
  <id>http://whn757397540.github.io/</id>
  <author>
    <name><![CDATA[hnnwang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[最小割的介绍及应用]]></title>
    <link href="http://whn757397540.github.io/blog/2015/03/14/zui-xiao-ge-de-jie-shao-ji-ying-yong/"/>
    <updated>2015-03-14T18:55:31+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/03/14/zui-xiao-ge-de-jie-shao-ji-ying-yong</id>
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=3469">POJ 3469 Dual Core CPU</a></p>

<p>这是一个典型的最小割问题，不再陈述题意。</p>

<!--more-->


<p>这里先介绍一下割的概念。所谓图的割，就是指对于某个定点几何S（属于V），从S出发指向S外部的那些边的几何，记作割（S, V/S）。这些边的容量之和被称为割的容量。如果有s∈S，t∈V/S，那么此时的割又可以称为s-t割。</p>

<p>好好理解下割的概念，然后，记住一个定理：一个图从s到t的最大流，等于s-t的最小割。这个被称为最大流最小割定理。</p>

<p>像这道题这种<strong>用最小的费用将对象划分成两个集合的问题，常常可以转换成最小割问题后顺利解决</strong>，本题就是一个非常典型的例子。（要不本来我还不知道最小割怎么来用呢，算是第一次遇到用最小割的题目吧！）</p>

<p>这道题，就可以记在A上执行的模块的几何为S，在B上执行的模块的几何为T，并加一个虚拟的源点s在S中和一个虚拟的汇点t在T中。我们很容易知道，花费的总和是</p>

<p>sigma(A[i],i∈S) + sigmasigma(B[i],i∈T) + sigma（wi,ai属于S，bi属于T） + sigma（wi,ai属于s，bi属于t）.</p>

<p>我们需要构建一个图，使得花费的综合等价于图的割的容量，那么我们就可以通过求最小割来求最小花费了。关键是图怎么构？这是一个问题。</p>

<p>我们要明确一个方向，我们要做的是让图的割等于花费，也就是让从S到T的各个边的权值和等于上面的式子，那么实际上还是蛮简单的，一个一个来考虑就好了，对于式子的第一项sigma(A[i],i∈S),首先，我们确定i∈S，我们只需要从S指向T就好，所以只需要从每个模块向t连一条容量为A[i]的边就好；同样，对于第二项，i属于T，所以只要有一个从S中指出来的边指向i就好，所以就从s指向每个模块一条容量为B[i]的边；最后，第三项，ai∈S，bi∈T，记住目的是连从S到T的边，所以连的应该是从ai到bi的边，容量为wi，同理，第四项只是把第三项的边反过来就好。</p>

<p>这样我们构完图，这个图的割就代表着花费，那么最小割自然就代表着最小花费了！而通过最大流最小割定理我们又知道，最小割等于最大流，所以我们只需要求从s到t的最大流即可。 代码如下</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 22222;

const int INF = 0x3f3f3f3f;
struct Edge{
    int to,cap, rev;
    Edge(int to, int cap, int rev):to(to), cap(cap), rev(rev){}
};

vector&lt;Edge&gt; G[maxv];
int level[maxv];//¶¥µãµ½Ô´µãµÄ¾àÀë±êºÅ
int iter[maxv];//µ±Ç°»¡£¬ÔÚÆäÖ®Ç°µÄ±ßÒÑ¾­Ã»ÓÐÓÃÁË

void addEdge(int from, int to, int cap)
{
    G[from].push_back(Edge(to, cap, G[to].size()));
    G[to].push_back(Edge(from, 0, G[from].size()-1));
}

void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for (int i = 0; i &lt; G[v].size(); i++)
        {
            Edge &amp;e = G[v][i];
            if (e.cap&gt;0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

int dfs(int v, int t, int f)
{
    if(v == t)
        return f;
    for (int &amp;i = iter[v]; i &lt; G[v].size(); i++)
    {
        Edge &amp;e = G[v][i];
        if (e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if (d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

int max_flow(int s, int t)
{
    int flow = 0;
    while(true)
    {
        bfs(s);
        if (level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while ((f = dfs(s, t, INF)) &gt; 0)
            flow += f;
    }
}

vector&lt;int&gt; rec[maxv];
int main()
{
    int n,m;
    scanf("%d%d", &amp;n, &amp;m);
    int s = 0, t = n+1;
    for (int i = 1; i &lt;= n; i++)
    {
        int a,b;
        scanf("%d%d", &amp;a, &amp;b);
        addEdge(s, i, b);
        addEdge(i, t, a);
    }
    for (int i = 1; i &lt;= m; i++)
    {
        int a,b,w;
        scanf("%d%d%d", &amp;a, &amp;b, &amp;w);
        addEdge(a,b,w);
        addEdge(b,a,w);
    }

    printf("%d\n", max_flow(s,t));
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图论总结(六)]]></title>
    <link href="http://whn757397540.github.io/blog/2015/03/14/tu-lun-zong-jie-liu/"/>
    <updated>2015-03-14T18:55:18+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/03/14/tu-lun-zong-jie-liu</id>
    <content type="html"><![CDATA[<p>2-sat问题</p>

<!--more-->


<p>2-sat问题嘛，去鞍山打比赛之前看过一次，是在刘汝佳白书上看的，看的迷迷糊糊似懂非懂的（说白了其实是没有看懂），这次看的《挑战程序设计竞赛》上的，一下子就全部闹明白了。</p>

<p>首先，解释一下什么叫做sat问题：给定一个布尔方程，判断是否存在一组布尔变量的真值指派使得整个方程为真的问题，被称为布尔方程的可满足性问题（sat）。sat问题是NP完全性问题，但是对于满足一定限制条件的sat问题，还是能够有效求解的。看下面的合取范式：</p>

<p>(a或b或……）且（c或d或………）且……（PS:符号不好打， 所以只能用文字代替了）</p>

<p>其中a,b,c,d……等被称为文字，它是一个布尔变量或者其否定。像 (a或b或……) 这样用 或 连接的部分称为子句。如果合取范式的每个子句中的文字个数都不超过2个，那么对应的sat问题又称为2-sat问题。</p>

<p>通过以上的说明，应该能够知道什么事sat问题了。那么这类问题怎么求解呢？利用强连通分量，可以在布尔公式句数的线性时间内解决2-sat问题。首先，利用=>(蕴涵)符号将每个子句（a 或 b） 改成其等价形式（非a => b 且 非b => a）。这样远布尔公式就变成了把 a=>b 形式的布尔公式用 与 链接起来的形式。 对于每个布尔变量x, 构造两个顶点分别代表 x 和 非x， 以 => 关系为边建立有向图。 此时，如果图上a能到达b点的话，就表示当a为真的时候b也肯定为真。因此，该图中同一个强连通分量所含的所有文字的布尔值均相同（可能真可能假）。</p>

<p>如果存在某个布尔变量x，x 和 非x 均在同一个强连通分量重，则显然无法令整个布尔公式的值为真。 反之，如果不存在这样的布尔变量，那么对于每个布尔变量x，让</p>

<p>x所在的强连通分量的拓扑序在 非x 所在的强连通分量之后 &lt;==> x为真</p>

<p>就是使得该公式值为真的一组合适的布尔变量赋值。（记住后面的是真就好，这个是在需要输出一种可能的结果的时候会用得到）</p>

<p>接下来看题</p>

<p><a href="http://poj.org/problem?id=3683">POJ 3683 Priest John’s Busiest Day</a></p>

<p>这道题，我们知道，对于每一组S,T,D，只有2种情况需要结婚仪式，就是(S, S+D) 和 (T-D, T)，把这两种情况分别设为同一个布尔变量的真和假就好。假设对应i于j的两个布尔型变量分别为xi（Si+Di）,xj(Sj+Dj),那么 非xi 对应（T[i] - D[i], T[i]）, 非xj 对应（T[j] - D[j], T[j]）。加入xi和xj矛盾，我们就有 xi且xj 为假， 那么 非xi 或 非xj 就为真，把这个式子按照之前所说的规则进行转换就能得到一组加边的方法。同理，对于其他的矛盾也是这样处理。</p>

<p>那么，对应的这道题的连边的方式就出来了，然后就没有什么难度了。给两个代码。</p>

<p>Tarjan</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;stack&gt;

using namespace std;
const int maxv = 11111;
const int maxm = 2222222;
struct Edge{
    int from, to, next;
    Edge(){}
    Edge(int from, int to, int next):from(from), to(to), next(next){}
};

Edge E[maxm];
int head[maxv];
int nume;
int pre[maxv],lowlink[maxv],sccno[maxv],dfs_clock,scc_cnt;
int S[maxv];
int tops;

void init()
{
    nume = 0;
    memset(head, -1, sizeof(head));
    tops = 0;
}

void addEdge(int from, int to)
{
    E[nume] = Edge(from, to, head[from]);
    head[from] = nume++;
}

void dfs(int u)
{
    pre[u] = lowlink[u] = ++dfs_clock;
    S[tops++] = u;
    for (int i = head[u]; i != -1; i = E[i].next)
    {
        int v = E[i].to;
        if (!pre[v])
        {
            dfs(v);;
            lowlink[u] = min(lowlink[u], lowlink[v]);
        }
        else if(!sccno[v])
            lowlink[u] = min(lowlink[u], pre[v]);
    }
    if (lowlink[u] == pre[u])
    {
        scc_cnt++;
        while(true)
        {
            int x = S[--tops];
            sccno[x] = scc_cnt;
            if(x == u)
                break;
        }
    }
}

void find_scc(int n)
{
    dfs_clock = scc_cnt = 0;
    memset(sccno, 0, sizeof(sccno));
    memset(pre, 0, sizeof(pre));
    for (int i = 0; i &lt; n; i++)
        if(!pre[i]) dfs(i);
}

int s[maxv],t[maxv],d[maxv];
int main()
{
    int n;
    init();
    scanf("%d", &amp;n);
    for (int i = 0; i &lt; n; i++)
    {
        int hh,mm;
        scanf("%d:%d", &amp;hh, &amp;mm);
        s[i] = hh*60+mm;
        scanf("%d:%d", &amp;hh, &amp;mm);
        t[i] = hh*60+mm;
        scanf("%d", &amp;d[i]);
    }

    for (int i = 0; i &lt; n; i++)
    {
        int t1 = s[i] + d[i], s1 = t[i] - d[i];
        for (int j = i+1; j &lt; n; j++)
        {
            int t2 = s[j] + d[j], s2 = t[j] - d[j];
            if (s[j] &lt; t1 &amp;&amp; t2 &gt; s[i])
            {
                addEdge(i,j+n);
                addEdge(j,i+n);
            }
            if (s2 &lt; t1 &amp;&amp; t[j] &gt; s[i])
            {
                addEdge(i,j);
                addEdge(j+n,i+n);
            }
            if (s[j] &lt; t[i] &amp;&amp; t2 &gt; s1)
            {
                addEdge(i+n, j+n);
                addEdge(j,i);
            }
            if (s2 &lt; t[i] &amp;&amp; t[j] &gt; s1)
            {
                addEdge(i+n,j);
                addEdge(j+n,i);
            }
        }
    }
    find_scc(2*n);
    bool judge = true;
    for (int i = 0; i &lt; n; i++)
        if(sccno[i] == sccno[n+i])
        {
            judge = false;
            break;
        }
    if(judge)
    {
        printf("YES\n");
        for (int i = 0; i &lt; n; i++)
        {
            if(sccno[i] &lt; sccno[n+i])
                printf("%02d:%02d %02d:%02d\n", s[i]/60, s[i]%60, (s[i]+d[i])/60, (s[i]+d[i])%60);
            else
                printf("%02d:%02d %02d:%02d\n", (t[i]-d[i])/60, (t[i]-d[i])%60, t[i]/60, t[i]%60);
        }
    }
    else
        printf("NO\n");
    system("pause");
    return 0;
}
</code></pre>

<p>Kosaraju</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;
const int maxv = 22222;
const int maxe = 2222222;

int V;
struct Edge{
    int from, to, next;
    Edge(){}
    Edge(int from, int to, int next):from(from), to(to), next(next){}
};
Edge E[maxe];//图的邻接表表示
Edge rE[maxe];//把边反向后的图
int head[maxv], rhead[maxv];
int nume,rnume;
int vs[maxv];//后续遍历顺序的顶点列表
int cntvs;
bool used[maxv];//访问标记
int tporder[maxv];//所属强联通分量的拓扑序

void init()
{
    nume = rnume = 0;
    memset(head, -1, sizeof(head));
    memset(rhead, -1, sizeof(rhead));
    cntvs = 0;
}
void addEdge(int from, int to)
{
    E[nume] = Edge(from, to, head[from]);
    head[from] = nume++;
    rE[rnume] = Edge(to, from, rhead[to]);
    rhead[to] = rnume++;
}

void dfs(int v)
{
    used[v] = true;
    for (int i = head[v]; i != -1; i = E[i].next)
        if (!used[E[i].to]) dfs(E[i].to);
    vs[cntvs++] = v;
}

void rdfs(int v, int k)
{
    used[v] = true;
    tporder[v] = k;
    for (int i = rhead[v]; i != -1; i = rE[i].next)
        if (!used[rE[i].to]) rdfs(rE[i].to, k);
}

int scc()
{
    memset(used, false, sizeof(used));

    for (int v= 0 ; v &lt; V; v++)
        if (!used[v])   dfs(v);
    memset(used, 0, sizeof(used));
    int k = 0;
    for (int i = cntvs-1; i &gt;= 0; i--)
        if (!used[vs[i]]) rdfs(vs[i], k++);
    return k;
}


int s[maxv],t[maxv],d[maxv];
int main()
{
    int n;
    init();
    scanf("%d", &amp;n);
    for (int i = 0; i &lt; n; i++)
    {
        int hh,mm;
        scanf("%d:%d", &amp;hh, &amp;mm);
        s[i] = hh*60+mm;
        scanf("%d:%d", &amp;hh, &amp;mm);
        t[i] = hh*60+mm;
        scanf("%d", &amp;d[i]);
    }
    int t1,t2,s1,s2;
    for (int i = 0; i &lt; n; i++)
    {
        t1 = s[i] + d[i], s1 = t[i] - d[i];
        for (int j = 0; j &lt; i; j++)
        {
            t2 = s[j] + d[j], s2 = t[j] - d[j];
            if (min(t1, t2) &gt; max(s[i],s[j]))
            {
                addEdge(i,j+n);
                addEdge(j,i+n);
            }
            if (max(s[i],s2) &lt; min(t1, t[j]))
            {
                addEdge(i,j);
                addEdge(j+n,i+n);
            }
            if (max(s[j],s1) &lt; min(t[i],t2))
            {
                addEdge(i+n, j+n);
                addEdge(j,i);
            }
            if (min(t[i], t[j]) &gt; max(s1,s2))
            {
                addEdge(i+n,j);
                addEdge(j+n,i);
            }
        }
    }
    V = 2*n;
    scc();
    bool judge = true;
    for (int i = 0; i &lt; n; i++)
        if(tporder[i] == tporder[n+i])
        {
            judge = false;
            break;
        }
    if(judge)
    {
        printf("YES\n");
        for (int i = 0; i &lt; n; i++)
        {
            if(tporder[i] &gt; tporder[n+i])
                printf("%02d:%02d %02d:%02d\n", s[i]/60, s[i]%60, (s[i]+d[i])/60, (s[i]+d[i])%60);
            else
                printf("%02d:%02d %02d:%02d\n", (t[i]-d[i])/60, (t[i]-d[i])%60, t[i]/60, t[i]%60);
        }
    }
    else
        printf("NO\n");
   // system("pause");
    return 0;
}
</code></pre>

<p>这里注意一点，Tarjan的拓扑序跟Kosaraju是相反的，之前所说的后面，对应Kosaraju里面的就是标号比较大，对应Tarjan里面的就是标号比较小。</p>

<p>做这种题的关键是抽象出布尔代数来，然后用蕴含关系来连边，注意你要化简的布尔式子一定是 与 的关系，最后通过强连通分量来求出2-sat的结果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图论总结(五)]]></title>
    <link href="http://whn757397540.github.io/blog/2015/03/14/tu-lun-zong-jie-wu/"/>
    <updated>2015-03-14T18:55:02+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/03/14/tu-lun-zong-jie-wu</id>
    <content type="html"><![CDATA[<h4>有向图的强联通分量</h4>

<p>主要介绍求强联通分量的2种方法。</p>

<!--more-->


<ol>
<li>Kosaraju算法</li>
</ol>


<p>这种算法就是数据结构上讲的那种算法，利用2次简单的dfs来实现。第一次dfs时，选取任意顶点作为起点，遍历所有未访问过的顶点，并在回溯前给顶点标号（后序遍历）。对剩余未访问过的顶点，不断重复上述过程；完成标号后，越接近图的尾部（搜索树的叶子），顶点标号越小。第二次dfs时，先将所有的边反向，然后以标号最大的顶点进行dfs。这样dfs所遍历的顶点几何就构成了一个强联通分量。之后，只要还有尚未访问的顶点，就从中选取标号最大的顶点不断重复上述过程。</p>

<p>以上就是整个算法的过程，至于证明吧，自己画个图模拟一下吧。给出一个模板代码！算法的复杂度时O(V+E)</p>

<pre><code class="c++">int V;
struct Edge{
    int from, to, next;
    Edge(){}
    Edge(int from, int to, int next):from(from), to(to), next(next){}
};
Edge E[maxe];//图的邻接表表示
Edge rE[maxe];//把边反向后的图
int head[maxv], rhead[maxv];
int nume,rnume;
int vs[maxv];//后续遍历顺序的顶点列表
int cntvs;
bool used[maxv];//访问标记
int tporder[maxv];//所属强联通分量的拓扑序

void init()
{
    nume = rnume = 0;
    memset(head, -1, sizeof(head));
    memset(rhead, -1, sizeof(rhead));
    cntvs = 0;
}
void addEdge(int from, int to)
{
    E[nume] = Edge(from, to, head[from]);
    head[from] = nume++;
    rE[rnume] = Edge(to, from, rhead[to]);
    rhead[to] = rnume++;
}

void dfs(int v)
{
    used[v] = true;
    for (int i = head[v]; i != -1; i = E[i].next)
        if (!used[E[i].to]) dfs(E[i].to);
    vs[cntvs++] = v;
}

void rdfs(int v, int k)
{
    used[v] = true;
    tporder[v] = k;
    for (int i = rhead[v]; i != -1; i = rE[i].next)
        if (!used[rE[i].to]) rdfs(rE[i].to, k);
}

int scc()
{
    memset(used, false, sizeof(used));

    for (int v= 0 ; v &lt; V; v++)
        if (!used[v])   dfs(v);
    memset(used, 0, sizeof(used));
    int k = 0;
    for (int i = cntvs-1; i &gt;= 0; i--)
        if (!used[vs[i]]) rdfs(vs[i], k++);
    return k;
}
</code></pre>

<ol>
<li>Tarjan算法</li>
</ol>


<p>这个算法的思想是这样的：</p>

<p>考虑强连通分量 C，设其中第一个被发现的点为 x，则 C 中其他点都是 x 的后代。我们希望在 x 访问完成时立刻输出 C。这样，就可以在同一棵 DFS 树中区分开所有 SCC 了。因此问题的关键，是判断一个点是否为一个 SCC中最先发现的点。</p>

<p>假设我们正在判断 u 是否为某 SCC 的第一个被发现结点。如果我们发现从 u 的子结点出发可以到达 u 的祖先w，显然 u、v、w 在同一个 SCC 中，因此 u 不是该 SCC 中第一个被发现的结点；另一方面，如果从 v 发现最多只能到 u，那么 u 是该 SCC 中第一个被发现的结点。这样，问题转化为求一个点 u 最远能到达的祖先的 d 值。注意，这里的“到达”只能通过当前 SCC 中的点，而不能通过已经确定 SCC 编号的其他点。</p>

<p>我们可以类似的定义 lowlink(u)为 u 及其后代能追溯到的最早（最先被发现）祖先点 v 的 pre(v)值，如此便可以在计算 lowlink 函数的同时完成 SCC 计算。这个算法的复杂度也是O(V+E)，但是常数比Kosaraju算法要小一些。参考代码如下：</p>

<pre><code class="c++">struct Edge{
    int from, to, next;
    Edge(){}
    Edge(int from, int to, int next):from(from), to(to), next(next){}
};

Edge E[maxm];
int head[maxv];
int nume;
int pre[maxv],lowlink[maxv],sccno[maxv],dfs_clock,scc_cnt;
int S[maxv];
int tops;

void init()
{
    nume = 0;
    memset(head, -1, sizeof(head));
    tops = 0;
}

void addEdge(int from, int to)
{
    E[nume] = Edge(from, to, head[from]);
    head[from] = nume++;
}

void dfs(int u)
{
    pre[u] = lowlink[u] = ++dfs_clock;
    S[tops++] = u;
    for (int i = head[u]; i != -1; i = E[i].next)
    {
        int v = E[i].to;
        if (!pre[v])
        {
            dfs(v);;
            lowlink[u] = min(lowlink[u], lowlink[v]);
        }
        else if(!sccno[v])
            lowlink[u] = min(lowlink[u], pre[v]);
    }
    if (lowlink[u] == pre[u])
    {
        scc_cnt++;
        while(true)
        {
            int x = S[--tops];
            sccno[x] = scc_cnt;
            if(x == u)
                break;
        }
    }
}

void find_scc(int n)
{
    dfs_clock = scc_cnt = 0;
    memset(sccno, 0, sizeof(sccno));
    memset(pre, 0, sizeof(pre));
    for (int i = 0; i &lt; n; i++)
        if(!pre[i]) dfs(i);
}
</code></pre>

<p>下面来说一道题</p>

<p><a href="http://poj.org/problem?id=2186">POJ 2186 Popular Cows</a></p>

<p>这道题思路其实不难想，算是一道基础题了，就是为了练习强联通分量的吧！首先，我们要明确，如果一个牛被其他所有牛认为是红人，那么那头牛所在的强联通分量里的任何一头牛都是被所有牛认为是红人的牛。反之，任何一头其他的牛被所有牛认为是红人，那么这头牛也一定属于这个强联通分量。所以，如果存在被所有牛认为是红人的牛，那么这些牛肯定都属于同一个强联通分量，这个强联通分量里面的牛的数目就是答案了；当然，也有可能不存在。</p>

<p>我们通过两种算法求出来的所有强联通分量，都是按照图的拓扑序排了序的，所以如果存在这样的牛的话，那么它一定属于拓扑序最后的强联通分量，所以一种方法就是，先找到拓扑序最后的强联通分量里面的一头牛，然后看他是不是所有顶点可达就能判断了。这种方法的代码，我是用Kosaraju算法写的（事实上是参考《挑战程序设计竞赛》中的代码写的），当然也可以用tarjan来写：</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;
const int maxv = 22222;
const int maxe = 55555;

int V;
struct Edge{
    int from, to, next;
    Edge(){}
    Edge(int from, int to, int next):from(from), to(to), next(next){}
};
Edge E[maxe];//图的邻接表表示
Edge rE[maxe];//把边反向后的图
int head[maxv], rhead[maxv];
int nume,rnume;
int vs[maxv];//后续遍历顺序的顶点列表
int cntvs;
bool used[maxv];//访问标记
int tporder[maxv];//所属强联通分量的拓扑序

void init()
{
    nume = rnume = 0;
    memset(head, -1, sizeof(head));
    memset(rhead, -1, sizeof(rhead));
    cntvs = 0;
}
void addEdge(int from, int to)
{
    E[nume] = Edge(from, to, head[from]);
    head[from] = nume++;
    rE[rnume] = Edge(to, from, rhead[to]);
    rhead[to] = rnume++;
}

void dfs(int v)
{
    used[v] = true;
    for (int i = head[v]; i != -1; i = E[i].next)
        if (!used[E[i].to]) dfs(E[i].to);
    vs[cntvs++] = v;
}

void rdfs(int v, int k)
{
    used[v] = true;
    tporder[v] = k;
    for (int i = rhead[v]; i != -1; i = rE[i].next)
        if (!used[rE[i].to]) rdfs(rE[i].to, k);
}

int scc()
{
    memset(used, false, sizeof(used));

    for (int v= 0 ; v &lt; V; v++)
        if (!used[v])   dfs(v);
    memset(used, 0, sizeof(used));
    int k = 0;
    for (int i = cntvs-1; i &gt;= 0; i--)
        if (!used[vs[i]]) rdfs(vs[i], k++);
    return k;
}

int main()
{
    int n,m;
    scanf("%d%d", &amp;n, &amp;m);
    init();
    for (int i = 0; i &lt; m; i++)
    {
        int a,b;
        scanf("%d%d", &amp;a, &amp;b);
        addEdge(a-1,b-1);
    }
    V = n;
    int K = scc();
    int ans = 0, u;
    for (int i = 0; i &lt; V; i++)
        if (tporder[i] == K-1)
        {
            ans++;
            u = i;
        }

    memset(used, 0, sizeof(used));
    rdfs(u, 0);
    for (int i = 0; i &lt; n; i++)
        if (!used[i])
        {
            ans = 0;
            break;
        }
    printf("%d\n", ans);

    return 0;
}
</code></pre>

<p>这里，书上用的是vector来表示的图，我刚开始也是跟着书上的写法来的，但是发现太慢了，344ms,然后改成了这样，手写的边，时间就变成了63ms，当然，后者写起来比较麻烦。</p>

<p>还有一种方法，被前面所有牛都认为是红人的那个强联通分量肯定在最后，所以我们只需要看有几个“最后”就行（这里的最后是指，出度为0的强联通分量）。如果只有一个的话，那么答案就是这个强联通分量里面的人数；如果有不止一个的话，那么就没有牛被所有牛认为是红人（因为出度为0的牛，除了自己圈子里的牛，不认为其他的任何牛是红人。）</p>

<p>这种方法我使用Tarjan写的。</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;stack&gt;

using namespace std;
const int maxv = 11111;
const int maxm = 55555;
struct Edge{
    int from, to, next;
    Edge(){}
    Edge(int from, int to, int next):from(from), to(to), next(next){}
};

Edge E[maxm];
int head[maxv];
int nume;
int pre[maxv],lowlink[maxv],sccno[maxv],dfs_clock,scc_cnt;
int S[maxv];
int tops;

void init()
{
    nume = 0;
    memset(head, -1, sizeof(head));
    tops = 0;
}

void addEdge(int from, int to)
{
    E[nume] = Edge(from, to, head[from]);
    head[from] = nume++;
}

void dfs(int u)
{
    pre[u] = lowlink[u] = ++dfs_clock;
    S[tops++] = u;
    for (int i = head[u]; i != -1; i = E[i].next)
    {
        int v = E[i].to;
        if (!pre[v])
        {
            dfs(v);;
            lowlink[u] = min(lowlink[u], lowlink[v]);
        }
        else if(!sccno[v])
            lowlink[u] = min(lowlink[u], pre[v]);
    }
    if (lowlink[u] == pre[u])
    {
        scc_cnt++;
        while(true)
        {
            int x = S[--tops];
            sccno[x] = scc_cnt;
            if(x == u)
                break;
        }
    }
}

void find_scc(int n)
{
    dfs_clock = scc_cnt = 0;
    memset(sccno, 0, sizeof(sccno));
    memset(pre, 0, sizeof(pre));
    for (int i = 0; i &lt; n; i++)
        if(!pre[i]) dfs(i);
}

int deg[maxv],cnt[maxv];
int main()
{
    int n,m;
    scanf("%d%d", &amp;n, &amp;m);
    init();
    for (int i = 0; i &lt; m; i++)
    {
        int a,b;
        scanf("%d%d", &amp;a, &amp;b);
        addEdge(a-1,b-1);
    }
    find_scc(n);

    int k = scc_cnt;

    for (int i = 0; i &lt; n; i++)
    {
        cnt[sccno[i]]++;
        for (int j = head[i]; j != -1; j = E[j].next)
            if (sccno[E[j].to] != sccno[i])
                deg[sccno[i]]++;
    }
    int ans = 0;
    //cout&lt;&lt;1&lt;&lt;endl;
    for (int i = 1; i &lt;= k; i++)
        if(ans == 0 &amp;&amp; deg[i] == 0)
            ans = cnt[i];
        else if (ans != 0 &amp;&amp; deg[i] == 0)
        {
            ans = 0;
            break;
        }
    printf("%d\n", ans);

    return 0;
}
</code></pre>

<p>这里我还是要说一下，对比一下，这个Tarjan，我用vector加stack的时候，用的时间是550ms；把vector改成手写边之后，时间变成了94ms；再把stack改成手写栈之后，时间变成了63ms。所以说时间差距还是蛮大的，不过毕竟还是用stl会感觉更加方便快捷一些，所以如果给的时间充足的话，用stl也是可以的；如果时间比较紧张，就尽量用手写的吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图论总结(四)]]></title>
    <link href="http://whn757397540.github.io/blog/2015/03/14/tu-lun-zong-jie-si/"/>
    <updated>2015-03-14T18:54:50+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/03/14/tu-lun-zong-jie-si</id>
    <content type="html"><![CDATA[<h3>最小费用流</h3>

<!--more-->


<p>被老爸坑了，耽搁了好久，然后回来后又卡一些题卡了好久，都是泪，不说了，继续总结图论，应该是倒数第二个总结了，马上就要接近尾声了（丫的半个假期都快过去了，这哪成？太慢了呀！）</p>

<p>中途由于一些事情，这个最小费用流断断续续弄了好几天，不过也算是搞懂了，虽然用起来还不太熟练，但是总比之前嘛也不会的小白强，练一练总归是有效果的，废话少说，进入正题。</p>

<p>先来说说最小费用流是个什么东东。在最大流问题的网络中，给每条边有多加上了一个费用，求的不再是流量的最大值，而是在一定流量F下时的费用的最小值，这就是最小费用流问题。（其中，求在最大流量下的最小费用流的问题又叫最小费用最大流，这也是常会碰到的）。</p>

<p>那么，这种问题怎么解呢？考虑一下，我们在求解最大流的时候，是在残余网络上不断贪心的增广得到了最大流，现在边上多了费用，那么如果我们依然采用贪心的策略，在残余网络上总是沿着最短路增广又如何呢？此时，残余网络中反向边的费用应该是原边的相反数，以保证过程是可逆而正确的。</p>

<p>先来证明一下这个算法的正确性：</p>

<p>首先，我们需要证明一个<strong>定理：f是最小费用流 &lt;==> 残余网络中没有负环。</strong>这个定理很重要，以后会用到。加入残余网络中有负环，那么我们就可以沿着这个负环进行增广，不会影响总的流量，但是会使费用更加小，所以，参与网络中有负环 => f不是最小费用流。 所以 f是最小费用流 => 残余网络中没有负环。（充分性证明）如果f不是最小费用流，也就是存在与f同流量但是费用比f更小的流f1。那么我们观察一下f1-f，在f中，除了s和t以外的所有顶点的流入量等于流出量，在流f1中亦然。并且，由流f和流f1的流量相同可知，流f1-f中所有顶点的流入量都等于流出量，即他们是由若干圈组成。因为刘f1-f的费用是负的，所以在这些圈中，至少存在一个负环。残余网络中没有负环=>f是最小费用流。（必要性证明）。综上，原命题得证。</p>

<p>利用上面个那个定理，我们就可以通过归纳法证明，在该算法中流量为i的流fi是具有相同流量的流中费用最小的。首先，对于流量为0的流f0，其残余网络就是原图，只要原图不含负环，那么f0就是流量为0的最小费用流。假设流量为i的流fi是最小费用流，并且下一步我们求得了流量为i+1的流fi+1，那么此时，fi+1 - fi 就是 fi 对应的残余网络中 s 到 t 的最短路。（其实想一下，增加1流量，肯定按照残余网络中的最短路进行增广的费用是最小的）。</p>

<p>不继续写下面的严格证明了，反正就是沿着最短路进行增广得到的费用一定是对应流量的中最小的。我们要做的就是每次求出当前网络中的最短路，然后还原最短路径，沿着这条路径进行增广，直到到达要求的流量。</p>

<p>这类求最小费用流的算法也叫连续最短路算法，模板如下：</p>

<pre><code class="c++">const int maxv = 22222;

const int INF = 0x3f3f3f3f;

struct Edge{
    int  to, cap, cost, rev;
    Edge(){}
    Edge(int to, int cap, int cost, int rev):to(to), cap(cap), cost(cost), rev(rev){}
};

int V;//顶点数
vector&lt;Edge&gt; G[maxv];//图的邻接表表示
int dist[maxv];//最短距离
int prevv[maxv], preve[maxv];//最短路中的前驱节点和对应的边
queue&lt;int&gt; que;
bool inq[maxv];

//向途中增加一条从from到to容量为cap费用为cost的边
void addEdge(int from, int  to, int cap, int cost)
{
    G[from].push_back(Edge(to, cap, cost, G[to].size()));
    G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1));
}
//求解从s到t流量为f的最小费用流
//如果不再能增广则返回-1
int min_cost_flow(int s, int  t, int f)
{
    int res = 0;
    while (f &gt; 0)
    {
        //利用Bellman-Ford算法求s到t的最短路
        fill(dist, dist+V, INF);
        memset(inq, 0 , sizeof(inq));
        dist[s] = 0;
        que.push(s);
        inq[s] = true;
        while(!que.empty())
        {
            int u = que.front(); que.pop();
            inq[u] = false;
            for (int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = G[u][i];
                if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost)
                {
                    dist[e.to] = dist[u] + e.cost;
                    prevv[e.to] = u;
                    preve[e.to] = i;
                    if (!inq[e.to])
                    {
                        que.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }

        if (dist[t] == INF)
            return -1;
        int d = f;
        for (int v = t; v != s; v = prevv[v])
            d = min(d, G[prevv[v]][preve[v]].cap);
        f -= d;
        res += d*dist[t];
        for (int v = t; v!= s; v = prevv[v])
        {
            Edge &amp;e = G[prevv[v]][preve[v]];
            e.cap -= d;
            G[v][e.rev].cap += d;
        }
    }
    return res;
}
</code></pre>

<p>由于图中含有负边，所以用的是SPFA算法求最短路，实际上，我们可以通过导入势的概念，改用Dijkstra算法来求最短路。</p>

<p>这里势的概念，是指给每个顶点赋予的一个标号h[v]，在这个势的基础上，将边e = (u,v)的长度变为d’[e] = d[e] + h[u] - h[v].所以从d’中的s-t路径的长度中减去常熟h[s] - h[t]，就得到了d中对应路径的长度，因此d’中的最短路也是d中的最短路。所以，如果合理的选择势，使得对于所有的e都有d’[e]>=0的话，我们就可以在d’中用Dijkstra算法求最短路，从而得到d的最短路。对于任意不含负环的图，我们可以通过取h[v] = (s-t的最短距离)来做到这一点，因为对于任意一条边e=(u,v),有(s-v的距离) &lt;= (s-u的距离) + d[e], 于是我们有d’[e] = d[e] + h[u] - h[v] >= 0.(注意，这里d[e]指的是边e的长度)</p>

<p>接下来我们就考虑如何一次更新流量为i的最小费用流fi及其对应的势hi。定义如下变量</p>

<p>fi[e]:流量为i的最小费用流中边e的流量</p>

<p>hi[v]:fi的残余网络中s到v的最短距离</p>

<p>di[e]:考虑事后e的长度。</p>

<p>在图中不含有负环的情况下，可以初始化fi[e]为0,。如果图中没有负权边的话，还可以直接用Dijkstra算法计算h0.求的fi和hi之后，沿着fi的参与网络中s到t得最短路进行增广就得到了fi+1(这个之前说过).为了求hi+1，我们需要求fi+1残余网络上的最短路，这个我们可以利用hi通过Dijkstra办到。</p>

<pre><code class="c++">using namespace std;

const int maxv = 22222;

const int INF = 0x3f3f3f3f;

struct Edge{
    int  to, cap, cost, rev;
    Edge(){}
    Edge(int to, int cap, int cost, int rev):to(to), cap(cap), cost(cost), rev(rev){}
};

typedef pair&lt;int, int&gt; P;
int V;//顶点数
vector&lt;Edge&gt; G[maxv];//图的邻接表表示
int dist[maxv];//最短距离
int prevv[maxv], preve[maxv];//最短路中的前驱节点和对应的边
int h[maxv];//顶点的势
// queue&lt;int&gt; que;


//向途中增加一条从from到to容量为cap费用为cost的边
void addEdge(int from, int  to, int cap, int cost)
{
    G[from].push_back(Edge(to, cap, cost, G[to].size()));
    G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1));
}
//求解从s到t流量为f的最小费用流
//如果不再能增广则返回-1
int min_cost_flow(int s, int  t, int f)
{
    int res = 0;
    while (f &gt; 0)
    {
        //利用Dijkstra算法求s到t的最短路
        priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que;
        fill(dist, dist+V, INF);
        //memset(inq, 0 , sizeof(inq));
        dist[s] = 0;
        que.push(make_pair(0, s));
        // inq[s] = true;
        while(!que.empty())
        {
            P p = que.top(); que.pop();
            int v = p.second;
            if (dist[v] &lt; p.first) continue;
            for (int i = 0; i &lt; G[v].size(); i++)
            {
                Edge&amp; e = G[v][i];
                if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[v] + e.cost + h[v] - h[e.to])
                {
                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];
                    prevv[e.to] = v;
                    preve[e.to] = i;
                    que.push(make_pair(dist[e.to], e.to));
                }
            }
        }

        if (dist[t] == INF)
            return -1;
        int d = f;
        for (int v = 0; v &lt; V; v++)
            h[v] += dist[v];

        for (int v = t; v != s; v = prevv[v])
            d = min(d, G[prevv[v]][preve[v]].cap);
        f -= d;
        res += d*h[t];
        for (int v = t; v!= s; v = prevv[v])
        {
            Edge &amp;e = G[prevv[v]][preve[v]];
            e.cap -= d;
            G[v][e.rev].cap += d;
        }
    }
    return res;
}
</code></pre>

<p>接下来看几道题。</p>

<p><a href="http://poj.org/problem?id=2175">POJ2175 Evacuation Plan</a></p>

<p>先用这道题来说一下，像这样要确定两类物体之间的对应关系，并希望使总花费最小的问题称为指派问题。如果把两类物体当做顶点，并在顶点之间连接权重为对应花费的边，就转化为了最小权匹配问题。与二分图的最大匹配可以用最大流求解类似，这个二分图最小权匹配也可以用最小费用流来求解，建图的方法几乎和二分图最大匹配的情况一样。</p>

<p>加设源点s和汇点t，需要连这样几类边：1.从s指向各个楼的边，流量为人数，花费为0；2.从各个楼指向各个防空洞的边，流量为无穷（只要有人在楼里切防空洞能撑得下就能过去），费用为题中给出公式计算出来的；3.从防空洞指向汇点的边，流量为防空洞的容量，花费为0.</p>

<p>这样建好图之后，就成了一个最小费用最大流问题，在流量最大的情况下取花费最小的（这里的流量肯定是总人数F），我们只需要求出最小花费跟题目中所给的方案比较即可，这个方法很简单，建好图就行，但是，实践发现，结果是TLE。这里说这种方法只不过是想让掌握一种二分图最小权匹配的方法，这里把代码挂出来。</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 555;

const int INF = 0x3f3f3f3f;

struct Edge{
    int  to, cap, cost, rev;
    Edge(){}
    Edge(int to, int cap, int cost, int rev):to(to), cap(cap), cost(cost), rev(rev){}
};

int V;//顶点数
vector&lt;Edge&gt; G[maxv];//图的邻接表表示
int dist[maxv];//最短距离
int prevv[maxv], preve[maxv];//最短路中的前驱节点和对应的边
queue&lt;int&gt; que;
bool inq[maxv];

//向途中增加一条从from到to容量为cap费用为cost的边
void addEdge(int from, int  to, int cap, int cost)
{
    G[from].push_back(Edge(to, cap, cost, G[to].size()));
    G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1));
}
//求解从s到t流量为f的最小费用流
//如果不再能增广则返回-1
int people_sum = 0;
int min_cost_flow(int s, int  t, int f)
{
    int res = 0;
    while (f &gt; 0)
    {
        //利用Bellman-Ford算法求s到t的最短路
        fill(dist, dist+V, INF);
        memset(inq, 0 , sizeof(inq));
        dist[s] = 0;
        que.push(s);
        inq[s] = true;
        while(!que.empty())
        {
            int u = que.front(); que.pop();
            inq[u] = false;
            for (int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = G[u][i];
                if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost)
                {
                    dist[e.to] = dist[u] + e.cost;
                    prevv[e.to] = u;
                    preve[e.to] = i;
                    if (!inq[e.to])
                    {
                        que.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }

        if (dist[t] == INF)
            return -1;
        int d = f;
        for (int v = t; v != s; v = prevv[v])
            d = min(d, G[prevv[v]][preve[v]].cap);
        f -= d;
        res += d*dist[t];
        for (int v = t; v!= s; v = prevv[v])
        {
            Edge &amp;e = G[prevv[v]][preve[v]];
            e.cap -= d;
            G[v][e.rev].cap += d;
        }
    }
    return res;
}
int N,M;
int X[maxv],Y[maxv],B[maxv],P[maxv],Q[maxv],C[maxv];
int E[maxv][maxv];
int main()
{
    int N,M;
    scanf("%d%d", &amp;N, &amp;M);
    for(int i = 0; i &lt; N; i++)
        scanf("%d%d%d", &amp;X[i], &amp;Y[i], &amp;B[i]);
    for(int i = 0; i &lt; M; i++)
        scanf("%d%d%d", &amp;P[i], &amp;Q[i], &amp;C[i]);
    for(int i = 0; i &lt; N; i++)
        for(int j = 0; j &lt; M; j++)
            scanf("%d", &amp;E[i][j]);
    int s = 0, t = N+M+1;
    V = t+1;
    int ans = 0;

    for (int i = 0; i &lt; N; i++)
    {
        addEdge(s, i+1, B[i], 0);
        people_sum += B[i];
    }
    for (int i = 0; i &lt; N; i++)
        for (int j = 0; j &lt; M; j++)
        {
            int c = abs(X[i] - P[j]) + abs(Y[i] - Q[j]) + 1;
            addEdge(i+1, 1+N+j, INF, c);
            ans += c*E[i][j];
        }
    for (int i = 0; i &lt; M; i++)
        addEdge(N+1+i, t, C[i], 0);

    if(min_cost_flow(s,t,people_sum) == ans)
        cout&lt;&lt;"OPTIMAL"&lt;&lt;endl;
    else
    {
        cout&lt;&lt;"SUBOPTIMAL"&lt;&lt;endl;
        for (int i = 0; i &lt; N; i++)
            for (int j = 0; j &lt; M; j++)
                printf("%d%c", G[N+1+j][i].cap, j == M-1 ? '\n':' ');
    }
    system("pause");
    return 0;
}
</code></pre>

<p>另外一种算法，称为消负环算法，根据我们前面的定理可以知道，只要当前图的残余网络含有负环，那么就一定不是最小费用流；如果不含有，那么就是最小费用流。</p>

<p>而这道题，只是让你判断给出的方案是不是最小费用流，如果不是的话还要求输出一个费用比给出的方案小（但不一定是最小费用流）的方案。那么我们就可以从负环这里入手，查找当前残余网络中是否含有负环，如果含有负环，就沿着负环（只是负环这一部分）对路径进行增广，费用就会减小且流量不变，由于只要求更优不要求最优，所以增广1即可。（事实上，这也是一种求最小费用流的方法，先任意给定一个合理的流，然后判断是否有负环，然后沿着负环增广，直到消除所有负环之后，就是最小费用流了，这种方法叫消负环法）</p>

<p>《挑战程序设计竞赛》上给出一种用floyd算法求负环的方法的代码，这里我打了出来</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 555;

const int INF = 0x3f3f3f3f;

struct Edge{
    int  to, cap, cost, rev;
    Edge(){}
    Edge(int to, int cap, int cost, int rev):to(to), cap(cap), cost(cost), rev(rev){}
};

int N,M;
int X[maxv],Y[maxv],B[maxv],P[maxv],Q[maxv],C[maxv];
int E[maxv][maxv];
int g[maxv][maxv];//距离矩阵
int prev[maxv][maxv];//最短路中的前驱
bool used[maxv];//找圈用的标记
void solve()
{
    int V = N+M+1;
    //计算距离矩阵
    for(int i = 0; i &lt; V; i++)
        fill(g[i], g[i]+V, INF);
    for (int j = 0; j &lt; M; j++)
    {
        int sum = 0;
        for (int i = 0; i &lt; N; i++)
        {
            int c = abs(X[i] - P[j]) + abs(Y[i] - Q[j]) + 1;
            g[i][N+j] = c;
            if (E[i][j] &gt; 0) g[N+j][i] = -c;
            sum += E[i][j];
        }
        if (sum &gt; 0) g[N+M][N+j] = 0;
        if (sum &lt; C[j]) g[N+j][N+M] = 0;
    }
    //用Floyd-Warshall算法查找负圈
    for (int i = 0; i &lt; V; i++)
        for (int j = 0; j &lt; V; j++)
            prev[i][j] = i;
    for (int k = 0; k &lt; V; k++)
        for (int i = 0; i &lt; V; i++)
            for (int j = 0; j &lt; V; j++)
            {
                if (g[i][j] &gt; g[i][k] + g[k][j])
                {
                    g[i][j] = g[i][k] + g[k][j];
                    prev[i][j] = prev[k][j];
                    if(i == j &amp;&amp; g[i][i] &lt; 0)
                    {
                        fill(used, used+V, false);
                        //找到负圈
                        for (int v = i; !used[v]; v = prev[i][v])
                        {
                            used[v] = true;
                            if (v != N+M &amp;&amp; prev[i][v] != N+M)
                                if (v &gt;= N)
                                    E[prev[i][v]][v-N]++;
                                else
                                    E[v][prev[i][v] - N]--;
                        }
                        printf("SUBOPTIMAL\n");
                        for (int x = 0; x &lt; N; x++)
                            for (int y = 0; y &lt; M; y++)
                                printf("%d%c", E[x][y], y == M-1?'\n':' ');
                        return;
                    }
                }
            }
    printf("OPTIMAL\n");
}
int main()
{
    while(~scanf("%d%d", &amp;N, &amp;M))
    {
        memset(E, 0 , sizeof(E));
        for(int i = 0; i &lt; N; i++)
            scanf("%d%d%d", &amp;X[i], &amp;Y[i], &amp;B[i]);
        for(int i = 0; i &lt; M; i++)
            scanf("%d%d%d", &amp;P[i], &amp;Q[i], &amp;C[i]);
        for(int i = 0; i &lt; N; i++)
            for(int j = 0; j &lt; M; j++)
                scanf("%d", &amp;E[i][j]);
       solve();
      // system("pause");
    }
    return 0;
}
</code></pre>

<p>我自己写了个SPFA消负环，不过现在还在WA着o(╯□╰)o，目前我已经暂时找不到错在哪里了T_T！</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 555;

const int INF = 0x3f3f3f3f;

struct Edge{
    int  to, cap, cost, rev;
    Edge(){}
    Edge(int to, int cap, int cost, int rev):to(to), cap(cap), cost(cost), rev(rev){}
};

int V;//顶点数
vector&lt;Edge&gt; G[maxv];//图的邻接表表示
int dist[maxv];//最短距离
int prevv[maxv], preve[maxv];//最短路中的前驱节点和对应的边
queue&lt;int&gt; que;
bool inq[maxv];
int cnt[maxv];
bool vis[maxv];
int N,M;

//向途中增加一条从from到to容量为cap费用为cost的边
void addEdge(int from, int  to, int cap, int cost)
{
    G[from].push_back(Edge(to, cap, cost, G[to].size()));
    G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1));
}
//求解从s到t流量为f的最小费用流
//如果不再能增广则返回-1
bool SPFA(int s, int t)
{
    fill(dist,dist+V,INF);
    fill(inq, inq+V, 0);
    fill(cnt, cnt+V, 0);
    while(!que.empty())
        que.pop();
    dist[s] = 0;
    que.push(s);
    inq[s] = 1;

    while(!que.empty())
    {
        int u = que.front(); que.pop();
        inq[u] = false;
       // cout&lt;&lt;u&lt;&lt;" "&lt;&lt;dist[u]&lt;&lt;endl;
        //system("pause");
        for (int i = 0; i &lt; G[u].size(); i++)
        {
            Edge&amp; e = G[u][i];
           // cout&lt;&lt;u&lt;&lt;" "&lt;&lt;e.to&lt;&lt;" "&lt;&lt;e.cap&lt;&lt;endl;
            if ((u == s || e.cap &gt; 0) &amp;&amp; dist[e.to] &gt; dist[u] + e.cost &amp;&amp; e.to != 0)
            {
                // cout&lt;&lt;u&lt;&lt;" "&lt;&lt;e.to&lt;&lt;" "&lt;&lt;e.cap&lt;&lt;endl;
                //system("pause");
                dist[e.to] = dist[u] + e.cost;
                prevv[e.to] = u;
                preve[e.to] = i;
                if (!inq[e.to])
                {
                    que.push(e.to);
                    inq[e.to] = true;
                    if (++cnt[e.to] &gt; V)
                    {
                        memset(vis, 0, sizeof(vis));
                        for (int v = e.to; !vis[v]; v = prevv[v])
                        {
                            vis[v] = true;
                            if (v != s &amp;&amp; prevv[v] != s)
                            {
                                Edge&amp; ee = G[prevv[v]][preve[v]];
                                ee.cap--;
                                G[v][ee.rev].cap++;
                            }
                        }
                        return false;
                    }
                }
            }
        }
    }
    return true;
}
int X[maxv],Y[maxv],B[maxv],P[maxv],Q[maxv],C[maxv];
int E[maxv][maxv];
int main()
{
    int N,M;
    while(~scanf("%d%d", &amp;N, &amp;M))
    {
        memset(E, 0 , sizeof(E));
        for (int i = 0; i &lt; V; i++)
            G[i].clear();
        for(int i = 0; i &lt; N; i++)
            scanf("%d%d%d", &amp;X[i], &amp;Y[i], &amp;B[i]);
        for(int i = 0; i &lt; M; i++)
            scanf("%d%d%d", &amp;P[i], &amp;Q[i], &amp;C[i]);
        for(int i = 0; i &lt; N; i++)
            for(int j = 0; j &lt; M; j++)
                scanf("%d", &amp;E[i][j]);
        int s = 0, t = N+M+1;
        V = t+1;
        for (int i = 0; i &lt; N; i++)
            addEdge(s, i+1, B[i], 0);
        for (int i = 0; i &lt; M; i++)
            addEdge(N+1+i, t, C[i], 0);
        for (int i = 0; i &lt; N; i++)
            for (int j = 0; j &lt; M; j++)
            {
                int c = abs(X[i] - P[j]) + abs(Y[i] - Q[j]) + 1;
                addEdge(i+1, j+N+1, INF, c);
                if (E[i][j] &gt; 0)
                {
                    G[s][i].cap -= E[i][j];
                    G[i+1][0].cap += E[i][j];
                    G[j+N+1][0].cap -= E[i][j];
                    G[t][j].cap += E[i][j];
                    G[j+N+1][i+1].cap += E[i][j];
                }
            }
        //如果通过SPFA没有找到负环，说明是最小费用，否则，输出一个沿着找到的负环增广1流量的结果
        /*for (int i = 0; i &lt; V; i++)
        {
            cout&lt;&lt;i&lt;&lt;":";
            for (int j = 0; j &lt; G[i].size(); j++)
                cout&lt;&lt;G[i][j].to&lt;&lt;"---"&lt;&lt;G[i][j].cap&lt;&lt;" "&lt;&lt;G[i][j].cost&lt;&lt;"\t";
            cout&lt;&lt;endl;
        }*/
        if (SPFA(s,t))
            cout&lt;&lt;"OPTIMAL"&lt;&lt;endl;
        else
        {
            cout&lt;&lt;"SUBOPTIMAL"&lt;&lt;endl;
            for (int i = 0; i &lt; N; i++)
                for (int j = 0; j &lt; M; j++)
                    printf("%d%c",G[N+1+j][1+i].cap, j == M-1 ? '\n':' ');

        }
      // system("pause");
    }
    return 0;
}
</code></pre>

<p><a href="http://poj.org/problem?id=3686">POJ3686 The Windy’s</a></p>

<p>这个题更当初那个火场逃生的题的构图挺像的，也是把一个东西分成了若干个，每个代表不同的东西。简单说下思路。</p>

<p>其实书中所给的这个题的思考方向我也感觉挺好的，大多数题都应该这么想，由简及繁。最小化平均时间，就相当于最小化总时间；首先，我们想，如果每个工厂只能加工一个玩具的话（一对一），那么问题就是很简单的普通的指派问题了，但是他不是这样的。那我们就想办法把他变成这样。</p>

<p>多个玩具多个工厂，我们先考虑一个工厂，在只有一个工厂的情况下，假设在这个工厂加工i号玩具的加工时间是ti，总时间是T，那么,如果按照a1,a2,a3,…………,an的顺序加工，那么T = ta1 + (ta1+ta2) + (ta1+ta2+ta3) + ………… + (ta1+ta2+…………+tan) = nta1 + (n-1)ta2 + (n-2)ta3 + ………… + tan。 这样我们就可以看成多个职能制作一个玩具的工厂，各自需要花费1倍到n倍的时间。然后对于每一个工厂都这样来分，这样建图的话，这道题也就不过是一个普通的指派问题了，很容易用最小费用流解决，代码给出来。</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 22222;

const int INF = 0x3f3f3f3f;

struct Edge{
    int  to, cap, cost, rev;
    Edge(){}
    Edge(int to, int cap, int cost, int rev):to(to), cap(cap), cost(cost), rev(rev){}
};

int V;//顶点数
vector&lt;Edge&gt; G[maxv];//图的邻接表表示
int dist[maxv];//最短距离
int prevv[maxv], preve[maxv];//最短路中的前驱节点和对应的边
queue&lt;int&gt; que;
bool inq[maxv];
void init()
{
    for (int i = 0; i &lt; V; i++)
        G[i].clear();
}
//向途中增加一条从from到to容量为cap费用为cost的边
void addEdge(int from, int  to, int cap, int cost)
{
    G[from].push_back(Edge(to, cap, cost, G[to].size()));
    G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1));
}
//求解从s到t流量为f的最小费用流
//如果不再能增广则返回-1
int min_cost_flow(int s, int  t, int f)
{
    int res = 0;
    while (f &gt; 0)
    {
        //利用Bellman-Ford算法求s到t的最短路
        fill(dist, dist+V, INF);
        memset(inq, 0 , sizeof(inq));
        dist[s] = 0;
        que.push(s);
        inq[s] = true;
        while(!que.empty())
        {
            int u = que.front(); que.pop();
            inq[u] = false;
            for (int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = G[u][i];
                if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost)
                {
                    dist[e.to] = dist[u] + e.cost;
                    prevv[e.to] = u;
                    preve[e.to] = i;
                    if (!inq[e.to])
                    {
                        que.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }

        if (dist[t] == INF)
            return -1;
        int d = f;
        for (int v = t; v != s; v = prevv[v])
            d = min(d, G[prevv[v]][preve[v]].cap);
        f -= d;
        res += d*dist[t];
        for (int v = t; v!= s; v = prevv[v])
        {
            Edge &amp;e = G[prevv[v]][preve[v]];
            e.cap -= d;
            G[v][e.rev].cap += d;
        }
    }
    return res;
}

int main()
{
    int T;
    cin&gt;&gt;T;
    while(T--)
    {
        //0 起点s
        //1-n 玩具
        //n+(k-1)*m+i i号工厂(1 =&lt; i &lt;= m)，k倍率。
        int n,m;
        scanf("%d%d", &amp;n, &amp;m);
        int s = 0,t = n*(m+1)+1;
        for (int i = 1; i &lt;= n; i++)
            addEdge(s, i, 1, 0);
        for (int j = 0; j &lt; m; j++)
            for (int k = 1; k &lt;= n; k++)
                addEdge(n+(k-1)*m+1+j, t, 1, 0);
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= m; j++)
            {
                int p;
                scanf("%d", &amp;p);
                for (int k = 1; k &lt;= n; k++)
                    addEdge(i, n+(k-1)*m+j, 1, k*p);
            }
        V = t+1;
        printf("%.6f\n", (double)min_cost_flow(s,t,n)/n );
        init();
    }
    return 0;
}
</code></pre>

<p><a href="http://poj.org/problem?id=3680">POJ 3680 Intervals</a></p>

<p>这道题，对于现在的我来说，还是比较有难度的，构思也是比较巧妙。想不到的话，应该是因为太年轻了。</p>

<p>同样的解题步骤，由简及繁。先考虑K=1的情况，这时问题等价于从这N个区域中选取一个元素互不相交的子集，目标是最大化子集元素的权重和。这种问题又被称为区间图的最大权独立集问题，可以用如下的DP算法求解。</p>

<p>首先，对所有区间的端点排序得到一个x[]数组，另</p>

<p>dp[i] = 只考虑 b[k] &lt;= x[i] 的区间所能得到的最大总权重</p>

<p>则有</p>

<p>dp[i] = max(dp[i-1],max{dp[j] + w[k] | a[k] = x[j] 且 b[k] = x[i]})</p>

<p>以上这个式子，说实话，好好想一想是能够想到的，但是关键是你会不会先去想K=1的情况。了解了这种情况之后，我们在参考它看一下K>1时的解法。看一下上面的那个DP递推式，仔细观察，它可以看做是在求解如下所建的图中的最短路问题：</p>

<p>给m个端点x[i]建立对应的顶点v[i]；
从v[i-1]向v[i]连一条费用为0的边
对于区间k，如果a[k] = x[i] 且 b[k] = x[i]，则从v[j]想v[i]连一条费用为-w[k]的边
K=1时DP所得到的最大总权重，就是该图中从v[0]到v[m-1]的最短路的费用的相反数。</p>

<p>在该图中沿着权重为-w[i]的边增广就对应于选中区间w[i]，因为每个区间只能被选中1次，所以这类变的容量为1；其余边的容量为INF。那么一个流量为K的v[0]-v[m-1]流对应原题中所要求的K割子集。利用最小费用流即可，不过这里有一点需要注意，本题的图中含有负边权，我们可以本文末尾的专栏中提到的技术，先令所有负权边初始都满流来处理。先给代码了</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 22222;
const int maxn = 555;
const int INF = 0x3f3f3f3f;

struct Edge{
    int  to, cap, cost, rev;
    Edge(){}
    Edge(int to, int cap, int cost, int rev):to(to), cap(cap), cost(cost), rev(rev){}
};

int V;//顶点数
vector&lt;Edge&gt; G[maxv];//图的邻接表表示
int dist[maxv];//最短距离
int prevv[maxv], preve[maxv];//最短路中的前驱节点和对应的边
queue&lt;int&gt; que;
bool inq[maxv];
void init()
{
    for (int i = 0; i &lt; V; i++)
        G[i].clear();
}
//向途中增加一条从from到to容量为cap费用为cost的边
void addEdge(int from, int  to, int cap, int cost)
{
    G[from].push_back(Edge(to, cap, cost, G[to].size()));
    G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1));
}
//求解从s到t流量为f的最小费用流
//如果不再能增广则返回-1
int min_cost_flow(int s, int  t, int f)
{
    int res = 0;
    while (f &gt; 0)
    {
        //利用Bellman-Ford算法求s到t的最短路
        fill(dist, dist+V, INF);
        memset(inq, 0 , sizeof(inq));
        dist[s] = 0;
        que.push(s);
        inq[s] = true;
        while(!que.empty())
        {
            int u = que.front(); que.pop();
            inq[u] = false;
            for (int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = G[u][i];
                if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost)
                {
                    dist[e.to] = dist[u] + e.cost;
                    prevv[e.to] = u;
                    preve[e.to] = i;
                    if (!inq[e.to])
                    {
                        que.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }

        if (dist[t] == INF)
            return -1;
        int d = f;
        for (int v = t; v != s; v = prevv[v])
            d = min(d, G[prevv[v]][preve[v]].cap);
        f -= d;
        res += d*dist[t];
        for (int v = t; v!= s; v = prevv[v])
        {
            Edge &amp;e = G[prevv[v]][preve[v]];
            e.cap -= d;
            G[v][e.rev].cap += d;
        }
    }
    return res;
}

int n,k;
int a[maxn],b[maxn],w[maxn];
int x[maxn],tmp[maxn];
int cnttmp,cntx;

int main()
{
    int T;
    cin&gt;&gt;T;
    while(T--)
    {
        scanf("%d%d", &amp;n, &amp;k);
        cnttmp = 0;
        int ans = 0;
        for (int i = 0; i &lt; n; i++)
        {
            scanf("%d%d%d", &amp;a[i], &amp;b[i], &amp;w[i]);
            tmp[cnttmp++] = a[i];
            tmp[cnttmp++] = b[i];
        }
        sort(tmp, tmp+cnttmp);
        x[0] = tmp[0];
        cntx = 1;
        for (int i = 1; i &lt; cnttmp; i++)
            if (tmp[i] != tmp[i-1])
            {
                x[cntx++] = tmp[i];
                addEdge(cntx-2, cntx-1, INF, 0);
            }
       /* for (int i = 0; i &lt; cntx; i++)
            cout&lt;&lt;x[i]&lt;&lt;" ";
        cout&lt;&lt;endl;*/
      //  cout&lt;&lt;1&lt;&lt;endl;
        int s = cntx, t = cntx+1;
        V = t+1;
        addEdge(s, 0, k, 0);
        addEdge(cntx-1, t, k, 0);
        for (int i = 0; i &lt; n; i++)
        {
            int u = lower_bound(x, x+cntx, a[i]) - x;
            int v = lower_bound(x, x+cntx, b[i]) - x;
            //连一条从u到v的满流的边，流量为1，费用为-w[i]；
            /*cout&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;endl;*/
            addEdge(v, u, 1, w[i]);
            addEdge(s, v, 1, 0);
            addEdge(u, t, 1, 0);
            ans -= w[i];
        }

        ans += min_cost_flow(s, t, k+n);
        cout&lt;&lt;-ans&lt;&lt;endl;
        init();
    }
    return 0;
}
</code></pre>

<p>PS:下面专栏中我还有一部分没有理解透彻</p>

<blockquote><p>专栏：最小费用流的各种变体</p>

<blockquote><p>与最大流相同的变体 + 都采用与最大流相同的处理方法是可以的，这里不赘述了。要说的一点是，对于边上有最小流量限制的情况，还有更简单的方法，对于e = (u,v)， 新加一天边e’ = (u,v)，再另c’[e] = c[e] - b[e], c’[e’] = b[e], d’[e] = d[e], d’[e’] = d[e] - M(一个足够大常数)，对变形后的新图求解最小费用流，再在结果上加上M*(sigma(b[e]))就好。这样就把问题转为了没有最小流量限制的情况</p>

<p>流量任意的情况 + 有些题目中，需要计算包含负权边的图中流量任意但费用最小的流。这种情况下，根据最小费用流算法中hi+1[v] >= hi[v]的性质，我们只要在hi[t]&lt;0是不断增广就好了。</p>

<p>费用为负数的情况 + 如果图中含有负权边，那么最初计算势的值就不能用Dijkstra算法，而需要改用SPFA算法。另外，如果图中还有负环，可以利用SPFA寻找负环，并在负环上尽量增广将其消去。 + 此外，在有些情况下，适当的变形可以避免负权边。比如下面的，也是上面个那道题用到的方法，在流量F一定的情况下，也可以采取与最小流量限制中类似的变形将负权边出去。新增源点S和汇点T，从S向s连一条容量为F费用为0的边，从t向T连一条容量为F费用为0的边。对于负权边e = (u,v)，可以让它一开始就已经满流。再从S向v连一条容量为c[e]费用为0的边，从u向T连一条容量为c[e]费用为0的边。这样变形后，我们就除去了图中的负权边，而原图流量为F+sigma（c[e]d[e]）(e为负权边)的最小费用就等于新图流量F的最小费用流加上sigma（c[e]d[e]）(e为负权边)。</p></blockquote></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图论总结(二)]]></title>
    <link href="http://whn757397540.github.io/blog/2015/03/14/tu-lun-zong-jie-er/"/>
    <updated>2015-03-14T18:54:17+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/03/14/tu-lun-zong-jie-er</id>
    <content type="html"><![CDATA[<h5>最大流的几种方法总结</h5>

<!--more-->


<p>这里总结一下最大流的几种算法的区别，以及最大流的一些使用技巧。</p>

<p>这里以一道例题来比较一下这几种方法。先放题</p>

<p><a href="http://poj.org/problem?id=1149">POJ1149 PIGS</a></p>

<p>先来说下题意和构图。</p>

<p>题意： 有人买猪，买主带着钥匙，卖猪的人没有钥匙。有以下几张限制条件：1.只有买猪的人能开门，且买猪的人可能带有多把钥匙；2.买猪的人每天只来一个；3.卖猪的人可以在买猪的人带来钥匙的那一天在打开的猪圈之间任意调动猪（也就是说，买猪的人走后猪圈重新关上）；4.猪圈的容量无上限；5.给出每个猪圈初始有的猪的个数；6.卖猪的人可以决定是否卖给买猪的人；7.给出每个人要买的猪的个数（可以少不可以多）。</p>

<p>首先，我们应该解决怎么构图的问题。分析下题意，容易看出是一个最大流问题，流体是猪，流向是从猪圈流向人。那么我们建图肯定是从猪圈指向人了。我们可以这样来建图。首先，虚拟一个源点s，s指向所有的猪圈，边的权值就是猪圈初始的猪的数量；然后，虚拟一个汇点t，所有的人最终指向t（因为他问的是最多能卖多少只猪，跟是谁买的没有关系），边的权值就是那个人想要的猪的数量。最后，也是最关键的，中间的图怎么建。关于这点，分析一下，我们知道，对于一个人来说，他有那个猪圈的钥匙，就可以从哪个猪圈里面选猪，猪是从猪圈流向人的，而且人选猪的数量也是没有限制的（多选了可以放回去，重点在于这个边是没有限制的），所以这个边应该是从猪圈指向持有猪圈钥匙的人，权值是INF；最后要解决的一点就是，卖猪的人可以在猪圈打开的时候任意调整猪的位置这个条件怎么用，很容易知道，假如两个人拥有同一个猪圈的钥匙，那么后来的那个人就可以从先来的那个人那里得到猪（先来的那个人手头的猪放到那个公共猪圈中，再流向后来的那个人），所以，还应该有这样一条边，对于拥有同一个猪圈钥匙的人，有一条从先来的指向后来的的边，权值是INF（因为猪圈的容量是无上限的）。</p>

<p>有了上面的分析，图就建好了，接下来就是求从s到t的最大流了。我用了4种方法来敲，其中Full-Fulkerson算法和Dinic是借鉴《挑战程序设计竞赛》书上的写法，Edmonds-Karp算法和ISAP算法是借鉴的刘汝佳《算法竞赛入门经典》上的写法。接下来挂出四种方法的代码。</p>

<p>Full-Fulkerson</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include&lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 10000;
const int maxe = 55555;
const int INF = 0x3f3f3f3f;
struct Edge{
    int to,cap,rev;

    Edge(){}
    Edge(int to, int cap, int rev):to(to),cap(cap),rev(rev){}
};

vector&lt;Edge&gt; G[maxv];
bool used[maxv];

void addEdge(int from, int to, int cap)
{
    G[from].push_back(Edge(to,cap,G[to].size()));
    G[to].push_back(Edge(from,0,G[from].size()-1));
}

int dfs(int v, int t, int f)
{
    if (v == t) return f;
    used[v] = true;
    for (int i = 0; i &lt; G[v].size(); i++)
    {
        Edge &amp;e = G[v][i];
        if (!used[e.to] &amp;&amp; e.cap &gt; 0)
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if (d&gt;0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

int max_flow(int s, int t)
{
    int flow = 0;
    while(true)
    {
        memset(used, 0 ,sizeof(used));
        int f = dfs(s,t,INF);
        if (f == 0) return flow;
        flow += f;
    }
}

vector&lt;int&gt; rec[maxv];
int main()
{
    int m,n;
    scanf("%d%d", &amp;m, &amp;n);
    int t = m+n+1, s = 0;
    for (int i = 1; i &lt;= m; i++)
    {
        int x;
        scanf("%d", &amp;x);
        addEdge(s,i,x);
    }
    for (int i = m+1; i &lt;= m+n; i++)
    {
        int nn;
        scanf("%d", &amp;nn);
        for (int j = 0; j &lt; nn; j++)
        {
            int mm;
            scanf("%d", &amp;mm);
            rec[mm].push_back(i);
            addEdge(mm, i, INF);
        }
        int tt;
        scanf("%d", &amp;tt);
        addEdge(i,t,tt);
    }
  for (int i = 1; i &lt;= m; i++)
        for (int j = 1; j &lt; rec[i].size(); j++)
                addEdge(rec[i][j-1], rec[i][j], INF);
    printf("%d\n", max_flow(s,t));
    return 0;
}
</code></pre>

<p>EK</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include&lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 10000;
const int maxe = 55555;
const int INF = 0x3f3f3f3f;
struct Edge{
    int from, to, cap, flow;
    Edge(int u, int v, int c, int f): from(u), to(v), cap(c),flow(f){}
};

vector&lt;Edge&gt; edges;
vector&lt;int&gt; G[maxv];
int a[maxv];
int p[maxv];
int nume;
void init(int n)
{
    for (int i = 0; i &lt; n; i++) G[i].clear();
    edges.clear();
}

void addEdge(int from, int to, int cap)
{
    edges.push_back(Edge(from, to, cap, 0));
    edges.push_back(Edge(to, from, 0, 0));
    nume = edges.size();
    G[from].push_back(nume-2);
    G[to].push_back(nume-1);
}

int max_flow(int s, int t)
{
    int flow = 0;
    while(true)
    {
        memset(a, 0 , sizeof(a));
        queue&lt;int&gt; Q;
        Q.push(s);
        a[s] = INF;
        while(!Q.empty())
        {
            int x = Q.front();Q.pop();
            for (int i = 0; i &lt; G[x].size(); i++)
            {
                Edge&amp; e = edges[G[x][i]];
                if(!a[e.to] &amp;&amp; e.cap &gt; e.flow)
                {
                    p[e.to] = G[x][i];
                    a[e.to] = min(a[x], e.cap - e.flow);
                    Q.push(e.to);
                }
            }
            if (a[t])
                break;
        }
        if(!a[t]) break;
        for (int u = t; u != s; u = edges[p[u]].from)
        {
            edges[p[u]].flow += a[t];
            edges[p[u]^1].flow -= a[t];
        }
        flow += a[t];
    }
    return flow;
}

vector&lt;int&gt; rec[maxv];
int main()
{
    int m,n;
    scanf("%d%d", &amp;m, &amp;n);
    int t = m+n+1, s = 0;
    for (int i = 1; i &lt;= m; i++)
    {
        int x;
        scanf("%d", &amp;x);
        addEdge(s,i,x);
    }
    for (int i = m+1; i &lt;= m+n; i++)
    {
        int nn;
        scanf("%d", &amp;nn);
        for (int j = 0; j &lt; nn; j++)
        {
            int mm;
            scanf("%d", &amp;mm);
            rec[mm].push_back(i);
            addEdge(mm, i, INF);
        }
        int tt;
        scanf("%d", &amp;tt);
        addEdge(i,t,tt);
    }
   /* for (int i = 0; i &lt;= n+m+1; i++)
    {
        printf("%d:\n", i);
        for (int j = 0; j &lt; G[i].size(); j++)
            printf("\t%d %d\n",G[i][j].to, G[i][j].cap);
        cout&lt;&lt;endl;
    }*/
  for (int i = 1; i &lt;= m; i++)
        for (int j = 1; j &lt; rec[i].size(); j++)
                addEdge(rec[i][j-1], rec[i][j], INF);
    printf("%d\n", max_flow(s,t));
    return 0;
}
</code></pre>

<p>Dinic</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include&lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 10000;
const int maxe = 55555;
const int INF = 0x3f3f3f3f;
struct Edge{
    int to,cap, rev;
    Edge(int to, int cap, int rev):to(to), cap(cap), rev(rev){}
};

vector&lt;Edge&gt; G[maxv];
int level[maxv];//顶点到源点的距离标号
int iter[maxv];//当前弧，在其之前的边已经没有用了

void addEdge(int from, int to, int cap)
{
    G[from].push_back(Edge(to, cap, G[to].size()));
    G[to].push_back(Edge(from, 0, G[from].size()-1));
}

void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for (int i = 0; i &lt; G[v].size(); i++)
        {
            Edge &amp;e = G[v][i];
            if (e.cap&gt;0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

int dfs(int v, int t, int f)
{
    if(v == t)
        return f;
    for (int &amp;i = iter[v]; i &lt; G[v].size(); i++)
    {
        Edge &amp;e = G[v][i];
        if (e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if (d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

int max_flow(int s, int t)
{
    int flow = 0;
    while(true)
    {
        bfs(s);
        if (level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while ((f = dfs(s, t, INF)) &gt; 0)
            flow += f;
    }
}

vector&lt;int&gt; rec[maxv];
int main()
{
    int m,n;
    scanf("%d%d", &amp;m, &amp;n);
    int t = m+n+1, s = 0;
    for (int i = 1; i &lt;= m; i++)
    {
        int x;
        scanf("%d", &amp;x);
        addEdge(s,i,x);
    }
    for (int i = m+1; i &lt;= m+n; i++)
    {
        int nn;
        scanf("%d", &amp;nn);
        for (int j = 0; j &lt; nn; j++)
        {
            int mm;
            scanf("%d", &amp;mm);
            rec[mm].push_back(i);
            addEdge(mm, i, INF);
        }
        int tt;
        scanf("%d", &amp;tt);
        addEdge(i,t,tt);
    }
   /* for (int i = 0; i &lt;= n+m+1; i++)
    {
        printf("%d:\n", i);
        for (int j = 0; j &lt; G[i].size(); j++)
            printf("\t%d %d\n",G[i][j].to, G[i][j].cap);
        cout&lt;&lt;endl;
    }*/
  for (int i = 1; i &lt;= m; i++)
        for (int j = 1; j &lt; rec[i].size(); j++)
                addEdge(rec[i][j-1], rec[i][j], INF);
    printf("%d\n", max_flow(s,t));
    return 0;
}
</code></pre>

<p>ISAP</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include&lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 10000;
const int maxe = 55555;
const int INF = 0x3f3f3f3f;
struct Edge{
    int from, to, cap, flow;
    Edge(int u, int v, int c, int f): from(u), to(v), cap(c),flow(f){}
};

vector&lt;Edge&gt; edges;
vector&lt;int&gt; G[maxv];
int a[maxv];//当前节点捏流量
int p[maxv];//父亲节点，回溯路径用到
int d[maxv];//到终点距离
int iter[maxv];//当前弧下标
int num[maxv];
int nume;
void init(int n)
{
    for (int i = 0; i &lt; n; i++) G[i].clear();
    edges.clear();
}

void addEdge(int from, int to, int cap)
{
    edges.push_back(Edge(from, to, cap, 0));
    edges.push_back(Edge(to, from, 0, 0));
    nume = edges.size();
    G[from].push_back(nume-2);
    G[to].push_back(nume-1);
}


void bfs(int t)
{
    memset(d, -1, sizeof(d));
    d[t] = 0;
    queue&lt;int&gt; que;
    que.push(t);
    while(!que.empty())
    {
        int u = que.front();que.pop();
        for (int i = 0; i &lt; G[u].size(); i++)
        {
            Edge &amp;e = edges[G[u][i]^1];
            if (e.cap &gt; e.flow &amp;&amp; d[e.from] &lt; 0)
            {
                d[e.from] = d[u] + 1;
                que.push(e.from);
            }
        }
    }
}

int add(int s, int t)
{
    int u = t,df = INF;
    //从汇点到源点通过p追踪增广路径，df为一路上最小的残量
    while(u != s)
    {
        Edge &amp;e = edges[p[u]];
        df = min(df, e.cap - e.flow);
        u = edges[p[u]].from;
    }
    u = t;
    //从汇点到源点更新流量
    while(u != s)
    {
        edges[p[u]].flow += df;
        edges[p[u]^1].flow -= df;
        u = edges[p[u]].from;
    }
    return df;
}


int max_flow(int s, int t)
{
    int flow = 0;
    bfs(t);
    memset(num, 0, sizeof(num));
    for (int i = 0; i &lt;= t; i++)
        num[d[i]]++;
    int u = s;
    memset(iter, 0, sizeof(iter));
    while(d[s] &lt;= t)
    {
        //cout&lt;&lt;d[s]&lt;&lt;endl;
       // system("pause");
        if (u == t)
        {
            flow += add(s, t);
            u = s;
        }
        bool flag = false;
        for (int i = iter[u]; i &lt; G[u].size(); i++)
        {
            Edge &amp;e = edges[G[u][i]];
            if (e.cap &gt; e.flow &amp;&amp; d[u] == d[e.to] + 1)
            {
                flag = true;
                p[e.to] = G[u][i];
                iter[u] = i;
                u = e.to;
                break;
            }
        }
        if (!flag) // restart
        {
           // cout&lt;&lt;1&lt;&lt;endl;
            int m = t;
            for (int i = 0; i &lt; G[u].size(); i++)
            {
                Edge &amp;e = edges[G[u][i]];
                if (e.cap &gt; e.flow)
                    m = min(m, d[e.to]);
            }
            if (--num[d[u]] == 0)
                break;//gap优化
            num[d[u] = m+1] ++;
            iter[u] = 0;
            if (u != s)
                u = edges[p[u]].from;
        }
    }
    return flow;
}

vector&lt;int&gt; rec[maxv];
int main()
{
    int m,n;
    scanf("%d%d", &amp;m, &amp;n);
    int t = m+n+1, s = 0;
    for (int i = 1; i &lt;= m; i++)
    {
        int x;
        scanf("%d", &amp;x);
        addEdge(s,i,x);
    }
    for (int i = m+1; i &lt;= m+n; i++)
    {
        int nn;
        scanf("%d", &amp;nn);
        for (int j = 0; j &lt; nn; j++)
        {
            int mm;
            scanf("%d", &amp;mm);
            rec[mm].push_back(i);
            addEdge(mm, i, INF);
        }
        int tt;
        scanf("%d", &amp;tt);
        addEdge(i,t,tt);
    }
   /* for (int i = 0; i &lt;= n+m+1; i++)
    {
        printf("%d:\n", i);
        for (int j = 0; j &lt; G[i].size(); j++)
            printf("\t%d %d\n",G[i][j].to, G[i][j].cap);
        cout&lt;&lt;endl;
    }*/
  for (int i = 1; i &lt;= m; i++)
        for (int j = 1; j &lt; rec[i].size(); j++)
                addEdge(rec[i][j-1], rec[i][j], INF);
    printf("%d\n", max_flow(s,t));
    return 0;
}
</code></pre>

<p>简单总结一下几种方法的区别，如果有说得不好不对的地方，还请指正。</p>

<p>首先，Full-Fulkerson算法，就是运用dfs随意找一条可以达到的路径，然后求增广路一直到没有增广路为止。复杂度（O(V<sup>2</sup> E)），这道题的运行时间200多ms;</p>

<p>然后，Edmonds-Karp算法（我看百度百科上说就是SAP算法，搞得我很混乱），其实就是把原来的深搜换成了广搜,记录下路径来更新当前选择的路径的流量就行，能保证每次选的都是最短路，相比如Full-Fulkerson算法，比较不容易被卡，复杂度（O（VE<sup>2</sup>））这道题的运行时间150ms左右;</p>

<p>再之后，Dinic算法，是对Full-Fulkerson算法的一种改进，先把图进行分层（用bfs给每个节点标明深度），然后用dfs找最短路的路径流，更新。完了之后重新bfs分层，dfs，一直到源点和汇点分离为止。这个就优化了好多了，还有一个当前弧优化，事实上就是对于一次dfs来说，用过一次的弧就不要再用了，能省好多时间的！复杂度与Full-Fulkerson相同，但是要快很多很多，这道题加上当前弧优化不到20ms，不加90ms左右。</p>

<p>最后，ISAP算法，说实话，还不是非常清楚，原理大概明白了，这个<a href="http://blog.csdn.net/pi9nc/article/details/11848245">博客</a>说得不错感觉说得挺清楚的。时间复杂度桶EK算法，但是要快好多，这道题的时间50ms左右。</p>

<p>总之，理解算法的内涵，然后找到一些好的板子就好，这些算法事实上不需要多熟悉，能够会用板子就行，关键是要能够构出图来，这个就需要多练了。</p>

<p>今天的完成度跟我计划出入有点大，还有一些应用以及变形没写。</p>

<p>好，继续补完网络流的这一部分，下面这部分很重要！（当然，也是来自于书本）</p>

<blockquote><p>专栏：最大流的各种变体</p>

<blockquote><p>多个源点和汇点的情况：</p>

<blockquote><p>上面那道题实际上就可以看成是这样的情况，就是有多个源点和汇点，不用细说了吧 。因为我们只知道单个源点和单个汇点的最大流的算法，所以对于这种情况，我们采取的办法就是增加一个超级源点S和一个超级汇点T，从S向每个源点连一条容量为对应在那个点的最大流出容量的边，从每个汇点向T连一条熔炼为定影那个点的最大流入容量的那个边。不过，如果有特殊要求（比如从某个源点流出的必须流入某些指定的汇点）时，是不能这样求解的，（PS:这种情况被称为多物网络流问题，目前尚未有已知的高效算法，竞赛中也几乎不会出现）。</p></blockquote>

<p>无向图的情况：</p>

<blockquote><p>我们常用到的是求有向图的的最大流，对于无向图怎么来求呢？记住一点，一个无向的边，跟两个流量相同方向相反的有向边是等效的，把一个无向边拆成两个有向边建图就好。</p></blockquote>

<p>顶点上也有容量限制的情况：</p>

<blockquote><p>这种情况下，我们只需要把一个点拆成2个点即可，例如原图中有一个点p，顶点限制为lim，我们只需要把他拆成p1和p2两个点，然后把本来指向p的边指向p1，把从p指出的边改为从p2指出，然后再连一条从p1指向p2的权威lim的边即可！应该比较容易想明白.</p></blockquote>

<p>有最小流量限制的情况：</p>

<blockquote><p>这个比较复杂，不太好说，参考周源《有上下界的网络流》吧（虽然我还没看），那上面也有2到例题，就在群里。</p></blockquote>

<p>图发生部分变化的情况</p>

<blockquote><p>这个指的是，在有些时候，我们求完某个图的最大流之后，需要对原图中的一部分做一些变化，再对新图求最大流。这种情况下，有些时候我们不需要重新计算最大流，而是可以重复利用前一步的结果，高效地求出新的最大流。主要考虑两种情况</p>

<p>首先，我们考虑边e(u,v)的容量增加的情况，我们只需要在原图最大流f的基础上，不断寻求增广路增广，就可以求得新图的最大流。当有多条边的容量同时增加的情况也是一样的，可以在原图的流的基础上进行求解。（我感觉，再多加一条边也是一样的）</p>

<p>然后，我们再来考虑一下变e(u,v)的容量减少1的情况。如果原图的最大六中，有f(e)&lt;=c(e)-1的话，那么它也是新图的最大流。否则，如果f(e)=c(e)，为了让新图满足流量限制，需要将多出的部分流退回去。加入f的残余网络中存在从u到v的路径，那么就可以沿着这条路径增广1并把f(e)减小1之后，而保持最大流流量不变。否则，需要找t->v和u->s的路径，沿他们增广1并把f（e）减小1之后，最大流流量也减小1.当有多条边的流量同时减小或者减小量不止1时，也可以做同样处理。（删边也可以吧！）这一般在求字典序最小的最大流之类的问题中会用到着这种技巧。</p></blockquote>

<p>容量为负数的情况</p>

<blockquote><p>通常不会出现。出现了的话，目前没有有效的算法，但是在某些情况下可以采取适当的变形额避免出现负容量的边。</p></blockquote></blockquote></blockquote>

<p>好了，到此，最大流的总结算是真的完了，重点还是在于建图上，还需要多加练习！</p>
]]></content>
  </entry>
  
</feed>
