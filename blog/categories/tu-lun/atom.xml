<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 图论 | hnnwang's Blog]]></title>
  <link href="http://whn757397540.github.io/blog/categories/tu-lun/atom.xml" rel="self"/>
  <link href="http://whn757397540.github.io/"/>
  <updated>2015-08-10T18:00:30+08:00</updated>
  <id>http://whn757397540.github.io/</id>
  <author>
    <name><![CDATA[hnnwang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[并查集模板]]></title>
    <link href="http://whn757397540.github.io/blog/2015/08/10/bing-cha-ji-mo-ban/"/>
    <updated>2015-08-10T17:32:15+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/08/10/bing-cha-ji-mo-ban</id>
    <content type="html"><![CDATA[<p>ZOJ 3811 Untrusted Patrol</p>

<!--more-->


<p>2014牡丹江赛区网络赛C题<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3811">题目链接在这里</a> 其实我的主要目的是放一下自己的并查集模板！</p>

<p>昨天，因为并查集模板的问题跟队友争论了一翻，其实，也是一些没有必要的争论，不管什么模板的，能用就行！</p>

<p>从刚一开始接触并查集，我就是这样敲的</p>

<p>首先，需要用到父亲数组father[]（个人习惯用father）;初始化father[i] = i；</p>

<p>然后，找祖宗函数</p>

<pre><code class="c++">int getfather(int i)
{
    if (father[i] != i) father[i] = getfather(father[i]);
    return father[i];
}
</code></pre>

<p>这样在每次getfather找祖宗的时候，就把所有的儿子节点的父亲都设为了祖宗节点，所以只要找过一次，那么找的这条链的长度(也可以看作是树的深度）就会变成2;</p>

<p>之后，联合判断（判断两个点是否在同一个集合）</p>

<pre><code class="c++">bool UnionJudge(int i, int j)
{
    reutrn getfather(i) == getfather(j);
}
</code></pre>

<p>这个函数有些时候是要用到的</p>

<p>之后，联合函数</p>

<pre><code class="c++">void GetUnion(int i, int j)
{
    int a = getfather(i);
    int b = getfather(j);
    father[b] = a;
}
</code></pre>

<p>一般情况下，树的深度是非常小的，所以基本可以视为是在常数级的时间案复杂度完成的！</p>

<p>接下来，是这道题的思路！</p>

<p>首先吧所有跟有监视器的点相连的边去掉，跑一遍并查集，把其他所有的边都连上；之后按照题目中给的顺序，分别联合有监视器的点，连某一个有监视器的点的时候，这个点之后的有监视器的点都不要被连进去（也就是跟他们相连的边依然是被去掉的）；按照顺序操作，在此过程中如果发现有不能跟第一个有监视器的点连通的点的话，那么说明操作不合法，答案就该输出No了！（当然，如果L&lt;k的话，就是肯定没有遍历完所有的点，输出也是No）</p>

<p>如果所有的带监视器的点都能按照顺序连进去的花，那么，这个人肯定有可能是按照正常的步骤来检查的！但是，题目中给的图可能不是连通图，在这样的情况下，用正常步骤肯定是不能检查完所有的点的，所以还要判断图是不是连通图，昨天就被坑在了这里。</p>

<p>题目大致思路说完了，结下来就是代码了</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;

const int maxv = 110000;

vector&lt;int&gt; edge[maxv];
int father[maxv];

int getfather(int i)
{
    if (father[i] != i) father[i] = getfather(father[i]);
    return father[i];
}

bool PlusJudge(int i, int j)
{
    return getfather(i) == getfather(j);
}

void getPlus(int i, int j)
{
    int a = getfather(i);
    int b = getfather(j);
    father[b] = a;
}

int a[maxv];
bool no[maxv];
int main()
{
    int T;
/*    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
*/    scanf("%d", &amp;T);
    while (T--)
    {
        int n,m,k;
        scanf("%d%d%d", &amp;n, &amp;m, &amp;k);
        memset(no, 0, sizeof(no));
        for (int i = 0; i &lt; k; i++)
        {
            int pp;
            scanf("%d", &amp;pp);
            no[pp] = true;
        }
        for (int i = 1 ; i &lt;= n; i ++)
        {
            edge[i].clear();
            father[i] = i;
        }
        for (int i = 0; i &lt; m; i++)
        {
            int u,v;
            scanf("%d%d", &amp;u, &amp;v);
            edge[u].push_back(v);
            edge[v].push_back(u);
            if (!no[u] &amp;&amp; !no[v])
                getPlus(u,v);
        }
        int L;
        scanf("%d", &amp;L);
        for (int i = 0 ; i &lt; L; i++)
            scanf("%d",&amp;a[i]);
        if (L &lt; k ||  m &lt; n-1) printf("No\n");
        else
        {
            bool flag = true;
            for (int i = 0; i &lt; L; i++)
            {
                no[a[i]] = false;
                for (int j = 0; j &lt; edge[a[i]].size(); j++)
                {
                    int son = edge[a[i]][j];
                    if (!no[son])
                        getPlus(a[i],son);
                }
                flag = PlusJudge(a[0], a[i]);
                if (!flag)
                    break;
            }
            for (int i = 1; i &lt;= n &amp;&amp; flag; i++)
              if (!PlusJudge(i, a[0]))
              {
                  flag = false;
                  break;
              }
            printf("%s\n", flag ? "Yes":"No");
        }
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[连通度总结]]></title>
    <link href="http://whn757397540.github.io/blog/2015/03/14/lian-tong-du-zong-jie/"/>
    <updated>2015-03-14T18:56:00+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/03/14/lian-tong-du-zong-jie</id>
    <content type="html"><![CDATA[<p>做<a href="http://poj.org/problem?id=1966">POJ 1966 Cable TV Network</a>时遇到的问题，用到了一些网络流的知识</p>

<p>这个其实首先是一个概念问题，要想明白什么事图的连通度，我们需要先搞明白什么叫做连通图！</p>

<!--more-->


<p>在图论中，连通图基于连通的概念。在一个无向图 G 中，若从顶点vi到顶点vj有路径相连（当然从vj到vi也一定有路径），则称vi和vj是连通的。如果 G 是有向图，那么连接vi和vj的路径中所有的边都必须同向。如果图中任意两点都是连通的，那么图被称作连通图。如果此图是有向图，则称为强连通图（注意：需要双向都有路径）</p>

<p>严格的定义是这样的：</p>

<p>对一个图 G=(V,E) 中的两点 x 和 y ，若存在交替的顶点和边的序列 Γ=(x=v0-e1-v1-e2-…-ek-(vk+1)=y) (在有向图中要求有向边vi−( vi+1)属于E )，则两点 x 和 y 是连通的。Γ是一条x到y的连通路径，x和y分别是起点和终点。当 x = y 时，Γ 被称为回路。如果通路 Γ 中的边两两不同，则 Γ 是一条简单通路，否则为一条复杂通路。如果图 G 中每两点间皆连通，则 G 是连通图。</p>

<p>(PS:以上内容摘自百度百科)</p>

<p>那么，搞清楚连通图是什么以后，我们就能够知道什么是连通度了。首先，连通度分为边连通度和点联通度，对于这两个概念，是如下定义的：</p>

<p>设G = (V, E)是一个n阶图。如果G是完全图Kn，那么我们定义它的顶点连通度为  κ(Kn) = n – 1  否则，定义它的顶点连通度为  κ(G) = min{|U| : Gv-u是非连通的}  即最小的定点数，删除这些定点后能让这个图不连通（这里没提有向图应该是怎么样的一种不连通，不过根据我的理解，应该是指的不是强联通，也就是任意两点不连通就算是不连通了）</p>

<p>图G的边连通度定义为从图G中删除边而使G非连通的最小边数，用λ(G)表示。  这里的图G=(V, E)代表无向图或有向图，且没有自环和重边。</p>

<p>那么对于边连通度和点连通度，应该怎么求呢？</p>

<p>有向图的边连通度：如果是对于2个点来说的边连通度，那么其实就是这两点之间的最小割！根据最大流最小割定理，很容易用最大流求出来（建图边容量为1就行）。但是如果是对于整个图的边连通度，其实就是要对任意一对点的最小割里面的最小值了，而事实上，我们不需要遍历每一对点，只需要固定源点然后枚举汇点，再固定汇点枚举源点就行了（这个的证明就不说的，因为只要理解了最小割的概念，很容易就能想明白！）</p>

<p>有向图的点连通度：这个相对麻烦一点点，不过其实也就是边容量无限了（因为求点连通度不需要断边），然后点有了容量为1，而之前在网络流的总结里提到了遇到点也有容量的时候该怎么解决，很简单，就是直接拆点，把一个点p拆成两个点v和v’，然后由v指向v’一条容量为1的边，然后所有指向原来的点p的边指向v，所有从原来的点p指出的边变成从v’指出即可！之后的算法跟求边连通度一样</p>

<p>无向图的边连通度：在网络流中也说过，怎么把无向图转化成有向图，这里不再赘述！</p>

<p>无向图的点连通度：一样，把无向图转换成有向图，然后按照有向图点连通度的建图方法来建图就好！</p>

<p>下面来说题：</p>

<p><a href="http://poj.org/problem?id=1966">POJ 1966 Cable TV Network</a></p>

<p>这道题，就是直接的一道让你求点连通度的裸题，很简单，按照之前说的方法建图来求就行！</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 11111;
const int INF = 0x3f3f3f3f;
struct Edge{
    int to, cap, rev;
    Edge(int to, int cap, int rev):to(to), cap(cap), rev(rev){}
};

int u[maxv],v[maxv];
vector&lt;Edge&gt; G[maxv];
int level[maxv];//¶¥µãµ½Ô´µãµÄ¾àÀë±êºÅ
int iter[maxv];//µ±Ç°»¡£¬ÔÚÆäÖ®Ç°µÄ±ßÒÑ¾­Ã»ÓÐÓÃÁË

void init(int n)
{
    for (int i = 0; i &lt; n; i++)
        G[i].clear();
}
void addEdge(int from, int to, int cap)
{
    G[from].push_back(Edge(to, cap, G[to].size()));
    G[to].push_back(Edge(from, 0, G[from].size()-1));
}

void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for (int i = 0; i &lt; G[v].size(); i++)
        {
            Edge &amp;e = G[v][i];
            if (e.cap&gt;0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

int dfs(int v, int t, int f)
{
    if(v == t)
        return f;
    for (int &amp;i = iter[v]; i &lt; G[v].size(); i++)
    {
        Edge &amp;e = G[v][i];
        if (e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if (d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

int max_flow(int s, int t)
{
    int flow = 0;
    while(true)
    {
        bfs(s);
        if (level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while ((f = dfs(s, t, INF)) &gt; 0)
            flow += f;
    }
}

void reset(int n, int m)
{
    init(2*n);
    for (int i = 0; i &lt; n; i++)
        addEdge(i, i+n, 1);
    for(int i = 0; i &lt; m; i++)
    {
        addEdge(u[i]+n, v[i], INF);
        addEdge(v[i]+n, u[i], INF);
    }

}
int main()
{
    int n,m;
    while(~scanf("%d%d", &amp;n, &amp;m))
    {
        for (int i = 0; i &lt; n; i++)
            addEdge(i, i+n, 1);
        for (int i = 0; i &lt; m; i++)
            scanf(" (%d,%d)", &amp;u[i], &amp;v[i]);
        //int s = n, ans = INF;
        int ans = INF;
        int s = n;
        int t;
        for (t = 1; t &lt; n; t++)
        {
            reset(n,m);
            ans = min(ans, max_flow(s,t));
        }
        t = 0;
        for (s = n+1; s &lt; 2*n; s++)
        {
            reset(n,m);
            ans = min(ans, max_flow(s,t));
        }
        printf("%d\n", ans &lt; INF ? ans : n);
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最小割的介绍及应用]]></title>
    <link href="http://whn757397540.github.io/blog/2015/03/14/zui-xiao-ge-de-jie-shao-ji-ying-yong/"/>
    <updated>2015-03-14T18:55:31+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/03/14/zui-xiao-ge-de-jie-shao-ji-ying-yong</id>
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=3469">POJ 3469 Dual Core CPU</a></p>

<p>这是一个典型的最小割问题，不再陈述题意。</p>

<!--more-->


<p>这里先介绍一下割的概念。所谓图的割，就是指对于某个定点几何S（属于V），从S出发指向S外部的那些边的几何，记作割（S, V/S）。这些边的容量之和被称为割的容量。如果有s∈S，t∈V/S，那么此时的割又可以称为s-t割。</p>

<p>好好理解下割的概念，然后，记住一个定理：一个图从s到t的最大流，等于s-t的最小割。这个被称为最大流最小割定理。</p>

<p>像这道题这种<strong>用最小的费用将对象划分成两个集合的问题，常常可以转换成最小割问题后顺利解决</strong>，本题就是一个非常典型的例子。（要不本来我还不知道最小割怎么来用呢，算是第一次遇到用最小割的题目吧！）</p>

<p>这道题，就可以记在A上执行的模块的几何为S，在B上执行的模块的几何为T，并加一个虚拟的源点s在S中和一个虚拟的汇点t在T中。我们很容易知道，花费的总和是</p>

<p>sigma(A[i],i∈S) + sigmasigma(B[i],i∈T) + sigma（wi,ai属于S，bi属于T） + sigma（wi,ai属于s，bi属于t）.</p>

<p>我们需要构建一个图，使得花费的综合等价于图的割的容量，那么我们就可以通过求最小割来求最小花费了。关键是图怎么构？这是一个问题。</p>

<p>我们要明确一个方向，我们要做的是让图的割等于花费，也就是让从S到T的各个边的权值和等于上面的式子，那么实际上还是蛮简单的，一个一个来考虑就好了，对于式子的第一项sigma(A[i],i∈S),首先，我们确定i∈S，我们只需要从S指向T就好，所以只需要从每个模块向t连一条容量为A[i]的边就好；同样，对于第二项，i属于T，所以只要有一个从S中指出来的边指向i就好，所以就从s指向每个模块一条容量为B[i]的边；最后，第三项，ai∈S，bi∈T，记住目的是连从S到T的边，所以连的应该是从ai到bi的边，容量为wi，同理，第四项只是把第三项的边反过来就好。</p>

<p>这样我们构完图，这个图的割就代表着花费，那么最小割自然就代表着最小花费了！而通过最大流最小割定理我们又知道，最小割等于最大流，所以我们只需要求从s到t的最大流即可。 代码如下</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 22222;

const int INF = 0x3f3f3f3f;
struct Edge{
    int to,cap, rev;
    Edge(int to, int cap, int rev):to(to), cap(cap), rev(rev){}
};

vector&lt;Edge&gt; G[maxv];
int level[maxv];//¶¥µãµ½Ô´µãµÄ¾àÀë±êºÅ
int iter[maxv];//µ±Ç°»¡£¬ÔÚÆäÖ®Ç°µÄ±ßÒÑ¾­Ã»ÓÐÓÃÁË

void addEdge(int from, int to, int cap)
{
    G[from].push_back(Edge(to, cap, G[to].size()));
    G[to].push_back(Edge(from, 0, G[from].size()-1));
}

void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for (int i = 0; i &lt; G[v].size(); i++)
        {
            Edge &amp;e = G[v][i];
            if (e.cap&gt;0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

int dfs(int v, int t, int f)
{
    if(v == t)
        return f;
    for (int &amp;i = iter[v]; i &lt; G[v].size(); i++)
    {
        Edge &amp;e = G[v][i];
        if (e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if (d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

int max_flow(int s, int t)
{
    int flow = 0;
    while(true)
    {
        bfs(s);
        if (level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while ((f = dfs(s, t, INF)) &gt; 0)
            flow += f;
    }
}

vector&lt;int&gt; rec[maxv];
int main()
{
    int n,m;
    scanf("%d%d", &amp;n, &amp;m);
    int s = 0, t = n+1;
    for (int i = 1; i &lt;= n; i++)
    {
        int a,b;
        scanf("%d%d", &amp;a, &amp;b);
        addEdge(s, i, b);
        addEdge(i, t, a);
    }
    for (int i = 1; i &lt;= m; i++)
    {
        int a,b,w;
        scanf("%d%d%d", &amp;a, &amp;b, &amp;w);
        addEdge(a,b,w);
        addEdge(b,a,w);
    }

    printf("%d\n", max_flow(s,t));
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图论总结(六)]]></title>
    <link href="http://whn757397540.github.io/blog/2015/03/14/tu-lun-zong-jie-liu/"/>
    <updated>2015-03-14T18:55:18+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/03/14/tu-lun-zong-jie-liu</id>
    <content type="html"><![CDATA[<p>2-sat问题</p>

<!--more-->


<p>2-sat问题嘛，去鞍山打比赛之前看过一次，是在刘汝佳白书上看的，看的迷迷糊糊似懂非懂的（说白了其实是没有看懂），这次看的《挑战程序设计竞赛》上的，一下子就全部闹明白了。</p>

<p>首先，解释一下什么叫做sat问题：给定一个布尔方程，判断是否存在一组布尔变量的真值指派使得整个方程为真的问题，被称为布尔方程的可满足性问题（sat）。sat问题是NP完全性问题，但是对于满足一定限制条件的sat问题，还是能够有效求解的。看下面的合取范式：</p>

<p>(a或b或……）且（c或d或………）且……（PS:符号不好打， 所以只能用文字代替了）</p>

<p>其中a,b,c,d……等被称为文字，它是一个布尔变量或者其否定。像 (a或b或……) 这样用 或 连接的部分称为子句。如果合取范式的每个子句中的文字个数都不超过2个，那么对应的sat问题又称为2-sat问题。</p>

<p>通过以上的说明，应该能够知道什么事sat问题了。那么这类问题怎么求解呢？利用强连通分量，可以在布尔公式句数的线性时间内解决2-sat问题。首先，利用=>(蕴涵)符号将每个子句（a 或 b） 改成其等价形式（非a => b 且 非b => a）。这样远布尔公式就变成了把 a=>b 形式的布尔公式用 与 链接起来的形式。 对于每个布尔变量x, 构造两个顶点分别代表 x 和 非x， 以 => 关系为边建立有向图。 此时，如果图上a能到达b点的话，就表示当a为真的时候b也肯定为真。因此，该图中同一个强连通分量所含的所有文字的布尔值均相同（可能真可能假）。</p>

<p>如果存在某个布尔变量x，x 和 非x 均在同一个强连通分量重，则显然无法令整个布尔公式的值为真。 反之，如果不存在这样的布尔变量，那么对于每个布尔变量x，让</p>

<p>x所在的强连通分量的拓扑序在 非x 所在的强连通分量之后 &lt;==> x为真</p>

<p>就是使得该公式值为真的一组合适的布尔变量赋值。（记住后面的是真就好，这个是在需要输出一种可能的结果的时候会用得到）</p>

<p>接下来看题</p>

<p><a href="http://poj.org/problem?id=3683">POJ 3683 Priest John’s Busiest Day</a></p>

<p>这道题，我们知道，对于每一组S,T,D，只有2种情况需要结婚仪式，就是(S, S+D) 和 (T-D, T)，把这两种情况分别设为同一个布尔变量的真和假就好。假设对应i于j的两个布尔型变量分别为xi（Si+Di）,xj(Sj+Dj),那么 非xi 对应（T[i] - D[i], T[i]）, 非xj 对应（T[j] - D[j], T[j]）。加入xi和xj矛盾，我们就有 xi且xj 为假， 那么 非xi 或 非xj 就为真，把这个式子按照之前所说的规则进行转换就能得到一组加边的方法。同理，对于其他的矛盾也是这样处理。</p>

<p>那么，对应的这道题的连边的方式就出来了，然后就没有什么难度了。给两个代码。</p>

<p>Tarjan</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;stack&gt;

using namespace std;
const int maxv = 11111;
const int maxm = 2222222;
struct Edge{
    int from, to, next;
    Edge(){}
    Edge(int from, int to, int next):from(from), to(to), next(next){}
};

Edge E[maxm];
int head[maxv];
int nume;
int pre[maxv],lowlink[maxv],sccno[maxv],dfs_clock,scc_cnt;
int S[maxv];
int tops;

void init()
{
    nume = 0;
    memset(head, -1, sizeof(head));
    tops = 0;
}

void addEdge(int from, int to)
{
    E[nume] = Edge(from, to, head[from]);
    head[from] = nume++;
}

void dfs(int u)
{
    pre[u] = lowlink[u] = ++dfs_clock;
    S[tops++] = u;
    for (int i = head[u]; i != -1; i = E[i].next)
    {
        int v = E[i].to;
        if (!pre[v])
        {
            dfs(v);;
            lowlink[u] = min(lowlink[u], lowlink[v]);
        }
        else if(!sccno[v])
            lowlink[u] = min(lowlink[u], pre[v]);
    }
    if (lowlink[u] == pre[u])
    {
        scc_cnt++;
        while(true)
        {
            int x = S[--tops];
            sccno[x] = scc_cnt;
            if(x == u)
                break;
        }
    }
}

void find_scc(int n)
{
    dfs_clock = scc_cnt = 0;
    memset(sccno, 0, sizeof(sccno));
    memset(pre, 0, sizeof(pre));
    for (int i = 0; i &lt; n; i++)
        if(!pre[i]) dfs(i);
}

int s[maxv],t[maxv],d[maxv];
int main()
{
    int n;
    init();
    scanf("%d", &amp;n);
    for (int i = 0; i &lt; n; i++)
    {
        int hh,mm;
        scanf("%d:%d", &amp;hh, &amp;mm);
        s[i] = hh*60+mm;
        scanf("%d:%d", &amp;hh, &amp;mm);
        t[i] = hh*60+mm;
        scanf("%d", &amp;d[i]);
    }

    for (int i = 0; i &lt; n; i++)
    {
        int t1 = s[i] + d[i], s1 = t[i] - d[i];
        for (int j = i+1; j &lt; n; j++)
        {
            int t2 = s[j] + d[j], s2 = t[j] - d[j];
            if (s[j] &lt; t1 &amp;&amp; t2 &gt; s[i])
            {
                addEdge(i,j+n);
                addEdge(j,i+n);
            }
            if (s2 &lt; t1 &amp;&amp; t[j] &gt; s[i])
            {
                addEdge(i,j);
                addEdge(j+n,i+n);
            }
            if (s[j] &lt; t[i] &amp;&amp; t2 &gt; s1)
            {
                addEdge(i+n, j+n);
                addEdge(j,i);
            }
            if (s2 &lt; t[i] &amp;&amp; t[j] &gt; s1)
            {
                addEdge(i+n,j);
                addEdge(j+n,i);
            }
        }
    }
    find_scc(2*n);
    bool judge = true;
    for (int i = 0; i &lt; n; i++)
        if(sccno[i] == sccno[n+i])
        {
            judge = false;
            break;
        }
    if(judge)
    {
        printf("YES\n");
        for (int i = 0; i &lt; n; i++)
        {
            if(sccno[i] &lt; sccno[n+i])
                printf("%02d:%02d %02d:%02d\n", s[i]/60, s[i]%60, (s[i]+d[i])/60, (s[i]+d[i])%60);
            else
                printf("%02d:%02d %02d:%02d\n", (t[i]-d[i])/60, (t[i]-d[i])%60, t[i]/60, t[i]%60);
        }
    }
    else
        printf("NO\n");
    system("pause");
    return 0;
}
</code></pre>

<p>Kosaraju</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;
const int maxv = 22222;
const int maxe = 2222222;

int V;
struct Edge{
    int from, to, next;
    Edge(){}
    Edge(int from, int to, int next):from(from), to(to), next(next){}
};
Edge E[maxe];//图的邻接表表示
Edge rE[maxe];//把边反向后的图
int head[maxv], rhead[maxv];
int nume,rnume;
int vs[maxv];//后续遍历顺序的顶点列表
int cntvs;
bool used[maxv];//访问标记
int tporder[maxv];//所属强联通分量的拓扑序

void init()
{
    nume = rnume = 0;
    memset(head, -1, sizeof(head));
    memset(rhead, -1, sizeof(rhead));
    cntvs = 0;
}
void addEdge(int from, int to)
{
    E[nume] = Edge(from, to, head[from]);
    head[from] = nume++;
    rE[rnume] = Edge(to, from, rhead[to]);
    rhead[to] = rnume++;
}

void dfs(int v)
{
    used[v] = true;
    for (int i = head[v]; i != -1; i = E[i].next)
        if (!used[E[i].to]) dfs(E[i].to);
    vs[cntvs++] = v;
}

void rdfs(int v, int k)
{
    used[v] = true;
    tporder[v] = k;
    for (int i = rhead[v]; i != -1; i = rE[i].next)
        if (!used[rE[i].to]) rdfs(rE[i].to, k);
}

int scc()
{
    memset(used, false, sizeof(used));

    for (int v= 0 ; v &lt; V; v++)
        if (!used[v])   dfs(v);
    memset(used, 0, sizeof(used));
    int k = 0;
    for (int i = cntvs-1; i &gt;= 0; i--)
        if (!used[vs[i]]) rdfs(vs[i], k++);
    return k;
}


int s[maxv],t[maxv],d[maxv];
int main()
{
    int n;
    init();
    scanf("%d", &amp;n);
    for (int i = 0; i &lt; n; i++)
    {
        int hh,mm;
        scanf("%d:%d", &amp;hh, &amp;mm);
        s[i] = hh*60+mm;
        scanf("%d:%d", &amp;hh, &amp;mm);
        t[i] = hh*60+mm;
        scanf("%d", &amp;d[i]);
    }
    int t1,t2,s1,s2;
    for (int i = 0; i &lt; n; i++)
    {
        t1 = s[i] + d[i], s1 = t[i] - d[i];
        for (int j = 0; j &lt; i; j++)
        {
            t2 = s[j] + d[j], s2 = t[j] - d[j];
            if (min(t1, t2) &gt; max(s[i],s[j]))
            {
                addEdge(i,j+n);
                addEdge(j,i+n);
            }
            if (max(s[i],s2) &lt; min(t1, t[j]))
            {
                addEdge(i,j);
                addEdge(j+n,i+n);
            }
            if (max(s[j],s1) &lt; min(t[i],t2))
            {
                addEdge(i+n, j+n);
                addEdge(j,i);
            }
            if (min(t[i], t[j]) &gt; max(s1,s2))
            {
                addEdge(i+n,j);
                addEdge(j+n,i);
            }
        }
    }
    V = 2*n;
    scc();
    bool judge = true;
    for (int i = 0; i &lt; n; i++)
        if(tporder[i] == tporder[n+i])
        {
            judge = false;
            break;
        }
    if(judge)
    {
        printf("YES\n");
        for (int i = 0; i &lt; n; i++)
        {
            if(tporder[i] &gt; tporder[n+i])
                printf("%02d:%02d %02d:%02d\n", s[i]/60, s[i]%60, (s[i]+d[i])/60, (s[i]+d[i])%60);
            else
                printf("%02d:%02d %02d:%02d\n", (t[i]-d[i])/60, (t[i]-d[i])%60, t[i]/60, t[i]%60);
        }
    }
    else
        printf("NO\n");
   // system("pause");
    return 0;
}
</code></pre>

<p>这里注意一点，Tarjan的拓扑序跟Kosaraju是相反的，之前所说的后面，对应Kosaraju里面的就是标号比较大，对应Tarjan里面的就是标号比较小。</p>

<p>做这种题的关键是抽象出布尔代数来，然后用蕴含关系来连边，注意你要化简的布尔式子一定是 与 的关系，最后通过强连通分量来求出2-sat的结果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图论总结(五)]]></title>
    <link href="http://whn757397540.github.io/blog/2015/03/14/tu-lun-zong-jie-wu/"/>
    <updated>2015-03-14T18:55:02+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/03/14/tu-lun-zong-jie-wu</id>
    <content type="html"><![CDATA[<h4>有向图的强联通分量</h4>

<p>主要介绍求强联通分量的2种方法。</p>

<!--more-->


<ol>
<li>Kosaraju算法</li>
</ol>


<p>这种算法就是数据结构上讲的那种算法，利用2次简单的dfs来实现。第一次dfs时，选取任意顶点作为起点，遍历所有未访问过的顶点，并在回溯前给顶点标号（后序遍历）。对剩余未访问过的顶点，不断重复上述过程；完成标号后，越接近图的尾部（搜索树的叶子），顶点标号越小。第二次dfs时，先将所有的边反向，然后以标号最大的顶点进行dfs。这样dfs所遍历的顶点几何就构成了一个强联通分量。之后，只要还有尚未访问的顶点，就从中选取标号最大的顶点不断重复上述过程。</p>

<p>以上就是整个算法的过程，至于证明吧，自己画个图模拟一下吧。给出一个模板代码！算法的复杂度时O(V+E)</p>

<pre><code class="c++">int V;
struct Edge{
    int from, to, next;
    Edge(){}
    Edge(int from, int to, int next):from(from), to(to), next(next){}
};
Edge E[maxe];//图的邻接表表示
Edge rE[maxe];//把边反向后的图
int head[maxv], rhead[maxv];
int nume,rnume;
int vs[maxv];//后续遍历顺序的顶点列表
int cntvs;
bool used[maxv];//访问标记
int tporder[maxv];//所属强联通分量的拓扑序

void init()
{
    nume = rnume = 0;
    memset(head, -1, sizeof(head));
    memset(rhead, -1, sizeof(rhead));
    cntvs = 0;
}
void addEdge(int from, int to)
{
    E[nume] = Edge(from, to, head[from]);
    head[from] = nume++;
    rE[rnume] = Edge(to, from, rhead[to]);
    rhead[to] = rnume++;
}

void dfs(int v)
{
    used[v] = true;
    for (int i = head[v]; i != -1; i = E[i].next)
        if (!used[E[i].to]) dfs(E[i].to);
    vs[cntvs++] = v;
}

void rdfs(int v, int k)
{
    used[v] = true;
    tporder[v] = k;
    for (int i = rhead[v]; i != -1; i = rE[i].next)
        if (!used[rE[i].to]) rdfs(rE[i].to, k);
}

int scc()
{
    memset(used, false, sizeof(used));

    for (int v= 0 ; v &lt; V; v++)
        if (!used[v])   dfs(v);
    memset(used, 0, sizeof(used));
    int k = 0;
    for (int i = cntvs-1; i &gt;= 0; i--)
        if (!used[vs[i]]) rdfs(vs[i], k++);
    return k;
}
</code></pre>

<ol>
<li>Tarjan算法</li>
</ol>


<p>这个算法的思想是这样的：</p>

<p>考虑强连通分量 C，设其中第一个被发现的点为 x，则 C 中其他点都是 x 的后代。我们希望在 x 访问完成时立刻输出 C。这样，就可以在同一棵 DFS 树中区分开所有 SCC 了。因此问题的关键，是判断一个点是否为一个 SCC中最先发现的点。</p>

<p>假设我们正在判断 u 是否为某 SCC 的第一个被发现结点。如果我们发现从 u 的子结点出发可以到达 u 的祖先w，显然 u、v、w 在同一个 SCC 中，因此 u 不是该 SCC 中第一个被发现的结点；另一方面，如果从 v 发现最多只能到 u，那么 u 是该 SCC 中第一个被发现的结点。这样，问题转化为求一个点 u 最远能到达的祖先的 d 值。注意，这里的“到达”只能通过当前 SCC 中的点，而不能通过已经确定 SCC 编号的其他点。</p>

<p>我们可以类似的定义 lowlink(u)为 u 及其后代能追溯到的最早（最先被发现）祖先点 v 的 pre(v)值，如此便可以在计算 lowlink 函数的同时完成 SCC 计算。这个算法的复杂度也是O(V+E)，但是常数比Kosaraju算法要小一些。参考代码如下：</p>

<pre><code class="c++">struct Edge{
    int from, to, next;
    Edge(){}
    Edge(int from, int to, int next):from(from), to(to), next(next){}
};

Edge E[maxm];
int head[maxv];
int nume;
int pre[maxv],lowlink[maxv],sccno[maxv],dfs_clock,scc_cnt;
int S[maxv];
int tops;

void init()
{
    nume = 0;
    memset(head, -1, sizeof(head));
    tops = 0;
}

void addEdge(int from, int to)
{
    E[nume] = Edge(from, to, head[from]);
    head[from] = nume++;
}

void dfs(int u)
{
    pre[u] = lowlink[u] = ++dfs_clock;
    S[tops++] = u;
    for (int i = head[u]; i != -1; i = E[i].next)
    {
        int v = E[i].to;
        if (!pre[v])
        {
            dfs(v);;
            lowlink[u] = min(lowlink[u], lowlink[v]);
        }
        else if(!sccno[v])
            lowlink[u] = min(lowlink[u], pre[v]);
    }
    if (lowlink[u] == pre[u])
    {
        scc_cnt++;
        while(true)
        {
            int x = S[--tops];
            sccno[x] = scc_cnt;
            if(x == u)
                break;
        }
    }
}

void find_scc(int n)
{
    dfs_clock = scc_cnt = 0;
    memset(sccno, 0, sizeof(sccno));
    memset(pre, 0, sizeof(pre));
    for (int i = 0; i &lt; n; i++)
        if(!pre[i]) dfs(i);
}
</code></pre>

<p>下面来说一道题</p>

<p><a href="http://poj.org/problem?id=2186">POJ 2186 Popular Cows</a></p>

<p>这道题思路其实不难想，算是一道基础题了，就是为了练习强联通分量的吧！首先，我们要明确，如果一个牛被其他所有牛认为是红人，那么那头牛所在的强联通分量里的任何一头牛都是被所有牛认为是红人的牛。反之，任何一头其他的牛被所有牛认为是红人，那么这头牛也一定属于这个强联通分量。所以，如果存在被所有牛认为是红人的牛，那么这些牛肯定都属于同一个强联通分量，这个强联通分量里面的牛的数目就是答案了；当然，也有可能不存在。</p>

<p>我们通过两种算法求出来的所有强联通分量，都是按照图的拓扑序排了序的，所以如果存在这样的牛的话，那么它一定属于拓扑序最后的强联通分量，所以一种方法就是，先找到拓扑序最后的强联通分量里面的一头牛，然后看他是不是所有顶点可达就能判断了。这种方法的代码，我是用Kosaraju算法写的（事实上是参考《挑战程序设计竞赛》中的代码写的），当然也可以用tarjan来写：</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;
const int maxv = 22222;
const int maxe = 55555;

int V;
struct Edge{
    int from, to, next;
    Edge(){}
    Edge(int from, int to, int next):from(from), to(to), next(next){}
};
Edge E[maxe];//图的邻接表表示
Edge rE[maxe];//把边反向后的图
int head[maxv], rhead[maxv];
int nume,rnume;
int vs[maxv];//后续遍历顺序的顶点列表
int cntvs;
bool used[maxv];//访问标记
int tporder[maxv];//所属强联通分量的拓扑序

void init()
{
    nume = rnume = 0;
    memset(head, -1, sizeof(head));
    memset(rhead, -1, sizeof(rhead));
    cntvs = 0;
}
void addEdge(int from, int to)
{
    E[nume] = Edge(from, to, head[from]);
    head[from] = nume++;
    rE[rnume] = Edge(to, from, rhead[to]);
    rhead[to] = rnume++;
}

void dfs(int v)
{
    used[v] = true;
    for (int i = head[v]; i != -1; i = E[i].next)
        if (!used[E[i].to]) dfs(E[i].to);
    vs[cntvs++] = v;
}

void rdfs(int v, int k)
{
    used[v] = true;
    tporder[v] = k;
    for (int i = rhead[v]; i != -1; i = rE[i].next)
        if (!used[rE[i].to]) rdfs(rE[i].to, k);
}

int scc()
{
    memset(used, false, sizeof(used));

    for (int v= 0 ; v &lt; V; v++)
        if (!used[v])   dfs(v);
    memset(used, 0, sizeof(used));
    int k = 0;
    for (int i = cntvs-1; i &gt;= 0; i--)
        if (!used[vs[i]]) rdfs(vs[i], k++);
    return k;
}

int main()
{
    int n,m;
    scanf("%d%d", &amp;n, &amp;m);
    init();
    for (int i = 0; i &lt; m; i++)
    {
        int a,b;
        scanf("%d%d", &amp;a, &amp;b);
        addEdge(a-1,b-1);
    }
    V = n;
    int K = scc();
    int ans = 0, u;
    for (int i = 0; i &lt; V; i++)
        if (tporder[i] == K-1)
        {
            ans++;
            u = i;
        }

    memset(used, 0, sizeof(used));
    rdfs(u, 0);
    for (int i = 0; i &lt; n; i++)
        if (!used[i])
        {
            ans = 0;
            break;
        }
    printf("%d\n", ans);

    return 0;
}
</code></pre>

<p>这里，书上用的是vector来表示的图，我刚开始也是跟着书上的写法来的，但是发现太慢了，344ms,然后改成了这样，手写的边，时间就变成了63ms，当然，后者写起来比较麻烦。</p>

<p>还有一种方法，被前面所有牛都认为是红人的那个强联通分量肯定在最后，所以我们只需要看有几个“最后”就行（这里的最后是指，出度为0的强联通分量）。如果只有一个的话，那么答案就是这个强联通分量里面的人数；如果有不止一个的话，那么就没有牛被所有牛认为是红人（因为出度为0的牛，除了自己圈子里的牛，不认为其他的任何牛是红人。）</p>

<p>这种方法我使用Tarjan写的。</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;stack&gt;

using namespace std;
const int maxv = 11111;
const int maxm = 55555;
struct Edge{
    int from, to, next;
    Edge(){}
    Edge(int from, int to, int next):from(from), to(to), next(next){}
};

Edge E[maxm];
int head[maxv];
int nume;
int pre[maxv],lowlink[maxv],sccno[maxv],dfs_clock,scc_cnt;
int S[maxv];
int tops;

void init()
{
    nume = 0;
    memset(head, -1, sizeof(head));
    tops = 0;
}

void addEdge(int from, int to)
{
    E[nume] = Edge(from, to, head[from]);
    head[from] = nume++;
}

void dfs(int u)
{
    pre[u] = lowlink[u] = ++dfs_clock;
    S[tops++] = u;
    for (int i = head[u]; i != -1; i = E[i].next)
    {
        int v = E[i].to;
        if (!pre[v])
        {
            dfs(v);;
            lowlink[u] = min(lowlink[u], lowlink[v]);
        }
        else if(!sccno[v])
            lowlink[u] = min(lowlink[u], pre[v]);
    }
    if (lowlink[u] == pre[u])
    {
        scc_cnt++;
        while(true)
        {
            int x = S[--tops];
            sccno[x] = scc_cnt;
            if(x == u)
                break;
        }
    }
}

void find_scc(int n)
{
    dfs_clock = scc_cnt = 0;
    memset(sccno, 0, sizeof(sccno));
    memset(pre, 0, sizeof(pre));
    for (int i = 0; i &lt; n; i++)
        if(!pre[i]) dfs(i);
}

int deg[maxv],cnt[maxv];
int main()
{
    int n,m;
    scanf("%d%d", &amp;n, &amp;m);
    init();
    for (int i = 0; i &lt; m; i++)
    {
        int a,b;
        scanf("%d%d", &amp;a, &amp;b);
        addEdge(a-1,b-1);
    }
    find_scc(n);

    int k = scc_cnt;

    for (int i = 0; i &lt; n; i++)
    {
        cnt[sccno[i]]++;
        for (int j = head[i]; j != -1; j = E[j].next)
            if (sccno[E[j].to] != sccno[i])
                deg[sccno[i]]++;
    }
    int ans = 0;
    //cout&lt;&lt;1&lt;&lt;endl;
    for (int i = 1; i &lt;= k; i++)
        if(ans == 0 &amp;&amp; deg[i] == 0)
            ans = cnt[i];
        else if (ans != 0 &amp;&amp; deg[i] == 0)
        {
            ans = 0;
            break;
        }
    printf("%d\n", ans);

    return 0;
}
</code></pre>

<p>这里我还是要说一下，对比一下，这个Tarjan，我用vector加stack的时候，用的时间是550ms；把vector改成手写边之后，时间变成了94ms；再把stack改成手写栈之后，时间变成了63ms。所以说时间差距还是蛮大的，不过毕竟还是用stl会感觉更加方便快捷一些，所以如果给的时间充足的话，用stl也是可以的；如果时间比较紧张，就尽量用手写的吧！</p>
]]></content>
  </entry>
  
</feed>
