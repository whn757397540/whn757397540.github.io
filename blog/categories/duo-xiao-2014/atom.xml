<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 多校2014 | hnnwang's Blog]]></title>
  <link href="http://whn757397540.github.io/blog/categories/duo-xiao-2014/atom.xml" rel="self"/>
  <link href="http://whn757397540.github.io/"/>
  <updated>2015-08-10T18:00:30+08:00</updated>
  <id>http://whn757397540.github.io/</id>
  <author>
    <name><![CDATA[hnnwang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[HDU 4923 Room and Moor]]></title>
    <link href="http://whn757397540.github.io/blog/2015/08/10/hdu-4923-room-and-moor/"/>
    <updated>2015-08-10T12:23:22+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/08/10/hdu-4923-room-and-moor</id>
    <content type="html"><![CDATA[<h2>2014年多校联合训练第六场1003题</h2>

<!--more-->


<p>题目链接点——–<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4923">这里</a></p>

<p>不是一道很难的题，应该是一个贪心吧。</p>

<p>首先，我们先要知道对于1 1 ……10 0 0……0（x个1,y个0） 这样的一段，要想让满足题目的f(A,B)最小的话，B[i]应该取x/(x+y),至于怎么证，我不太清楚，应该是可以证出来，我们是按照这种方式算的样例，就假定他是正确的了。</p>

<p>有了上面的条件的话，后面的工作就简单了，不管前导0和后导1，然后把中间的部分分成k个111000类型的部分，算出每一段对应的B，然后用一个单调队列更新，如果后一段较前一段上升的话，就把后一段加到队列中；如果后一段较前一段下降的话，合并这两段（可以证明，这样的操作肯定是正确的），再将合并后的这一段跟之前的一段比较，直到满足数列上升的条件；一直进行这种操作就行了。用单调队列维护的话，也不会超时。赛时玮神敲的代码如下</p>

<pre><code class="c++">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
using namespace std;
const double eps=1e-9;
int N,M;
int A[100010],B[100010],num[100010],que[100010];
double val[100010],vx[100010];
double get_val(int a)
{
    int l=B[a+1]-B[a];
    if(l==num[a]&amp;&amp;B[a+1]==N+1)return 0;
    double x=1.0*num[a]/l;
    return (1.0-x)*(1.0-x)*num[a]+x*x*(l-num[a]);
}
double get_x(int a)
{
    int l=B[a+1]-B[a];
    return 1.0*num[a]/l;
}
int main()
{
    int i,j,T;
    memset(A,0,sizeof(A));
    scanf("%d",&amp;T);
    while(T--){
        scanf("%d",&amp;N);
        for(i=1;i&lt;=N;i++){
            scanf("%d",&amp;A[i]);
        }
        memset(B,-1,sizeof(int)*(N+1));
        memset(num,0,sizeof(int)*N);
        memset(val,0,sizeof(val));
        for(i=1,j=0;i&lt;=N;i++){
            if(A[i]==1&amp;&amp;A[i-1]==0){
                num[j]=1;
                B[j++]=i;
            }
            else if(A[i]==1&amp;&amp;A[i-1]==1)num[j-1]++;
        }
        B[j]=N+1;
        int head=0,tail=0;
        for(i=0;i&lt;j;i++){
            vx[i]=get_x(i);
            val[i]=get_val(i);
            while(head&lt;tail){
                if(vx[i]+eps&lt;vx[que[tail-1]]){
                    tail--;
                    num[i]+=num[que[tail]];
                    B[i]=B[que[tail]];
                    int l=B[i+1]-B[i];
                    vx[i]=1.0*num[i]/l;
                    val[i]=vx[i]*vx[i]*(l-num[i])+(1-vx[i])*(1.0-vx[i])*num[i];
                }
                else break;
            }
            que[tail++]=i;
        }
        double res=0;
        for(i=head;i&lt;tail;i++){
            res+=val[que[i]];
        }
        printf("%.6lf\n",res);
    }
    return 0;
}
</code></pre>

<p>仔细再思考一下，发现不管是对于任何一段，都是符合如果对这一段选择相同的值，肯定要选择平均数，而最小的结果也正好是这样，所以，不用去找到那些11110000的部分，直接用单调队列从头维护到尾即可，代码如下：</p>

<pre><code class="c++">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#define INF 0x3f3f3f3f
using namespace std;
const double eps=1e-9;
typedef long long ll;
#define MAXN 100100

int a[MAXN];
double b[MAXN];
int que[MAXN],head,tail;
double sum[MAXN],ave[MAXN];

void init()
{
    memset(b, 0, sizeof(b));
}
int main()
{
    int T;
    //freopen("in.txt", "r", stdin);
    cin&gt;&gt;T;
    while(T--)
    {
        int n;
        sum[0] = 0;
        init();
        scanf("%d", &amp;n);
        for(int i = 1; i &lt;= n; i++)
        {
            scanf("%d", &amp;a[i]);
            sum[i] = sum[i-1] + a[i];
        }
        head = tail = 0;
        que[tail++] = 0;
        ave[0] = 0;
        memset(ave, 0, sizeof(ave));
        for(int i = 1; i &lt;= n; i++)
        {
            ave[i] = (sum[i] - sum[que[tail-1]])/(i-que[tail-1]);
           // cout&lt;&lt;ave[i]&lt;&lt;" "&lt;&lt;tail&lt;&lt;endl;
            while(head &lt; tail &amp;&amp; ave[i]-eps &lt;= ave[que[tail-1]])
            {
                tail--;
                ave[i] = (sum[i] - sum[que[tail-1]])/(i-que[tail-1]);
               // cout&lt;&lt;"\t\t"&lt;&lt;sum[i]&lt;&lt;"-"&lt;&lt;sum[que[tail-1]]&lt;&lt;" "&lt;&lt;ave[i]&lt;&lt;endl;
            }
            que[tail++] = i;
        }
        double ans = 0;
        while(head &lt; tail-1)
        {
            for(int i = que[head]+1; i &lt;= que[head+1]; i++)
                b[i] = ave[que[head+1]];
            head++;
        }
      for(int i = 1; i &lt;= n; i++)
            ans += (a[i]-b[i])*(a[i]-b[i]);
      printf("%.6f\n", ans);

    }
}
</code></pre>

<p><a href="/blog/archives/">&lt;&ndash;Back</a></p>
]]></content>
  </entry>
  
</feed>
