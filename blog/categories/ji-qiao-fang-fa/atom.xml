<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 技巧方法 | hnnWang's Blog]]></title>
  <link href="http://whn757397540.github.io/blog/categories/ji-qiao-fang-fa/atom.xml" rel="self"/>
  <link href="http://whn757397540.github.io/"/>
  <updated>2015-02-15T01:17:39+08:00</updated>
  <id>http://whn757397540.github.io/</id>
  <author>
    <name><![CDATA[hnnWang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[开关问题]]></title>
    <link href="http://whn757397540.github.io/blog/2015/02/15/kai-guan-wen-ti/"/>
    <updated>2015-02-15T00:00:58+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/02/15/kai-guan-wen-ti</id>
    <content type="html"><![CDATA[<p>反转问题，开关问题，关灯问题！这是一个什么样的问题呢？说实话，我也不清楚，那就不清楚地说一说呗！先来看两个题，再根据这两个题再来分析下这是一个什么样的问题！</p>

<!--more-->


<p><a href="http://poj.org/problem?id=3276">POJ3276 Face The Right Way</a></p>

<p>简单说下题意，给你n头牛的朝向(B向后F向前)，给你一台机器，机器的作用是，你先要指定一个k，然后机器每次操作反转严格的k头牛的方向（B变F，F变B）。问让所有的牛朝前最少需要反转几次，对应的K是多少（如果次数相同，输出最小的K）。</p>

<p>首先，区间的反转顺序对于结果是没有影响的；其次，如果对同一个区间反转2次以上是多余的；有以上两点，问题就转变成了求需要被反转的空间的集合。</p>

<p>那么我们就考虑最前面一头牛，如果这头牛需要反转，那么包含这头牛的区间只有1个，所以这个区间就必须要反转；在把这头牛反转之后，在剩下的牛里面再选取最前面的一头，依然是一样的。所以我们就可以通过首先考虑最左端的牛，然后不断重复最终求出结果了！</p>

<p>以上便是这种方法的精髓。可是如果我们直接按照这种方法来模拟的话，我们来分析下复杂度，首先，需要对所有可能的K都求解一次（N）,然后，对于每个K，我们都要从最左端考虑N头牛的情况，最坏的情况下又需要进行N-K+1次反转操作，每次操作需要反转K头牛，所以总的复杂度是O（N<sup>3</sup>）,这个显然，对于5000的问题规模，现在是不能在规定的时间内解决的！所以，我们需要优化。（这个不属于这种方法的内容）</p>

<p>这个，我们可以设一个f[i]代表区间[i,i+K-1]是否进行过反转，反转过就为1，否则为0.那么对于某头牛，我们只需要考虑在它之前的包括它的区间反转次数的和，而我们求的时候是按照顺序来的，所以这个和也可以用O（1）的时间求出来。举个例子，再这个和sum从i-1向i转移的过程中，很显然需要sum-f[i-k]（因为f[i-k]不包括牛i），根据这个sum求出f[i]来，再把f[i]加入到sum中就好，具体看看<a href="/acm/poj/poj3276/">代码</a>应该也挺容易懂的.</p>

<p><a href="http://poj.org/problem?id=3279">POJ3279 Fliptile</a></p>

<p>这个题意也好理解，给你一个m×n的格子，每个格子可能是黑色（1）或者白色（0）,然后你可以进行的操作是可以选择一个格子进行反转，那个格子反转会带动周围的4个格子（上下左右）也反转，问题是最少进行多少步能够把所有的格子反转成白色，如果没有可能，输出IMPOSSIBLE,否则输出字典序最小的反转方案。</p>

<p>跟上一题一样的分析方法，首先，对同一个格子进行2次以上的反转是多余的；其次，反转的格子的顺序对结果是没有影响的！那么接下来，我们需要考虑找到一个可以确定反转方法的最靠前位置的格子（就像上一题最前面的那头牛一样）。但是，假如当前只考虑这些格子的左上角一个格子[i,j]的话，当前还没有确定反转方向的格子中，除了[i,j]之外，实际上还有[i+1,j],[i,j+1]两个个格子可能对他产生影响，所以我们不能非常容易地确定某个格子是不是必须要反转，所以我们要想办法把不确定因素减少。考虑下，假如我们把最上面一行的反转情况固定了，那么，能够影响到最左上角[i,j]的就只有[i+1,j]这一个位置（[i,j],[i,j+1]都被固定了），那么我们就可以根据[i,j]的状态判断[i+1,j]是不是需要反转了（因为这时能影响到[i,j]的只剩下[i+1,j]了）；事实上，我们只需要固定第一行的反转情况就好，因为如果第i行的反转情况固定了，那么根据[i,j]能确定[i+1,j]的反转情况，在跑完一行之后，第i+1行的也就固定了，以此类推就行了！至于怎么固定最上面一行？枚举就好了嘛，怎么枚举呢？记得状态压缩吗？n的范围只有15，所以，你知道了？</p>

<p>我的<a href="/acm/poj/poj3279/">代码</a></p>

<p>下面总结一下这种思想可能会在什么样的情况下用到，只是我自己对比这两道题的解法总结的，如果发现不全的话欢迎补充，发现不对的话欢迎指正：</p>

<p>首先，需要确定两点，第一是顺序无关性，第二是状态有限且有序性（这两道题都是2种状态，而根据我的理解，感觉如果不止是2种状态但是状态的变换是有序的话，也能借鉴这种思想，只不过会很麻烦，可能有其他的方法）；第三就是你每次操作是把一个位置从一个状态转换成下一个状态；第四是对每个位置可以选择操作和不操作。</p>

<p>在满足这以上条件的情况下，可以考虑下能不能用这种方法来解决，这时候我们需要考虑找到一个可以根据之前的操作状态确定来确定当前位置是不是操作的位置（比如第一道题里面的最前面一头牛就可以根据它之前的牛的操作情况来确定自己是不是要操作，而且是确定的，操作就是一定要操作，不操作就一定不操作，第二题里面也是一样，在确定首行之后，[i+1， j]这个位置的操作就能为唯一确定，<strong>必须是唯一确定！！</strong>），能找到这么一个位置的话，还要确定，对这个位置进行了对应的操作之后，依然能找到下一个这样的位置，这样就可以依次递推到最后了！</p>

<p>不知道我说的是不是清楚,最后再说一句,记得14年多校有一题,貌似跟这种思想挺像的,忘了有没有做出来了!</p>

<p><a href="/blog/archives">&lt;&ndash;返回</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[尺取法]]></title>
    <link href="http://whn757397540.github.io/blog/2015/02/13/chi-qu-fa/"/>
    <updated>2015-02-13T22:19:11+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/02/13/chi-qu-fa</id>
    <content type="html"><![CDATA[<p>尺取法，不止一次听说过，也大概知道是怎么回事儿，不过没怎么用过（好像旋转卡壳有用到过），今天就着书本系统地总结一下！</p>

<p>反复推进区间的开头和末尾，来求取满足条件的最小区间的方法成为尺取法</p>

<!--more-->


<p>很简单，不复杂，就着两个例子简单说一下就好。</p>

<p>首先，最基础的一道题。</p>

<p><a href="http://poj.org/problem?id=3061">POJ3061 Subsequence</a></p>

<p>这道题本身就是一道水体，用一些比较暴力的方法也能过，这里只把尺取法说一下！</p>

<p>算法过程如下：（这里依旧取左闭右开的区间[s,t)）</p>

<ol>
<li>以s=t=sum=0初始化；</li>
<li>只要依然有sum&lt;S,就不断讲sum增加a[t]，并且t++;</li>
<li>如果2中无法满足sum>=0则终止，否则，更新res = min(res,t-s);</li>
<li>将sum减去a[s],s++然后返回到2。</li>
</ol>


<p>上面的过程是书上的过程，跟我自己写的略有不同，但是也算是大同小异，我也懒得改了，我之前没写过，自然谈不上什么姿势，姿势最好还是按照上面说的步骤来吧！我的挫挫的<a href="/acm/poj/poj3061/">代码</a>也挂出来</p>

<p><a href="http://poj.org/problem?id=3320">POJ3320 Jessica&rsquo;s Reading Problem</a></p>

<p>这题就稍微需要拐一个弯儿了。我是在知道要用尺取法的情况下，刻意去想而想出来的解法，如果没有知道用尺取法，我也不清楚多久会想出来。</p>

<p>说说我的思路，这道题所有知识点都被覆盖的话，那么你所选择的区间里，所有的知识点都应该要被看到至少一次！所以，我就想如果能够把每个知识点被看到的次数标记出来就好了！但是，知识点的范围是int以内，这就决定了不能直接用数组存储，所以我想到了一个常用的手段，离散化！因为最多10<sup>6</sup>页，所以离散化后，知识点的标号不会超过10<sup>6</sup>。所以呢，离散化后就能够标记次数了。而且，离散化处理的复杂度也就是nlogn，可以接受！</p>

<p>那么有了上面的处理之后，就只需要按照尺取法的步骤来写就好，不同的只不过是判断条件以及标识变量（比如之前一道题的sum）的改变方式而已，仔细想一想，应该很容易解决！这里也挂出我自己的<a href="/acm/poj/poj3320/">参考代码</a></p>

<p>这道题，除了我使用的离散化的处理方法之外，还可以用map来处理，这里给出来参考代码：（PS：这是书上的代码）</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;
const int INF = 0x3f3f3f3f;
const int maxn = 111111;
typedef long long ll;
int a[maxn];
int P;
int main()
{
    int p;
    scanf("%d", &amp;P);
    set&lt;int&gt; all;
    for (int i = 0; i &lt; P; i++)
    {
        scanf("%d", &amp;a[i]);
        all.insert(a[i]);
    }
    int n = all.size();
    //利用尺取法求解
    int s = 0, t = 0, num = 0;
    map&lt;int, int&gt; count;//map映射，知识点-&gt;出现次数的映射
    int res = P;
    for (;;)
    {
        while(t&lt;P &amp;&amp; num &lt; n)
            if (count[a[t++]]++ == 0)
                num++;
        if (num &lt; n)
            break;
        res = min(res, t-s);
        if (--count[a[s++]] == 0)
            num--;
    }
    printf("%d\n", res);

    return 0;
}
</code></pre>

<p><a href="/blog/archives">&lt;&ndash;返回</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二分查找及其应用总结]]></title>
    <link href="http://whn757397540.github.io/blog/2015/02/13/er-fen-cha-zhao-ji-qi-ying-yong/"/>
    <updated>2015-02-13T14:26:37+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/02/13/er-fen-cha-zhao-ji-qi-ying-yong</id>
    <content type="html"><![CDATA[<p>二分搜索法，是通过不断缩小解可能存在的范围，从而求的问题最优解的方法。经常会出现的是二分搜索和其他算法结合的题目。</p>

<p>(PS:有关二分姿势的选取，可以看看<a href="http://blog.csdn.net/u012139398/article/details/38637311">峰霸这短小精悍的博文</a>)</p>

<!--more-->


<p>1.首先，最基本的，从有序数组中查找某个值。</p>

<p>这个问题，再stl中有lower_bound()和upper_bound()来解决，这里给出一个内部算法结构，再简单说说STL的用法</p>

<pre><code class="c++">int lowerBound(int a[], int n, int aim)//返回值是&gt;=aim的第一个位置，如果不存在，返回最后一个元素之后的一个位置（也就是n）
{
    int l = -1, r = n;//初始化解的存在范围，这里求lower_bound的时候采取的是左闭右开的

    while(r-l &gt; 1)//重复循环，一知道解的范围足够小
    {
        int mid = (l+r)/2;
        if (a[mid] &gt;= aim)//如果mid满足条件
            r = mid;//解的存在范围变为(l, mid]
        else
            l = mid;//解的存在范围变为(mid, r]
    }
    return r;
}
</code></pre>

<p>当然，这只是针对整数的情况，而根据实际情况，还会有可能是其他的元素，或者其他的要求，要视情况而定。不再多说，提一下STL库里的两个函数的用法:</p>

<p>首先，lower_bound(a, a+n, d)返回的是数组a里面（a可以是任何有序的数组）,元素值>=d的第一个元素的位置，如果不存在，则返回的是最后一个元素之后的第一个位置，<strong><strong>注意，他的返回值是指针！</strong></strong></p>

<p>然后，upper_bound(a, a+n, d)，与lower_bound（）类似，不过这里找的是>d的第一个元素的位置，不包括等于，不存在的情况与lowerbound相同，返回值也是<strong>指针</strong></p>

<p>2.假定一个解并判断是否可行（二分答案法）</p>

<p>这种解题方法并不是第一次用了，什么情况下用这种方法呢？如果在求解<strong>最大化或最小化的问题中</strong>，能够<strong>比较简单的判断</strong>条件是否满足，那么使用二分搜索法就可以很好得解决问题。</p>

<p>举个简单的例子：</p>

<p><a href="http://poj.org/problem?id=1064">POJ 1064 Cable master</a></p>

<p>我们如果假定答案是x的话，那么每条绳子最多可以切成floor(L[i] / x)段，那么我们只需要判断所有的绳子最多可以切成多少段，如果能切得比K段更多（或者相等），那么就能知道有可能切得更长，这个判断就对应了之前代码的a[mid] >= aim的条件了；同样，反之就说明切得太长了，需要往短了切。所以呢，参考下之前的代码，很容易能写出这一题的代码！我的<a href="/acm/poj/poj1064/">代码</a>仅供参考。</p>

<p>这种类型的题目还很多，记住两个要点：<strong>最大化或者最小化问题中</strong>;<strong>能够比较简单地判断条件是否满足</strong>；在满足以上两个条件的情况下，二分搜索法是一个很好的办法，复杂度是O（判断的复杂度×log(maxans)）.</p>

<p>3.最大化最小值问题</p>

<p>类似最大化最小值或者最小化最大值的问题，通常用二分搜索法就可以很好的解决（实际上，跟2的二分答案法是差不多的）。不多说，挂个例题和解法就过了。</p>

<p><a href="http://poj.org/problem?id=2456">POJ 2456 Aggressive cows</a></p>

<p>定义一个canMake(int d)函数,代表可以安排牛的位置使离得最近的互相仇恨的牛的距离不小于d。这个问题只用贪心法就很容易判断了（具体过程不说了）。之后进行二分答案就好！</p>

<p>参考<a href="/acm/poj/poj2456/">代码</a></p>

<p>4.最大化平均值</p>

<p>这种题呢，说实话，还没有太多印象遇到过，不过既然书上提到了，这里就来讲一讲罗！先来看问题：</p>

<p>有n个物品的重量和价值分别为wi和vi，要从中选出k个物品是的单位重量的价值最大。</p>

<p>这个问题，我刚开始看到的想法就是直接贪心按照单价排序不就好了嘛，可是后来发现这种贪心是错误的（给的样例就能证明）。那么我们可以这样来假设，定义:</p>

<p>C(x) = 可以选择使得单位重量的价值不小于x。</p>

<p>那么原问题就等于是求满足C(x)的最大的x。那么解决了判断问题，就又可以二分答案了。关键我们是怎么判断C(x)呢？假设我们选了某个物品的集合S那么它们的单位重量的价值就是 sigma(vi)/sigma(wi)。</p>

<p>因此就变成了判断是否存在S满足下面的条件</p>

<p>sigma(vi)/sigma(wi) >= x;</p>

<p>把这个不等式变形就得到</p>

<p>sigma(vi - x*wi) >= 0.</p>

<p>因此，我们只需要对vi-x*wi的值进行排序贪心的选取，判断从大到小前k个的和不小于0就行了。每次判断的复杂度是O（nlogn）.</p>

<p>通过上面的内容，我们会发现，不管怎么样，用到二分答案的时候，我们需要先找到一个判断条件，然后对答案进行二分。二分，更重要的是这种思想，它不仅仅是能够搜索数值，还能有更广阔的应用！</p>

<p><a href="/blog/archives">&lt;&ndash;返回</a></p>
]]></content>
  </entry>
  
</feed>
