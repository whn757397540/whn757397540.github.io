<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cf | hnnwang's Blog]]></title>
  <link href="http://whn757397540.github.io/blog/categories/cf/atom.xml" rel="self"/>
  <link href="http://whn757397540.github.io/"/>
  <updated>2015-08-10T18:00:30+08:00</updated>
  <id>http://whn757397540.github.io/</id>
  <author>
    <name><![CDATA[hnnwang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Codeforces Round #261 (Div. 2)]]></title>
    <link href="http://whn757397540.github.io/blog/2014/08/16/codeforces-round-number-261-div-2/"/>
    <updated>2014-08-16T14:32:37+08:00</updated>
    <id>http://whn757397540.github.io/blog/2014/08/16/codeforces-round-number-261-div-2</id>
    <content type="html"><![CDATA[<p>悲剧呀，这场CF差点被AK了，犯了两个小错误。。。T_T,整理下A-D题。</p>

<!--more-->


<p><a href="http://codeforces.com/contest/459">比赛链接</a></p>

<p>A题 Pashmak and Garden</p>

<p>水题，忘记了加绝对值，好多人因为这个WA了，吃一堑长一志吧！以后小心点儿（其实刚开始想到了，后来码代码的时候给忘了T_T）</p>

<p>我的代码写的比较麻烦，没什么参考价值。</p>

<p>B题 Pashmak and Flowers</p>

<p>昨天硕果仅存的一题，排个序，然后用最大数的个数乘最小数的个数就好，如果二者相等的话，种数为C2n,即(n-1)*n/2，记得用long long就好。 代码也不是什么好的姿势，没什么值得学习的地方，不用再挂出来</p>

<p>C题 Pashmak and Buses</p>

<p>这题可以说一说，其实算是有些贪心的思想吧，就是每次把在同一辆车上的所有人分开，比如，刚开始看作所有人都在第0辆车上，然后在第一天把他们分到对应编号的车上（我是取得人标号对k的余数，0当作k），判断多少天能把所有人分开，就看多少天之后，原来在同一辆车上的人都变成了了一个就好。而方案的花，就是每次对同一辆车上的人进行重新编号，然后按照跟第一次相同的规则来分，这样一直分d天就可以了。这个策略是可以证明是正确的，并不只是根据感觉。证明我就不写了。</p>

<p>需要说一下的是，如果 k >= n的话，直接一人一辆车就好；如果k == 1并且 n > 1的话，永远也不可能分开，这种情况如果按照之前的输出，会陷入死循环，我就错在了这里。</p>

<p>代码有点奇葩。</p>

<pre><code class="c++">include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N=1005;
vector &lt;int&gt; bus[2][N];
int ans[N][N];
int main()
{
    int n,k,d;
    cin&gt;&gt;n&gt;&gt;k&gt;&gt;d;
    if (k &gt;= n)
        for (int i =1; i &lt;= d ; i++)
            for (int j =1; j &lt;= n; j++)
                printf("%d%c",j,(j == n ? '\n' : ' '));
    else if (k == 1) printf("-1\n");
    else
    {
        int m = n;
        int cntd=1;
        while (m / k + ( m % k == 0 ? 0 : 1) &gt; 1)
        {
           cntd++;
           m = m / k + (m % k == 0 ? 0 : 1);
        }
        if (cntd &gt; d)
            printf("-1\n");
        else
        {
            int now = 0;
            for (int i = 1; i &lt;= n; i ++)
            {
                bus[now][i%k == 0 ? k : i%k].push_back(i);
                ans[1][i] = (i%k == 0 ? k : i%k);
            }
            for (int i = 2; i &lt;= d ; i++)
            {
                for (int j = 1; j &lt;= k; j++)
                    bus[now^1][j].clear();
                for (int j = 1; j &lt;= k; j++)
                {
                    for (int t = 0; t &lt; bus[now][j].size(); t++)
                    {
                        int student = bus[now][j][t];
                        bus[now^1][(t+1)%k == 0 ? k : (t+1)%k].push_back(student);
                        ans[i][student] = ((t+1)%k == 0 ? k : (t+1)%k);
                    }
                }
                now ^= 1;
            }
            for (int i = 1; i &lt;= d; i++)
            {
                for (int j = 1; j &lt; n; j++)
                    printf("%d ",ans[i][j]);
                printf("%d\n",ans[i][n]);
            }
        }
    }

    return 0;
}
</code></pre>

<p>D题 Pashmak and Parmida’s proble</p>

<p>先说说这题的思路吧。</p>

<p>首先把坐标离散化，方便计数，记录每一位上的左边跟他相等的数的个数L[i]，和右边跟他相等的数的个数R[i]，这个用O（n）的复杂度就能处理出来。</p>

<p>然后，开一个树状数组来记录R[i]的和，之后倒着扫，边扫边更新树状数组和答案，由于你从第n个数扫到地i个数的时候，前一半都还没有记录进去，所以树状数组记录的是后一部分R[i]的和，所以对于i位的时候就能求出它后面总共有多少个满足条件的位置。说的不是特别清楚，自己看代码想一下吧</p>

<pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 1000006;

int lowbit(int n)
{
    return n&amp;(-n);
}

int n;
int Update(int k,int det,int a[])
{
    for (int i = k; i &lt;= n; i += lowbit(i))
        a[i] += det;
}

int GetSum(int k,int a[])
{
    int res = 0;
    for (int i = k; i &gt; 0 ; i -= lowbit(i))
        res += a[i];
    return res;
}
struct data{
    int dat;
    int num;
}a[N];

bool cmp(data a,data b)
{
    return a.dat &lt; b.dat;
}
int b[N],c[N] = {0};
int cnt[N]={0};
int L[N];
int main()
{
    scanf("%d",&amp;n);
    for (int i = 0; i &lt; n; i++)
    {
        scanf("%d",&amp;a[i].dat);
        a[i].num = i;
    }
    sort(a,a+n,cmp);
    int cc = 1;
    b[a[0].num] = 1;
    for (int i = 1; i &lt; n; i++)
    {
        if (a[i].dat == a[i-1].dat)
            b[a[i].num] = cc;
        else
            b[a[i].num] = ++cc;
    }
    for (int i = 0; i &lt; n; i++)
    {
        cnt[b[i]]++;
        L[i] = cnt[b[i]];
    }
    memset(cnt,0,sizeof(cnt));
    long long ans = 0;
    for (int i = n-1; i &gt;= 0; i--)
    {
        cnt[b[i]]++;
        ans += GetSum(L[i]-1,c);
        Update(cnt[b[i]],1,c);
    }
    printf("%I64d\n",ans);
}
</code></pre>

<p>有关L，R的计数，看别人代码发现一种神奇的map法,这里挂个L部分的。</p>

<pre><code class="c++">map &lt;int, int&gt; hash;
for (int i = 0; i &lt; n; i++)
{
    scanf("%d",&amp;a[i]);
    L[i] = ++hash[a[i]];
}
</code></pre>

<p>其实就相当于用map代替了之前的离散化操作，在这里是可以用的，我这对map不怎么熟悉的小白是想不出这种方法来，不过好在有sort函数，离散化也不是很复杂的，而且，很多情况下，是不能用这种东西代替离散化的。</p>

<p>根据我的理解简单说一下，因为这里离散化的目的是为了方便计数，而用map映射很容易实现这种计数.但是在有些情况下，比如poj2299用树状数组来记录各个大小的数的个数来求和的话，就显然不能用了。</p>

<p><a href="/blog/archives/">&lt;&ndash;Back</a></p>
]]></content>
  </entry>
  
</feed>
