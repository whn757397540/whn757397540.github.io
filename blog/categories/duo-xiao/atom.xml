<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 多校 | hnnwang's Blog]]></title>
  <link href="http://whn757397540.github.io/blog/categories/duo-xiao/atom.xml" rel="self"/>
  <link href="http://whn757397540.github.io/"/>
  <updated>2015-08-09T22:15:30+08:00</updated>
  <id>http://whn757397540.github.io/</id>
  <author>
    <name><![CDATA[hnnwang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[2015年多校联合训练（二）]]></title>
    <link href="http://whn757397540.github.io/blog/2015/07/24/test/"/>
    <updated>2015-07-24T05:57:05+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/07/24/test</id>
    <content type="html"><![CDATA[<!-- more -->


<p>1002题： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5301">HDU 5301 Building</a></p>

<p>这道题实际应该是最水的题目了，非常简单，最大的面积的矩形的宽度肯定是1，而长度只有可能是5个位置之中的到边界的最小距离的最大值，这5个位置分别是，不能占用的块相邻的4个位置和中心的位置。敲的时候细心一点就好。</p>

<p>1004题： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5303">HDU 5303 Delicious Apples</a></p>

<p>这道题，在比赛时应该是做不出来的。根据曹霸的思路，是一道dp题。</p>

<p>由于苹果总数只有10<sup>5</sup>个，所以我们可以这样dp，先按照距离给果树排序，然后依次给每个苹果标号，编号为i的苹果与储藏处的距离记录在apple[i]之中。之后用两个数组，dp1[i]来记录顺时针出发（总是顺时针出发）最后取到第i个苹果时所花费的总距离（第i个之前的苹果都被运回了储藏处，这也是我们之前排序的原因。），则dp1[i] = dp1[i-k]+apple[i]+min(apple[i],L-apple[i])，因为取的第i个苹果有可能在左半圆，也有可能在右半圆，在右半圆应该是接着往前走走到起点比原路返回近。同理，dp2[i]表示逆时针的，同样i也要反过来，从大到小。。最后再暴力判断一下，对于每个i作为分界点来计算dp1[i]+dp2[i+1]的最小值即可。</p>

<p><a href="/acm/hdu/hdu5301/">代码</a></p>

<p>1006题： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5305">HDU 5305 Friends</a></p>

<p>这道题如果数据范围大的化不会很简单，由于数据范围并不大，所以直接暴力枚举即可，记得稍微剪枝一下，比如如果有个人同奇数个人有关系的，就肯定不可能有符合的情况了。</p>

<p>1009题： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5308">HDU 5308 I Wanna Become A 24-Point Master</a></p>

<p>这个就是一个模拟题，我们的思路是，</p>

<p>首先1～3是不可能构成的</p>

<p>然后4～12手动构造，</p>

<p>13～18有如下规律：首先令k=(24-n),用k+1个数构成k，然后再加上n得到24，剩下的肯定是偶数个，就加一个减一个即可。（当然，这个到24都是适用的）</p>

<p>19之后有如下规律：当n为奇数时，我们可以用3个数构造一个2，再用16个数构造8个1，然后就可以构造出一个4和一个6，然后相乘得到24，总共花费19个数，剩下偶数个数，加一个减一个即可；当n为偶数时，用20个数构造10个1，之后就可以构造一个4和一个6，然后得到24，之后剩下的还是偶数个数，只需要加一个减一个即可。</p>

<p>之后就可以写出来了，我们的<a href="/acm/hdu/hdu5308/">代码</a>在这里。</p>

<p>其实还有很多种构造方法，比如我们可以用5个1构造一个4，7个1构造一个6（先相加再相除），共用12个；或者用4个1构造一个3，9个1构造一个8，共用13个；这样，在12之后就可以统一写了，这是S菊苣他们队伍的思路。其他的当然也有，就不用一一列举了，就是写的时候小心一点，就是一个不算特别大的模拟题。</p>

<p>今天就先到这里</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2015年多校联合训练第一场]]></title>
    <link href="http://whn757397540.github.io/blog/2015/07/21/test-new/"/>
    <updated>2015-07-21T23:10:54+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/07/21/test-new</id>
    <content type="html"><![CDATA[<h1>2015年多校联合训练第一场</h1>

<!--more-->


<p>1001题：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5288">hdu 5288 OO’s Sequence</a></p>

<p>这个题，其实就是考虑每个位置的a[i]对答案的贡献是多少.找到从i开始向左都符合条件的最大区间，和向右都符合条件的最大区间，两个区间长度相乘就是a[i]对答案的贡献。</p>

<p>方法很简单，先处理出1000以内的每个数的因数，这个暴力预处理就好。然后扫一遍，扫到每个数，就找他的因数里面距离他最近的那个位置，就能求出区间的长度，左右都一样，最后求和就行，乘法可能暴int(吗？),反正转换以下肯定没有错</p>

<p><a href="/acm/hdu/hdu5288/">代码</a></p>

<p>1002题：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5289">HDU 5289 Assignment</a></p>

<p>这个题非常简单，使用单调队列，维护一个最大值的单调队列和一个最小值的单调队列，然后设定一个头，每次当最大值和最小值的差不小于k就让头加1，否则在答案里增加当前的区间长度。具体可以根据<a href="/acm/hdu/hdu5289/">代码</a>来看清楚</p>

<p>1005题 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5292">HDU 5292 Pocket Cube</a></p>

<p>这个题其实没什么好说的，算是一个结论题，仔细研究过魔方的人很容易就知道，而没玩过的人想想出来是非常困难的。就是按照官方题解的思路来喽，上面写的圈值+代表1，-代表-1，0代表0。当然正负反一下也可以，不过要保证对面的数字和为0.</p>

<p>1006题 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5293">HDU 5293 Tree chain problem</a></p>

<p>树型dp，本人这方面比较弱，看了题解才能写出来，玮神说这题要比第9题简单，2333。思路就是题解中的思路，关于后面的求和部分，可以利用树状数组（时间比较紧）。对于dfs过程中到达的每个点，记录达到这个点的时间戳和离开这个点的时间戳。然后以时间戳为下标来更新树状数组，在达到这个点的时候加上对应的数字（求sum[i]的和就加上sum[i]，求d[i]的和就加上d[i],用两个树状数组维护），离开这个点的时候减去这个数字，这样只需要对应求和就可以得到想要的和。</p>

<p><a href="/acm/hdu/hdu5293/">代码</a>在这里，刚开始是建的双向图，然后给T了，就只好建单向图。还有就是这题要扩栈，在题目的hint里有提示，但是一定要用c++交才可以。</p>

<p>1007题 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5294">HDU 5294 Tree chain problem</a></p>

<p>其实并不难，就是敲的时候小心模板不要敲错了，我们的做法是先求最短路（用dijkstra），然后记录所有最短路径上的点的父亲节点，然后从终点开始dfs父亲节点，最终构造出一个最短路的图。</p>

<p>之后就是在这个图的基础上，设定所有的边流量为1求最大流（也就是在求这个图的最小割），这是第一个输出数据，第二个数据应该是所有边的边数减去边数最少的最短路上的边数，这个可以用bfs来求，不过我们是用了dfs来求的。</p>

<p><a href="/acm/hdu/hdu5294/">代码在这里</a></p>

<p>1009题 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5296">HDU 5296 Annoying problem</a></p>

<p>这个题也是看了题解才知道怎么写，而且也参考了标程，首先处理LCA，记录dfs顺序也是用到了时间戳。为什么要选择dfs序最近的左右两个点呢？其实对于每种情况，不只是这两个点可以，也有其他的点可以，但是画图后观察可以发现，dfs序最近的两个点之间的路径到点的距离肯定是是所有集和的最近距离（说了好像没说一样，我也只是看了题解后画了画，并不知道怎么证明。），而实现上，找这两个点，利用了set。<a href="/acm/hdu/hdu5296/">代码</a>在这里</p>

<p>1012题 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5299">hdu 5299 Circles Game</a></p>

<p>这个题呀，其实，在比赛刚刚开始，一道题都没有过的时候，我的猜想就是正确的，只不过太久没有做过博弈的题目，使得我并没有证明，然后最后又想别的办法。</p>

<p>这个题的证明基于几个结论：</p>

<ol>
<li>sg函数得到的sg值等同于NIM游戏的一堆石子的石子个数（至于多堆石子异或和为0先手必败就不用说了吧）</li>
<li>多个博弈游戏的sg值的异或和就是将这多个游戏组成一个大的游戏的sg值。</li>
</ol>


<p>那么在上面两个的基础上，就可以来证明了，首先，我们注意到，如果是一个圆套一个圆，那么这一组圆(假设有n个)就可以看成是一个个数为n的石子堆，其实就是说他的sg值为n(这个也可以通过sg的定义来证明出来)。假设一个圆内有很多个不互相包含的圆，那么每个圆都可以看作是一个游戏，这个游戏是有自己的sg值的，将这几个游戏取异或和，就会得到这个圆内所有游戏的sg值（设为sg1吧），那么这些游戏等效于一个sg值为sg1的游戏，也就是sg1个圆一个套一个，这时加上外面那个圆，其实对于外面一层来说，就相当于那个圆代表的游戏的sg值为sg1+1，这样就可以递归地得到所有游戏的sg值，得到最终的sg值。（刚开始就是猜想异或和加1，然后没有深入去想）。</p>

<p>至于圆的处理，也不算难吧，应该是扫瞄线的思想吧，用一个暴力点的方法，先对所有的圆按照最左侧的x坐标排序，然后依次扫描，每次扫描从当前位置开始往前的最近的那个圆是哪个，然后那个圆就是当前这个圆的父节点了，最终构成一棵树，每个节点代表一个圆，子节点代表圆内的圆，之后就按照之前所说的计算sg的方法来计算就行，终点节点为空圆，空圆内部没有圆，所以他内部的游戏sg值为0.</p>

<p><a href="/acm/hdu/hdu5299">代码在此</a></p>

<p><a href="http://blog.sina.com.cn/u/5657719201">官网题解博客</a></p>
]]></content>
  </entry>
  
</feed>
