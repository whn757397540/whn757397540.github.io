<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: acm | hnnwang's Blog]]></title>
  <link href="http://whn757397540.github.io/blog/categories/acm/atom.xml" rel="self"/>
  <link href="http://whn757397540.github.io/"/>
  <updated>2015-04-20T22:53:39+08:00</updated>
  <id>http://whn757397540.github.io/</id>
  <author>
    <name><![CDATA[hnnwang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[树状数组以及线段树总结]]></title>
    <link href="http://whn757397540.github.io/blog/2015/03/14/shu-zhuang-shu-zu-yi-ji-xian-duan-shu-zong-jie/"/>
    <updated>2015-03-14T18:57:26+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/03/14/shu-zhuang-shu-zu-yi-ji-xian-duan-shu-zong-jie</id>
    <content type="html"><![CDATA[<p>大年初一初二两天，除了玩儿，也就看了看这些，zkw线段树看了看，想了想还是放弃了；二维线段树看了看，马马虎虎敲了几道题，规范了下二维线段树的代码；二维树状数组重新回顾了一下，其实跟一维树状数组是完全一样的；然后重新看了看书上的树状数组，也是有一些收获的，接下来就谈一谈！</p>

<!--more-->


<p>这次先把该说的说了，最后集中看题。</p>

<p>首先，线段树我就不多做介绍了,只是来介绍下二维线段树的写法：二维线段树，简单来说，就是树套树，一个线段树的域是值，另一个线段树的域是那个线段树。具体的写法一会儿看我做的最后一道二维线段树的题目的代码，那时我整理过姿势后的板子！这里说下思路，就是通过第一个树来建树（域是线段树的树），这棵树维护的是第一维的区间，然后对应再每一个节点上建立一个线段树（域是值的树，假如称它为子树），这个维护的是第二位的区间；也就是说，子树是嵌套再外围的线段树里面的；其实不管是建树，更新还是查找，都是一棵树套一棵树，这些具体需要看着代码来理解会比较好，这里要说的一点，就是更新的时候，以单点更新为例，因为你要找到(x,y)这个点，我们想一下1维线段树，只需要找到目标节点更新值，然后递归更新回去就好；类比下二维，一样也应该是找到目标节点然后更新值，然后递归更新回去，但是关键就是，这个点除了要再第二维坐标上更新，还得在第一维坐标上更新，而且你找目标节点的时候，也不是只是l == r == y就好，还需要注意第一维坐标必须是在x处，但是又不能值更新第一维坐标是x的线段树，那么怎么办呢？其实看看代码就知道了，就是再更新的第一维的区间不是[x,x]，而是包含[x,x]区间的时候，记得在找到y这个位置的时候，更新下第一维的值就好！说的有点乱，还是等一会儿看代码好一些！</p>

<p>另外，zkw线段树放弃了，但是也不见得以后也不会看，只不过现在没有那个时间取研究而已！</p>

<p>接着，关于树状数组，我在之前的博客里面有讲过,<a href="http://hnnwang.github.io/blog/2014/07/23/shu-zhuang-shu-zu-zong-jie/">链接在这里</a>,里面提到了利用树状数组进行单点修改，区间查询、区间修改，单点查询、区间修改，区间查询的方法，但是那里面的区间修改，区间查询的方法，利用的是差分的思想，这里再来说一个再《挑战程序设计竞赛》中提到的多项式的方法，还是以<a href="http://poj.org/problem?id=3468">poj3468</a>为例，这个题在之前那个博客里面也有，那里面有利用差分方法的代码，这道题就是简单的一道区间修改区间查询的问题，我们进行如下推导：</p>

<p>如果给区间[l,r]同时加上x的话，那么每个节点的值将如何变化呢？我们设</p>

<p>s(i) = 加上x之前的sigma(a[1……i])；</p>

<p>ss(i) = 加上x之后的sigma(a[1……i])；</p>

<p>那么我们就有</p>

<p>i &lt; l → ss(i) = s(i);//区间里面的东西没有被改变</p>

<p>l &lt;= i &lt;= r → ss(i) = s(i) + (i-l+1) = s(i) + xi - x(l-1);</p>

<p>i > r → ss(i) = s(i) + x*(r-l+1)</p>

<p>那么下面我们如果及sum(bit, i)为树状数组bit的前i项和。我们构建两个树状数组bit0和bit1，并且设</p>

<p>sigma(a[1..i]) = sum(bit1,i)*i + sum(bit0,i);</p>

<p>那么再[l,r]区间上同时加上x就可以看成是</p>

<p>在bit0的l位置加上-x(l-1);//对应上面第二条的-x*(l-1)</p>

<p>在bit1的l位置加上x ;//在l之后(包括l)，每个都多加一个x</p>

<p>在bit0的r+1位置加上xr；//在i>r之后的式子中，跟在bit0的中加上的那个式子相比，少一个xr，所以加上xr，以保证再这之后的计算都是算的x*(r-l+1);</p>

<p>在bit1的r+1位置加上-x；在r+1之后(包括r+1)，每一个都减一个x，跟之前加的那个x抵消，从而达到指示[l,r]区间加的目的</p>

<p>这4个操作。因此，查询和更新的操作都可以在O（logn）的时间里完成。</p>

<p>更一般的，如果操作得到的结果可以用i的n次多项式来表示的话，那么就可以使用n+1个树状数组来进行维护了！至于代码就不贴了，这个只要推出公式来就简单了！</p>

<p>至于二维树状数组，非常简单，根本不用说。只要一会看一下一道题的代码就知道了，其实就是再一维树状数组的基础上加上了一维。</p>

<p>好了，接下来进入题目环节，简单的讲解几道题就好！</p>

<p>首先，一维线段树的，也是书上的例题</p>

<p><a href="http://poj.org/problem?id=2991">POJ 2991 Crane</a></p>

<p>这道题稍微用到了一些计算几何的知识，也就是个旋转而已；来说下怎么建树和维护，建树维护下面两个域: 一是第一条线段起点指向最后一条线段终点的向量； 二是（如果该节点有儿子节点），右儿子节点绕左儿子节点逆时针旋转的角度！</p>

<p>有了以上那两个域，就可以利用计算几何中的旋转公式来维护线段树了，这里说下计算几何上的旋转公式以及其推导方法！</p>

<p>假如向量p = (x,y) 绕原点旋转角度 β 到向量q = (x’, y’)，我们把直角坐标转换为极坐标，那么就应该是p=(lcosα， lsinα） 转动 β 到 q=(lcos(α+β), lsin(α+β)）， 运用三角函数和差公式可以得到 q = (lcosαcosβ - lsinαsinβ， lsinαcosβ + lcosαsinβ) = (xcosβ - ysinβ， xsinβ + ycosβ), 这可得旋转公式！</p>

<p>具体的维护细节就不说了，自己思考思考把，我的参考代码挂出来</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
using namespace std;

typedef long long ll;
const int maxn = 10050;
const double PI = acos(-1);
struct Point{
    double x,y;
    Point(){};
    Point(double x, double y): x(x),y(y){};
    bool operator &lt; (const Point p)const{return x &lt; p.x || (x==p.x &amp;&amp; y &lt; p.y);}
    Point operator - (Point p){return Point(x - p.x, y - p.y);}
    Point operator + (Point p){return Point(x + p.x, y + p.y);}
    Point rotate(double rad){return Point(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad));}
};

typedef Point Vector;
struct Tree{
    int l,r;
    Vector v;
    double ang;
}a[4*maxn];
double rec[maxn];
void buildTree(int now,int l, int r)
{
    int lson = 2*now, rson = 2*now+1;
    a[now].v = Point(0,0);
    a[now].ang = 0;
    a[now].l = l;
    a[now].r = r;
    if (l == r) return;
    int mid = (l+r)/2;
    buildTree(lson, l, mid);
    buildTree(rson, mid+1, r);
}

void Insert(int now, int aim, Vector v)
{
    if (a[now].l == a[now].r &amp;&amp; a[now].l == aim)
        a[now].v = v;
    else
    {
        int lson = 2*now, rson = 2*now+1;
        int mid = (a[now].l + a[now].r)/2;
        if (aim &gt; mid)
            Insert(2*now+1, aim, v);
        else
            Insert(2*now, aim, v);
        a[now].v = a[lson].v + a[rson].v;
    }
}

void Change(int now, int aim, double ang)
{
    int lson = 2*now, rson = 2*now+1;
    if (a[lson].r == aim)
    {
        a[now].ang += ang - rec[aim];
        a[now].v = a[lson].v + a[rson].v.rotate(a[now].ang);
        return;
    }
    int mid = (a[now].l + a[now].r) / 2;
    if (aim &lt;= mid)
    {
        Change(lson, aim, ang);
        a[now].ang += ang - rec[aim];
    }
    else
        Change(rson, aim, ang);
    a[now].v = a[lson].v + a[rson].v.rotate(a[now].ang);
}

int main()
{
    int n,c;
    while (~scanf("%d%d", &amp;n, &amp;c))
    {
        buildTree(1, 1, n);
        for (int i = 1; i &lt;= n; i++)
        {
            int w;
            scanf("%d", &amp;w);
            Insert(1, i, Point(0,w));
            rec[i] = PI;
        }
        for (int i = 0; i &lt; c; i++)
        {
            int s;
            double ang;
            scanf("%d%lf", &amp;s, &amp;ang);
            double rad = ang/180*PI;
            //cout&lt;&lt;rad&lt;&lt;endl;
            Change(1, s, rad);
            rec[s] = rad;
            printf("%.2f %.2f\n", a[1].v.x, a[1].v.y);
        }
        printf("\n");
    }
}
</code></pre>

<p>然后，二维线段树：</p>

<p><a href="http://poj.org/problem?id=2155">poj2155 Matrix</a></p>

<p>这道题，解法十分简单，是道基础题，用到了一个思想，就是对于区间的更新，可以不用懒标记，只是重新维护一个域，然后不下传，最后求结果的时候从最底层回溯上去，或者在从上向下找结果的时候，顺便根据维护的那个域进行更新。这道题就是，因为操作一次就改变一次0或者1，所以只需要找到操作的区间，然后记录次数，最后算结果的时候看找结果总共操作了多少次，从而求出答案，（当然，不用记录次数，直接跟1取异或即可），这是我的第一个代码,有点丑，必经是自己写的,还是第一次，不要以这个为参考。</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;

#define mid  ((l+r)&gt;&gt;1)
#define lson (now&lt;&lt;1)
#define rson (lson|1)
using namespace std;
const int maxn = 1010;
const int maxe = 20200;
const int INF = 0x3f3f3f3f;

struct Tree2{
    int l,r,data;
};

struct Tree1{
    int l,r;
    Tree2 T2[maxn&lt;&lt;2];
}T1[maxn&lt;&lt;2];

int a[maxn][maxn];
int n,Q,X;
int x1, y1, x2, y2;
int ans;
void buildTree2(Tree1 &amp;T, int now, int l, int r)
{
    T.T2[now].l = l;
    T.T2[now].r = r;
    T.T2[now].data = 0;
    if (l == r)
        return;
    buildTree2(T, lson, l, mid);
    buildTree2(T, rson, mid+1, r);
}

void buildTree1(int now, int l, int r)
{
    T1[now].l = l;
    T1[now].r = r;
    buildTree2(T1[now], 1, 1, n);
    if (l == r)
        return;
    buildTree1(lson, l, mid);
    buildTree1(rson, mid+1, r);
}

void update2(Tree1 &amp;T, int now, int l, int r)
{
    if (l == T.T2[now].l &amp;&amp; r == T.T2[now].r)
    {
        T.T2[now].data ^=1;
        return;
    }
    if (r &lt;= T.T2[lson].r)
        update2(T, lson, l, r);
    else if(l &gt;= T.T2[rson].l)
        update2(T, rson, l, r);
    else
    {
        update2(T, lson, l, T.T2[lson].r);
        update2(T, rson, T.T2[rson].l, r);
    }
}

void update1(int now, int l, int r)
{
    if (l == T1[now].l &amp;&amp; r == T1[now].r)
    {
        update2(T1[now], 1, y1, y2);
        return;
    }
    if (r &lt;= T1[lson].r)
        update1(lson, l, r);
    else if(l &gt;= T1[rson].l)
        update1(rson, l, r);
    else
    {
        update1(lson, l, T1[lson].r);
        update1(rson, T1[rson].l, r);
    }
}

void Search2(Tree1 &amp;T, int now, int y)
{
    ans ^= T.T2[now].data;
    if (y == T.T2[now].l &amp;&amp; y == T.T2[now].r)
        return;
    if (y &lt;= T.T2[lson].r)
        Search2(T, lson, y);
    else
        Search2(T, rson, y);
}

void Search1(int now, int x, int y)
{
    Search2(T1[now], 1, y);
    if (T1[now].l == x &amp;&amp; T1[now].r == x)
        return;
    if (x &lt;= T1[lson].r)
        Search1(lson, x, y);
    else
        Search1(rson, x, y);
}

int main()
{
    scanf("%d", &amp;X);
    while(X--)
    {
        //cout&lt;&lt;X&lt;&lt;endl;
        scanf("%d%d", &amp;n, &amp;Q);
        buildTree1(1,1,n);
        char order;
        ans = 0;
        //cout&lt;&lt;Q&lt;&lt;endl;
        while(Q--)
        {
            scanf("%s", &amp;order);
            //cout&lt;&lt;Q&lt;&lt;endl;
            if (order == 'C')
            {
                scanf("%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2);
                update1(1, x1, x2);
            }
            else if (order == 'Q')
            {
                int x, y;
                ans = 0;
                scanf("%d%d", &amp;x, &amp;y);
                Search1(1, x, y);
                printf("%d\n", ans);
            }
        }
        printf("\n");
       // cout&lt;&lt;X&lt;&lt;endl;
    }
    //system("pause");
    return 0;

}
</code></pre>

<p><a href="http://poj.org/problem?id=4819">hdu4819 Mosaic</a></p>

<p>这是一道简单的二维线段树RMQ问题，就是利用二维线段树更新的思想进行更新，参考一维线段树的RMQ的方法就好，注意在前面说的那几点。这道题的代码是经过我的整理的，虽然很麻烦，但也应该很清楚。</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;

#define mid  ((l+r)&gt;&gt;1)
#define lson (now&lt;&lt;1)
#define rson (lson|1)
using namespace std;
const int maxn = 1010;
const int INF = 0X3F3F3F3F;
struct Sub_tree{
    int l,r;
    int mindat,maxdat;
};

struct Tree{
    int l,r;
    Sub_tree st[maxn&lt;&lt;2];
}t[maxn&lt;&lt;2];

int a[maxn][maxn];
int ans, ansmax, ansmin;
int n;
void build_sub_tree(int u, int now, int l, int r)
{
    Sub_tree *st = t[u].st;
    st[now].l = l; st[now].r = r; st[now].mindat = INF; st[now].maxdat = 0;
    if (l == r)
    {
       // st[now].mindat = st[now].maxdat = a[u][l];
        return;
    }
    build_sub_tree(u, lson, l, mid);
    build_sub_tree(u, rson, mid+1, r);
    st[now].mindat = min(st[lson].mindat, st[rson].mindat);
    st[now].maxdat = max(st[lson].maxdat, st[rson].maxdat);
}

void build_tree(int now, int l, int r)
{
    t[now].l = l; t[now].r = r;
    build_sub_tree(now, 1, 1, n);
    if (l == r)
        return;
    build_tree(lson, l, mid);
    build_tree(rson, mid+1, r);
}

void search_sub_tree(int u, int now, int l, int r)
{
    Sub_tree *st = t[u].st;
    if (st[now].l == l &amp;&amp; st[now].r == r)
    {
        ansmax = max(st[now].maxdat, ansmax);
        ansmin = min(st[now].mindat, ansmin);
        return;
    }
    int MID = st[lson].r;
    if(r &lt;= MID)
        search_sub_tree(u, lson, l, r);
    else if (l &gt; MID)
        search_sub_tree(u, rson, l, r);
    else
    {
        search_sub_tree(u, lson, l, MID);
        search_sub_tree(u, rson, MID+1, r);
    }
}

void search_tree(int now, int l, int r, int l2, int r2)
{
    if (t[now].l == l &amp;&amp; t[now].r == r)
    {
        search_sub_tree(now, 1, l2, r2);
        return;
    }
    int MID = t[lson].r;
    if (r &lt;= MID)
        search_tree(lson, l, r, l2, r2);
    else if (l &gt; MID)
        search_tree(rson, l, r, l2, r2);
    else
    {
        search_tree(lson, l, MID, l2, r2);
        search_tree(rson, MID+1, r, l2, r2);
    }
}

void update_sub_tree(int u, int now, int aim, int dat)
{
    Sub_tree *st = t[u].st;
    if (st[now].r == st[now].l)
    {
        if (t[u].l == t[u].r)
            st[now].mindat = st[now].maxdat = dat;
        else
        {
            st[now].mindat = min(t[u&lt;&lt;1].st[now].mindat, t[u&lt;&lt;1|1].st[now].mindat);
            st[now].maxdat = max(t[u&lt;&lt;1].st[now].maxdat, t[u&lt;&lt;1|1].st[now].maxdat);
        }
        return;
    }
    int MID = st[lson].r;
    if (aim &lt;= MID)
        update_sub_tree(u, lson, aim, dat);
    else
        update_sub_tree(u, rson, aim, dat);
    st[now].mindat = min(st[lson].mindat, st[rson].mindat);
    st[now].maxdat = max(st[lson].maxdat, st[rson].maxdat);
}

void update_tree(int now, int aim1, int aim2, int dat)
{
    if (t[now].l == t[now].r)
    {
        update_sub_tree(now, 1, aim2, dat);
        return;
    }
    int MID = t[lson].r;
    if (aim1 &lt;= MID)
        update_tree(lson, aim1, aim2, dat);
    else
        update_tree(rson, aim1, aim2, dat);
    update_sub_tree(now, 1, aim2, dat);

}

int main()
{
    int T;
    cin&gt;&gt;T;
    int ks = 0;
    while(T--)
    {
        scanf("%d", &amp;n);
        printf("Case #%d:\n", ++ks);
        build_tree(1,1,n);
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= n; j++)
            {
                int d;
                scanf("%d", &amp;d);
                update_tree(1, i, j, d);
            }
        int m;
        scanf("%d", &amp;m);
        for (int i = 0; i &lt; m; i++)
        {
            int x,y,l;
            scanf("%d%d%d", &amp;x, &amp;y, &amp;l);
            int x1 = max(x-l/2, 1), x2 = min(x+l/2, n), y1 = max(y-l/2, 1), y2 = min(y+l/2, n);
            ansmax = 0; ansmin = INF; ans = 0;
            //cout&lt;&lt;1&lt;&lt;endl;
            search_tree(1, x1, x2, y1, y2);
            ans = (ansmax+ansmin)&gt;&gt;1;
           // cout&lt;&lt;ans&lt;&lt;endl;
            update_tree(1, x, y, ans);
            //cout&lt;&lt;3&lt;&lt;endl;
            printf("%d\n", ans);
        }
    }
}
</code></pre>

<p>还有一道题，也是RMQ的，不打算写出来了，白白浪费了我好久的时间，总感觉自己没错，但是总也过不了，后来拿网上题解的代码去交，百度前2页的都过不了，我就郁闷了，怀疑是那道题的数据或者什么的出现了问题，后来放弃了，上面那个hdu4819就是我放弃这个之后重新找的一道题，由于都是RMQ，所以也差不多啦！</p>

<p>然后，二维树状数组，一道基础题：</p>

<p><a href="http://poj.org/problem?id=1195">POJ1195 Mobile phones</a></p>

<p>题意简单，代码也简单，不讲了，就挂个代码,纯属为了给一个二维树状数组的例子</p>

<pre><code class="c++">//poj1195 二维树状数组
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define N 1025

int S,C[N][N];


int Lowbit(int n)
{
  return n&amp;(n^(n-1));
}

void Update(int x,int y,int delta)
{
    for(int i = x; i &lt;= S; i += Lowbit(i))
        for(int j = y; j &lt;= S; j += Lowbit(j))
          C[i][j] += delta;
}

int getSum(int x,int y)
{
  int result = 0;
    for(int i = x; i &gt; 0; i -= Lowbit(i))
        for(int j = y; j &gt; 0; j -= Lowbit(j))
            result+=C[i][j];
    return result;
}

main()
{
  int Ins;
  while(scanf("%d", &amp;Ins),Ins != 3)
  {
      if (Ins == 0)
      {
          scanf("%d", &amp;S);
          memset(C, 0, sizeof(C));
      }
      if (Ins == 1)
      {
          int X, Y, a;
          scanf("%d%d%d", &amp;X, &amp;Y, &amp;a);
          Update(X+1, Y+1, a);
      }
      if (Ins == 2)
      {
          int L, B, R, T;
          scanf("%d%d%d%d", &amp;L, &amp;B, &amp;R, &amp;T);
          int sum=getSum(R+1, T+1) + getSum(L, B) - getSum(L, T+1) - getSum(R+1, B);
          printf("%d\n",sum);
      }

  }
}
</code></pre>

<p>最后，K-th Number问题：</p>

<p>poj2104 K-th Number</p>

<p>这也是桶分法，平方分割那一节的例题，这里说两种方法。</p>

<p>第一是平方分割（桶分）法.首先，我们需要转换一下问题，直接去求某个区间的第k大数是很难的，但是，它只有100000个数，我们可以先假定一个数，然后看它是第几大数，用二分答案法来找到答案。（当然，这个得要求是有序的），这样，我们就变成了求k是要求区间的第几大数这个问题，接下来我们要想怎么解决这个问题。</p>

<p>先把所有的数分到几个桶里，每个桶的容量都是一样的，然后对每个桶里数进行排序；之后查询的时候，假如区间为[l,r]，没有完全被包含再[l,r]内的区间（最多2个）直接暴力判断，包含在内的，在排好序的桶里面用二分法比x小的总共有多少个。</p>

<p>具体复杂度看桶的大小而定，设桶的大小为B,则复杂度为O（(n/B)logB + B）;</p>

<p>总体算法的复杂度为O(nlogn + mlogn*((n/B)logB + B)));</p>

<p>第二种方法，线段树，或者说，归并树。这次的线段树不是动态的，而是静态的，直接说说方法吧！</p>

<p>线段树存储一个域，这个域存的是对应区间排好序的数组（是数组），要计算再某个区间中不超过x的数的个数，只需要递归的进行下面的操作就行：</p>

<p>如果所给区间与当前节点区间没交集，返回0；</p>

<p>如果所给区间完全包含当前节点对应的区间，那么就使用二分法对该点上保存的数组进行查找；</p>

<p>否则对两个儿子递归的进行计算求得结果；</p>

<p>时间复杂度是O(nlogn + mlog3n).</p>

<p>两种方法的参考代码都在<a href="/acm/poj/poj2104/">这里</a></p>

<p>这里提一下，再第二种方法里面用到的一个STL函数，merge.</p>

<p>merge(a, a+n, b, b+n, c) 进行的操作是把数组a和数组b的前n项合并，存在数组c中！</p>

<p>还有，《统计的力量》中也有提到这个，不过我没太看懂怎么去敲！</p>

<p>好了，这次就到这里吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[折半枚举]]></title>
    <link href="http://whn757397540.github.io/blog/2015/03/14/zhe-ban-mei-ju/"/>
    <updated>2015-03-14T18:56:56+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/03/14/zhe-ban-mei-ju</id>
    <content type="html"><![CDATA[<p>这个，也是一种优化技巧，其思想来源于传统的双向搜索！</p>

<p>要点: 把要枚举的多个东西分成2部分分开来进行枚举，从而达到降低时间复杂度的目的，实际上是一种牺牲空间换取时间的方法，分成两部分来枚举的时候，就是先枚举一部分存起来，再根据存起来的这部分对剩下的一部分进行枚举。光说也看不出效果来，来看一道题。</p>

<!--more-->


<p><a href="http://poj.org/problem?id=2785">POJ 2785 4 Values whose Sum is 0</a></p>

<p>就是给你4个序列，让你从每个序列中选一个数使得4个数和为0，问总共有几种方法（统一序列数值相同的数字区别看待）？</p>

<p>这个如果按照正常的方法直接枚举的话，复杂度是O(n<sup>4</sup>)，但是如果我们先来枚举一半，看a+b+c+d = 0,则 c+d = -(a+b)，我们可以先枚举c和d的选取方法，总共是n<sup>2</sup>种，复杂的自然就是n2，然后再把这几个数字存起来进行排序，之后再枚举a+b,利用a+b是c+d的相反数这个性质，利用二分搜索，可以再每次用logn的时间找出对应的c+d，而枚举a+b复杂度是n<sup>2</sup>，综上，复杂度为O(n<sup>2</sup> logn).</p>

<p>参考代码理解一下就好。</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;
const int INF = 0x3f3f3f3f;
const int maxn = 4010;

int a[maxn],b[maxn],c[maxn],d[maxn];
int cd[maxn*maxn];

int main()
{
    int n;
    scanf("%d", &amp;n);
    for (int i = 0; i &lt; n; i++)
        scanf("%d%d%d%d", &amp;a[i], &amp;b[i], &amp;c[i], &amp;d[i]);
    for (int i = 0; i &lt; n; i++)
        for (int j = 0; j &lt; n; j++)
            cd[i*n+j] = c[i]+d[j];
    sort(cd, cd+n*n);
    long long ans = 0;
    for (int i = 0; i &lt; n; i++)
        for (int j = 0; j &lt; n; j++)
        {
            int ab = a[i] + b[j];
            ans += upper_bound(cd, cd+n*n, -ab) - lower_bound(cd, cd+n*n, -ab);
           /* if (ans != 0)
                cout&lt;&lt;a[i]&lt;&lt;" "&lt;&lt;b[i]&lt;&lt;" "&lt;&lt;ans&lt;&lt;endl;
            system("pause");*/
        }
    printf("%I64d\n", ans);
    return 0;
}
</code></pre>

<p>另外一个例子就是超大背包问题，就是背包问题，不过限制条件不适合用dp：1&lt;=n&lt;=40, 1&lt;= w[i],v[i] &lt;= 10<sup>15</sup>, 1&lt;W&lt;10<sup>15</sup>;</p>

<p>n比较小，就考虑能不能枚举，但是直接枚举复杂度是2n, 240铁定是不行的，所以，需要再优化。这时，就可以利用折半枚举，把所有的物品拆成2部分，先选一半，再选一半。实际上就是先枚举一半（2<sup>20</sup>），假设枚举的这一半是w2,v2。存起来后，我们可以排除掉所有的w2[i]&lt;=w2[j] &amp;&amp; v2[i] >= v2[j]的j,按照w,v的字典序排序后很容易做到这一点。之后声誉的元素都满足w2[i]&lt;w2[j]等价与v2[i]&lt;v2[j]，我们要计算的是max{v2| w2&lt;= W-w1},就只需要找到满足w2[i]&lt;= W-w1[i]的最大的i就行，这个可以用二分搜索完成。复杂度是O（2<sup>n</sup>/2 * n）,是可以在时限内完成的！</p>

<p>总结：对于枚举情况很多的时候，并且跟顺序有关的时候，可以折半，先枚举一半存起来，然后用二分查找的方法降低复杂度！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开关问题]]></title>
    <link href="http://whn757397540.github.io/blog/2015/03/14/kai-guan-wen-ti/"/>
    <updated>2015-03-14T18:56:21+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/03/14/kai-guan-wen-ti</id>
    <content type="html"><![CDATA[<p>反转问题，开关问题，关灯问题！这是一个什么样的问题呢？说实话，我也不清楚，那就不清楚地说一说呗！先来看两个题，再根据这两个题再来分析下这是一个什么样的问题！</p>

<!--more-->


<p><a href="http://poj.org/problem?id=3276">POJ3276 Face The Right Way</a></p>

<p>简单说下题意，给你n头牛的朝向(B向后F向前)，给你一台机器，机器的作用是，你先要指定一个k，然后机器每次操作反转严格的k头牛的方向（B变F，F变B）。问让所有的牛朝前最少需要反转几次，对应的K是多少（如果次数相同，输出最小的K）。</p>

<p>首先，区间的反转顺序对于结果是没有影响的；其次，如果对同一个区间反转2次以上是多余的；有以上两点，问题就转变成了求需要被反转的空间的集合。</p>

<p>那么我们就考虑最前面一头牛，如果这头牛需要反转，那么包含这头牛的区间只有1个，所以这个区间就必须要反转；在把这头牛反转之后，在剩下的牛里面再选取最前面的一头，依然是一样的。所以我们就可以通过首先考虑最左端的牛，然后不断重复最终求出结果了！</p>

<p>以上便是这种方法的精髓。可是如果我们直接按照这种方法来模拟的话，我们来分析下复杂度，首先，需要对所有可能的K都求解一次（N）,然后，对于每个K，我们都要从最左端考虑N头牛的情况，最坏的情况下又需要进行N-K+1次反转操作，每次操作需要反转K头牛，所以总的复杂度是O（N3）,这个显然，对于5000的问题规模，现在是不能在规定的时间内解决的！所以，我们需要优化。（这个不属于这种方法的内容）</p>

<p>这个，我们可以设一个f[i]代表区间[i,i+K-1]是否进行过反转，反转过就为1，否则为0.那么对于某头牛，我们只需要考虑在它之前的包括它的区间反转次数的和，而我们求的时候是按照顺序来的，所以这个和也可以用O（1）的时间求出来。举个例子，再这个和sum从i-1向i转移的过程中，很显然需要sum-f[i-k]（因为f[i-k]不包括牛i），根据这个sum求出f[i]来，再把f[i]加入到sum中就好，具体看看<a href="/acm/poj/poj3276/">代码</a>应该也挺容易懂的.</p>

<p><a href="http://poj.org/problem?id=3279">POJ3279 Fliptile</a></p>

<p>这个题意也好理解，给你一个m×n的格子，每个格子可能是黑色（1）或者白色（0）,然后你可以进行的操作是可以选择一个格子进行反转，那个格子反转会带动周围的4个格子（上下左右）也反转，问题是最少进行多少步能够把所有的格子反转成白色，如果没有可能，输出IMPOSSIBLE,否则输出字典序最小的反转方案。</p>

<p>跟上一题一样的分析方法，首先，对同一个格子进行2次以上的反转是多余的；其次，反转的格子的顺序对结果是没有影响的！那么接下来，我们需要考虑找到一个可以确定反转方法的最靠前位置的格子（就像上一题最前面的那头牛一样）。但是，假如当前只考虑这些格子的左上角一个格子[i,j]的话，当前还没有确定反转方向的格子中，除了[i,j]之外，实际上还有[i+1,j],[i,j+1]两个个格子可能对他产生影响，所以我们不能非常容易地确定某个格子是不是必须要反转，所以我们要想办法把不确定因素减少。考虑下，假如我们把最上面一行的反转情况固定了，那么，能够影响到最左上角[i,j]的就只有[i+1,j]这一个位置（[i,j],[i,j+1]都被固定了），那么我们就可以根据[i,j]的状态判断[i+1,j]是不是需要反转了（因为这时能影响到[i,j]的只剩下[i+1,j]了）；事实上，我们只需要固定第一行的反转情况就好，因为如果第i行的反转情况固定了，那么根据[i,j]能确定[i+1,j]的反转情况，在跑完一行之后，第i+1行的也就固定了，以此类推就行了！至于怎么固定最上面一行？枚举就好了嘛，怎么枚举呢？记得状态压缩吗？n的范围只有15，所以，你知道了？</p>

<p>我的代码</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;
const int INF = 0x3f3f3f3f;
const int maxn = 11111;
const int d[5][2] = { {0, -1}, {1, 0}, {0, 1},{-1, 0},{0, 0} };
int n,m;
int a[20][20];
int ans[20][20];
int tmp[20][20];

int get(int x, int y)
{
    int res = a[x][y];
    for (int i = 0; i &lt; 5; i++)
    {
        int xx = x+d[i][0], yy = y + d[i][1];
        if (xx &lt; m &amp;&amp; xx &gt;= 0 &amp;&amp; yy &lt; n &amp;&amp; yy &gt;= 0)
            res ^= tmp[xx][yy];
    }
    return res;
}

int solve()
{
    int res = 0;
    for (int i = 1; i &lt; m; i++)
        for (int j = 0; j &lt; n; j++)
            if (get(i-1,j))//i-1,j位置的砖头是黑色的，i,j位置的就必须要翻转
            {
                tmp[i][j] = 1;
                res++;
            }

    for (int j = 0; j &lt; n; j++)
        if (get(m-1,j))//都翻转完之后最后一行不是全白的话，就说明无解
            return INF;
    for (int i = 0; i &lt; n; i++)
        res += tmp[0][i];
    return res;
}

int main()
{
    scanf("%d%d", &amp;m, &amp;n);
    for (int i = 0; i &lt; m; i++)
        for (int j = 0; j &lt; n; j++)
            scanf("%d", &amp;a[i][j]);
    int num = INF;
    for (int i = 0; i &lt; (1&lt;&lt;n); i++)
    {
        memset(tmp, 0, sizeof(tmp));
        for (int j = 0; j &lt; n; j++)
            tmp[0][n-j-1] = (i&gt;&gt;j) &amp; 1;//要保证字典序最小
        int tp = solve();
        if (num &gt; tp)
        {
            num = tp;
            for (int k = 0; k &lt; m; k++)
                for (int t = 0; t &lt; n; t++)
                    ans[k][t] = tmp[k][t];
        }
    }
    if (num &lt; INF)
        for (int i = 0; i &lt; m; i++)
            for (int j = 0; j &lt; n; j++)
                printf("%d%c", ans[i][j], j==n-1?'\n':' ');
    else
        puts("IMPOSSIBLE");
        //system("pause");
    return 0;
}
</code></pre>

<p>下面总结一下这种思想可能会在什么样的情况下用到，只是我自己对比这两道题的解法总结的，如果发现不全的话欢迎补充，发现不对的话欢迎指正：</p>

<p>首先，需要确定两点，第一是顺序无关性，第二是状态有限且有序性（这两道题都是2种状态，而根据我的理解，感觉如果不止是2种状态但是状态的变换是有序的话，也能借鉴这种思想，只不过会很麻烦，可能有其他的方法）；第三就是你每次操作是把一个位置从一个状态转换成下一个状态；第四是对每个位置可以选择操作和不操作。</p>

<p>在满足这以上条件的情况下，可以考虑下能不能用这种方法来解决，这时候我们需要考虑找到一个可以根据之前的操作状态确定来确定当前位置是不是操作的位置（比如第一道题里面的最前面一头牛就可以根据它之前的牛的操作情况来确定自己是不是要操作，而且是确定的，操作就是一定要操作，不操作就一定不操作，第二题里面也是一样，在确定首行之后，[i+1， j]这个位置的操作就能为唯一确定，必须是唯一确定！！），能找到这么一个位置的话，还要确定，对这个位置进行了对应的操作之后，依然能找到下一个这样的位置，这样就可以依次递推到最后了！</p>

<p>不知道我说的是不是清楚,最后再说一句,记得14年多校有一题,貌似跟这种思想挺像的,忘了有没有做出来了!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[连通度总结]]></title>
    <link href="http://whn757397540.github.io/blog/2015/03/14/lian-tong-du-zong-jie/"/>
    <updated>2015-03-14T18:56:00+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/03/14/lian-tong-du-zong-jie</id>
    <content type="html"><![CDATA[<p>做<a href="http://poj.org/problem?id=1966">POJ 1966 Cable TV Network</a>时遇到的问题，用到了一些网络流的知识</p>

<p>这个其实首先是一个概念问题，要想明白什么事图的连通度，我们需要先搞明白什么叫做连通图！</p>

<!--more-->


<p>在图论中，连通图基于连通的概念。在一个无向图 G 中，若从顶点vi到顶点vj有路径相连（当然从vj到vi也一定有路径），则称vi和vj是连通的。如果 G 是有向图，那么连接vi和vj的路径中所有的边都必须同向。如果图中任意两点都是连通的，那么图被称作连通图。如果此图是有向图，则称为强连通图（注意：需要双向都有路径）</p>

<p>严格的定义是这样的：</p>

<p>对一个图 G=(V,E) 中的两点 x 和 y ，若存在交替的顶点和边的序列 Γ=(x=v0-e1-v1-e2-…-ek-(vk+1)=y) (在有向图中要求有向边vi−( vi+1)属于E )，则两点 x 和 y 是连通的。Γ是一条x到y的连通路径，x和y分别是起点和终点。当 x = y 时，Γ 被称为回路。如果通路 Γ 中的边两两不同，则 Γ 是一条简单通路，否则为一条复杂通路。如果图 G 中每两点间皆连通，则 G 是连通图。</p>

<p>(PS:以上内容摘自百度百科)</p>

<p>那么，搞清楚连通图是什么以后，我们就能够知道什么是连通度了。首先，连通度分为边连通度和点联通度，对于这两个概念，是如下定义的：</p>

<p>设G = (V, E)是一个n阶图。如果G是完全图Kn，那么我们定义它的顶点连通度为  κ(Kn) = n – 1  否则，定义它的顶点连通度为  κ(G) = min{|U| : Gv-u是非连通的}  即最小的定点数，删除这些定点后能让这个图不连通（这里没提有向图应该是怎么样的一种不连通，不过根据我的理解，应该是指的不是强联通，也就是任意两点不连通就算是不连通了）</p>

<p>图G的边连通度定义为从图G中删除边而使G非连通的最小边数，用λ(G)表示。  这里的图G=(V, E)代表无向图或有向图，且没有自环和重边。</p>

<p>那么对于边连通度和点连通度，应该怎么求呢？</p>

<p>有向图的边连通度：如果是对于2个点来说的边连通度，那么其实就是这两点之间的最小割！根据最大流最小割定理，很容易用最大流求出来（建图边容量为1就行）。但是如果是对于整个图的边连通度，其实就是要对任意一对点的最小割里面的最小值了，而事实上，我们不需要遍历每一对点，只需要固定源点然后枚举汇点，再固定汇点枚举源点就行了（这个的证明就不说的，因为只要理解了最小割的概念，很容易就能想明白！）</p>

<p>有向图的点连通度：这个相对麻烦一点点，不过其实也就是边容量无限了（因为求点连通度不需要断边），然后点有了容量为1，而之前在网络流的总结里提到了遇到点也有容量的时候该怎么解决，很简单，就是直接拆点，把一个点p拆成两个点v和v’，然后由v指向v’一条容量为1的边，然后所有指向原来的点p的边指向v，所有从原来的点p指出的边变成从v’指出即可！之后的算法跟求边连通度一样</p>

<p>无向图的边连通度：在网络流中也说过，怎么把无向图转化成有向图，这里不再赘述！</p>

<p>无向图的点连通度：一样，把无向图转换成有向图，然后按照有向图点连通度的建图方法来建图就好！</p>

<p>下面来说题：</p>

<p><a href="http://poj.org/problem?id=1966">POJ 1966 Cable TV Network</a></p>

<p>这道题，就是直接的一道让你求点连通度的裸题，很简单，按照之前说的方法建图来求就行！</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 11111;
const int INF = 0x3f3f3f3f;
struct Edge{
    int to, cap, rev;
    Edge(int to, int cap, int rev):to(to), cap(cap), rev(rev){}
};

int u[maxv],v[maxv];
vector&lt;Edge&gt; G[maxv];
int level[maxv];//¶¥µãµ½Ô´µãµÄ¾àÀë±êºÅ
int iter[maxv];//µ±Ç°»¡£¬ÔÚÆäÖ®Ç°µÄ±ßÒÑ¾­Ã»ÓÐÓÃÁË

void init(int n)
{
    for (int i = 0; i &lt; n; i++)
        G[i].clear();
}
void addEdge(int from, int to, int cap)
{
    G[from].push_back(Edge(to, cap, G[to].size()));
    G[to].push_back(Edge(from, 0, G[from].size()-1));
}

void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for (int i = 0; i &lt; G[v].size(); i++)
        {
            Edge &amp;e = G[v][i];
            if (e.cap&gt;0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

int dfs(int v, int t, int f)
{
    if(v == t)
        return f;
    for (int &amp;i = iter[v]; i &lt; G[v].size(); i++)
    {
        Edge &amp;e = G[v][i];
        if (e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if (d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

int max_flow(int s, int t)
{
    int flow = 0;
    while(true)
    {
        bfs(s);
        if (level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while ((f = dfs(s, t, INF)) &gt; 0)
            flow += f;
    }
}

void reset(int n, int m)
{
    init(2*n);
    for (int i = 0; i &lt; n; i++)
        addEdge(i, i+n, 1);
    for(int i = 0; i &lt; m; i++)
    {
        addEdge(u[i]+n, v[i], INF);
        addEdge(v[i]+n, u[i], INF);
    }

}
int main()
{
    int n,m;
    while(~scanf("%d%d", &amp;n, &amp;m))
    {
        for (int i = 0; i &lt; n; i++)
            addEdge(i, i+n, 1);
        for (int i = 0; i &lt; m; i++)
            scanf(" (%d,%d)", &amp;u[i], &amp;v[i]);
        //int s = n, ans = INF;
        int ans = INF;
        int s = n;
        int t;
        for (t = 1; t &lt; n; t++)
        {
            reset(n,m);
            ans = min(ans, max_flow(s,t));
        }
        t = 0;
        for (s = n+1; s &lt; 2*n; s++)
        {
            reset(n,m);
            ans = min(ans, max_flow(s,t));
        }
        printf("%d\n", ans &lt; INF ? ans : n);
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二分查找及其应用总结]]></title>
    <link href="http://whn757397540.github.io/blog/2015/03/14/er-fen-cha-zhao-ji-qi-ying-yong-zong-jie/"/>
    <updated>2015-03-14T18:55:45+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/03/14/er-fen-cha-zhao-ji-qi-ying-yong-zong-jie</id>
    <content type="html"><![CDATA[<p>二分查找及其应用总结
二分搜索法，是通过不断缩小解可能存在的范围，从而求的问题最优解的方法。经常会出现的是二分搜索和其他算法结合的题目。</p>

<!--more-->


<p>(PS:有关二分姿势的选取，可以看看<a href="http://blog.csdn.net/u012139398/article/details/38637311">峰霸这短小精悍的博文</a></p>

<ol>
<li>首先，最基本的，从有序数组中查找某个值。</li>
</ol>


<p>这个问题，再stl中有lower_bound()和upper_bound()来解决，这里给出一个内部算法结构，再简单说说STL的用法</p>

<pre><code class="c++">int lowerBound(int a[], int n, int aim)//返回值是&gt;=aim的第一个位置，如果不存在，返回最后一个元素之后的一个位置（也就是n）
{
    int l = -1, r = n;//初始化解的存在范围，这里求lower_bound的时候采取的是左闭右开的

    while(r-l &gt; 1)//重复循环，一知道解的范围足够小
    {
        int mid = (l+r)/2;
        if (a[mid] &gt;= aim)//如果mid满足条件
            r = mid;//解的存在范围变为(l, mid]
        else
            l = mid;//解的存在范围变为(mid, r]
    }
    return r;
}
</code></pre>

<p>当然，这只是针对整数的情况，而根据实际情况，还会有可能是其他的元素，或者其他的要求，要视情况而定。不再多说，提一下STL库里的两个函数的用法:</p>

<p>首先，lower_bound(a, a+n, d)返回的是数组a里面（a可以是任何有序的数组）,元素值>=d的第一个元素的位置，如果不存在，则返回的是最后一个元素之后的第一个位置，注意，他的返回值是指针！</p>

<p>然后，upper_bound(a, a+n, d)，与lower_bound（）类似，不过这里找的是>d的第一个元素的位置，不包括等于，不存在的情况与lowerbound相同，返回值也是指针</p>

<ol>
<li>假定一个解并判断是否可行（二分答案法）</li>
</ol>


<p>这种解题方法并不是第一次用了，什么情况下用这种方法呢？如果在求解最大化或最小化的问题中，能够比较简单的判断条件是否满足，那么使用二分搜索法就可以很好得解决问题。</p>

<p>举个简单的例子：</p>

<p><a href="http://poj.org/problem?id=1064">POJ 1064 Cable master</a></p>

<p>我们如果假定答案是x的话，那么每条绳子最多可以切成floor(L[i] / x)段，那么我们只需要判断所有的绳子最多可以切成多少段，如果能切得比K段更多（或者相等），那么就能知道有可能切得更长，这个判断就对应了之前代码的a[mid] >= aim的条件了；同样，反之就说明切得太长了，需要往短了切。所以呢，参考下之前的代码，很容易能写出这一题的代码！我的<a href="/acm/poj/poj1064/">代码</a>仅供参考。</p>

<p>这种类型的题目还很多，记住两个要点：最大化或者最小化问题中;能够比较简单地判断条件是否满足；在满足以上两个条件的情况下，二分搜索法是一个很好的办法，复杂度是O（判断的复杂度×log(maxans)）.</p>

<ol>
<li>最大化最小值问题</li>
</ol>


<p>类似最大化最小值或者最小化最大值的问题，通常用二分搜索法就可以很好的解决（实际上，跟2的二分答案法是差不多的）。不多说，挂个例题和解法就过了。</p>

<p><a href="http://poj.org/problem?id=2456">POJ 2456 Aggressive cows</a></p>

<p>定义一个canMake(int d)函数,代表可以安排牛的位置使离得最近的互相仇恨的牛的距离不小于d。这个问题只用贪心法就很容易判断了（具体过程不说了）。之后进行二分答案就好！</p>

<p>参考<a href="/acm/poj/poj2456/">代码</a></p>

<ol>
<li>最大化平均值</li>
</ol>


<p>这种题呢，说实话，还没有太多印象遇到过，不过既然书上提到了，这里就来讲一讲罗！先来看问题：</p>

<p>有n个物品的重量和价值分别为wi和vi，要从中选出k个物品是的单位重量的价值最大。</p>

<p>这个问题，我刚开始看到的想法就是直接贪心按照单价排序不就好了嘛，可是后来发现这种贪心是错误的（给的样例就能证明）。那么我们可以这样来假设，定义:</p>

<p>C(x) = 可以选择使得单位重量的价值不小于x。</p>

<p>那么原问题就等于是求满足C(x)的最大的x。那么解决了判断问题，就又可以二分答案了。关键我们是怎么判断C(x)呢？假设我们选了某个物品的集合S那么它们的单位重量的价值就是 sigma(vi)/sigma(wi)。</p>

<p>因此就变成了判断是否存在S满足下面的条件</p>

<p>sigma(vi)/sigma(wi) >= x;</p>

<p>把这个不等式变形就得到</p>

<p>sigma(vi - x*wi) >= 0.</p>

<p>因此，我们只需要对vi-x*wi的值进行排序贪心的选取，判断从大到小前k个的和不小于0就行了。每次判断的复杂度是O（nlogn）.</p>

<p>通过上面的内容，我们会发现，不管怎么样，用到二分答案的时候，我们需要先找到一个判断条件，然后对答案进行二分。二分，更重要的是这种思想，它不仅仅是能够搜索数值，还能有更广阔的应用！</p>

<p><a href="/blog/archives">&lt;–返回</a></p>
]]></content>
  </entry>
  
</feed>
