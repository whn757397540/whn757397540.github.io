<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 最小生成树 | hnnwang's Blog]]></title>
  <link href="http://whn757397540.github.io/tags/zui-xiao-sheng-cheng-shu/atom.xml" rel="self"/>
  <link href="http://whn757397540.github.io/"/>
  <updated>2015-08-10T18:00:30+08:00</updated>
  <id>http://whn757397540.github.io/</id>
  <author>
    <name><![CDATA[hnnwang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[图论总结(一)]]></title>
    <link href="http://whn757397540.github.io/blog/2015/03/14/tu-lun-zong-jie-%5B%3F%5D/"/>
    <updated>2015-03-14T18:54:04+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/03/14/tu-lun-zong-jie-[?]</id>
    <content type="html"><![CDATA[<p>今天搞了一天的图论，重新熟悉了下Dijkstra，SPFA，PRIM和Kruskal算法，这里总结一下！</p>

<!--more-->


<p>先来几道例题（大部分是《挑战程序设计竞赛》中的例题）</p>

<ol>
<li><a href="http://poj.org/problem?id=3255">POJ3255 Roadblocks</a></li>
</ol>


<p>这是一个次短路的题目，题意就是给你R条道路，总共有N个路口，问你从1号路口到N号路口的次短路（如果存在多个最短路，次短路就是比最短路长比其他所有路径都要短的路的长度）。求次短路有几种方法，这里我用的是《挑战程序设计竞赛》中提到的Dijkstra的方法，（至于求K短路的方法，这个等下一次总结再说！）</p>

<p>这个主要是要理解了Dijkstra的思想，我们想一下，从顶点1到某个顶点v的次短路要么是到顶点u的最短路加上u到v的边，要么是到顶点u的次短路加上顶点u到顶点v的边。所以更新的时候要用到到某个顶点u的最短路d[u]和到某个定点u的次短路dd[u],更新的规则如下：①先看d[u]能不能更新，需要更新则更新，同时也要更新次短路；②再看次短路能不能更新，需要更新则更新。（对于上面的两步操作，《挑战程序设计竞赛》上用了一种很巧妙的方法，具体请看代码）。这里说一下，用优先队列优化Dijkstra算法，在这个里面，要根据实际情况选择是用最短路入队还是用次短路入队，具体参考代码！代码如下：</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include&lt;vector&gt;

using namespace std;
const int maxv = 5500;
const int maxe = 200100;
const int INF = 0x3fffffff;
struct Edge
{
    int from, to, cost, next;
    Edge() {}
    Edge(int from, int to, int cost, int next):from(from),to(to),cost(cost),next(next) {}
};
int head[maxv];
Edge E[maxe];
int nume;

void init()
{
    memset(head, -1, sizeof(head));
    nume = 0;
}

void addEdge(int u, int v, int cost)
{
    E[nume] = Edge(u,v,cost,head[u]);
    head[u] = nume++;
}

int d[maxv],dd[maxv];
priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; que;

void dijkstra(int s, int e)
{
    fill(d, d+e+1, INF);
    fill(dd, dd+e+1, INF);
    d[s] = 0;
    que.push(make_pair(0,s));

    while (!que.empty())
    {
        pair&lt;int,int&gt; p = que.top();
        que.pop();
        int v = p.second;
        if (dd[v] &lt; p.first) continue;
        for (int i = head[v]; i != -1; i = E[i].next)
        {
            int from = E[i].from, to = E[i].to, dis = E[i].cost;
            int tmp = p.first + dis;
            if (d[to] &gt; tmp)
            {
                swap(d[to], tmp);
                que.push(make_pair(d[to], to));
            }
            if ( dd[to] &gt; tmp &amp;&amp; d[to] &lt; tmp)
            {
                dd[to] = tmp;
                que.push(make_pair(dd[to], to));
            }
        }
    }
}

int main()
{
    //freopen("in.txt", "r", stdin);
    int n,m;
    while(scanf("%d%d", &amp;n, &amp;m)!=EOF)
    {
        init();
        for (int i = 0; i &lt; m; i++)
        {
            int x,y,v;
            scanf("%d%d%d", &amp;x, &amp;y, &amp;v);
            addEdge(x,y,v);
            addEdge(y,x,v);
        }
        dijkstra(1,n);
        printf("%d\n", dd[n]);
    }

}
</code></pre>

<ol>
<li><a href="http://poj.org/problem?id=3169">POJ 3169 Layout</a></li>
</ol>


<p>这道题就需要思考怎么建图了，不看书我预计是不能够相处这么一种建图的方法的，因为做的少还不会。算是学习一下吧！</p>

<p>题意是给你N头牛，按照从近到远的顺序排列，牛与牛的距离可以是0，然后牛与牛的关系不同，有些牛之间的关系比较好，它们希望彼此之间的间距不要超过一定的距离；有些牛之间的关系比较差，它们希望彼此之间的间距不能小于一定的距离。先给出牛的个数N（编号从1到N，有序），给出你ML组关系好的牛的信息（AL,BL,DL）（AL&lt;=BL）表示牛AL和牛BL之间的距离不能大于DL，给出你MD组关系差的牛的信息（AD,BD,DD)（AD &lt;= BD）表示牛AD和牛BD之间的距离不能小于DD。问你在满足所有这些约束关系的情况中，1号牛和N号牛之间的最大距离。</p>

<p>这里我就借助书上说的思路来讲解一下了，也算是总结了。首先，设第i号牛的距离为的di,我们可以根据约束条件得出下面几个式子:①牛的编号是有序的，而且牛与牛之间的距离可以是0，那么有d[i]&lt;=d[i+1];②对于每对关系好的牛(AL&lt; BL)之间有最大距离限制DL，所以必须满足 d[BL] - d[AL] &lt;= DL;③，对于每对关系比较差的牛（AD &lt; BD）之间有最小距离限制DD，所以必须满足 DD &lt;= d[BD] - d[AD]. 综合上面三组式子，其实可以列一个线性规划，但是显然，这个用计算机来实现很麻烦，现在问题的关键来了，怎么把它跟图联系起来呢？就现在的我来说，我是想不到该怎么办的！不过看了书之后，感觉书上的做法确实很敲秒，事实上，图论的题目难就难在建图，这里才是思考的关键，得慢慢练，下面说建图的方法：</p>

<p>我们来想一下，对于最短路d[u]和d[v]两个顶点，我们总有d[u] + w[u][v] >= d[v]成立（否则d[v]就不是最短路了），那么如果u = 1, v = n，我们就有d[1] + w[1][n] >= d[n]成立，即d[n] &lt;= w[1][n],从这里我们可以看出，d[n]的最大值就是w[1][n]，也就是从1到n的最短距离。</p>

<p>对比一下上面的分析，不难看出其实式子的模样很像，看，对于①，我们可以写成d[i+1] + 0 >= d[i]， 所以我们需要建一个从i+1指向i的长度为0的边；对于②， 我们可以写成d[AL]+DL >= d[BL]，我们应该建一个从AL指向BL的长度为DL的边；对于③，我们可以写成d[BD] - DD >= d[AD],所以我们应该建一个从BD指向AD的长度为-DD的边。从第对牛的关系的分析可知，这里d[u]代表牛u和牛1的距离，所以我们需要求的是d[n]的最大值，而通过对最短路的分析我们可知，d[n]的最大值也就是从1到n的最短距离。（看起来是不是好怪的样子qq_pp），所以我们建好图之后只需要求出最短路d[n]就行！</p>

<p>由于存在负边，所以我们这里用的是SPFA算法（Dijkstra算法不能处理负边的情况），我的代码如下：</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include&lt;vector&gt;

using namespace std;
const int maxv = 1010;
const int maxe = 20200;
const int INF = 0x3fffffff;
struct Edge{
    int from,to,cost,next;
    Edge(){};
    Edge(int from, int to, int cost, int next) : from(from), to(to), cost(cost), next(next){}
}E[maxe];
int head[maxv];
queue&lt;int&gt; que;
int nume;

void init()
{
    nume = 0;
    memset(head, -1, sizeof(head));
}

void addEdge(int u, int to, int cost)
{
    E[nume] = Edge(u,to,cost,head[u]);
    head[u] = nume++;
}

int d[maxv];
int cnt[maxv];
bool inq[maxv];
bool SPFA(int s, int e)
{
    fill(d, d+e+1, INF);
    memset(inq, 0, sizeof(inq));
    memset(cnt, 0, sizeof(cnt));
    //cout&lt;&lt;1&lt;&lt;endl;
    d[s] = 0;
    inq[s] = true;
    que.push(s);
    while(!que.empty())
    {
        int u = que.front();
        que.pop();
        inq[u] = false;
        for (int i = head[u]; i != -1; i = E[i].next)
        {
            int to = E[i].to, w = E[i].cost;
            if (d[u] &lt; INF &amp;&amp; d[to] &gt; d[u] + E[i].cost)
            {
                d[to] = d[u] + E[i].cost;
                if (!inq[to])
                {
                    que.push(to);
                    inq[to] = true;
                    if (++cnt[to] &gt; e)
                            return false;
                }
            }
           // cout&lt;&lt;
        }
       // cout&lt;&lt;u&lt;&lt;endl;
    }
    return true;
}

int main()
{
     int n, ml, md;
     while(scanf("%d%d%d", &amp;n, &amp;ml, &amp;md) == 3)
     {
         init();
         for (int i = 1; i &lt; n; i++)
            addEdge(i+1, i, 0);
         for (int i = 0; i &lt; ml; i++)
         {
             int a,b,dis;
             scanf("%d%d%d", &amp;a, &amp;b, &amp;dis);
             addEdge(a, b, dis);
         }
         for (int i = 0; i &lt; md; i++)
         {
             int a,b,dis;
             scanf("%d%d%d", &amp;a, &amp;b, &amp;dis);
             addEdge(b, a, -dis);
         }
       //  cout&lt;&lt;1&lt;&lt;endl;
         if (SPFA(1, n))
         {
             if (d[n] &lt; INF)
                printf("%d\n", d[n]);
             else
                printf("%d\n", -2);
         }
         else
            printf("%d\n", -1);

     }
}
</code></pre>

<p>以上是Dijkstra算法和SPFA算法的两个例子，这里总结一下二者的区别，首先，从思想上来说，Dijkstra算法是 从一点开始依次更新每一点，每次取距离初始点最近的一个点对接下来的点进行更新；而SPFA是对每一个节点进行多次松弛操作，直到所有的节点都是最短路为止！从实现上来看，Dijkstra的算法代码跟SPFA是非常像的，在我看来，不同点就在于：第一，DJ用的是优先队列，而SPFA用的是普通FIFO队列；第二，DJ每个元素只入队一次，而SPFA可以入队多次（据说一般不超过2次）（好了，我承认，这是在刘汝佳紫书上看的，不过很对不是？）。然后，一般情况下，DJ是比较稳定的，是SPFA的时间复杂度不够稳定，所以，如果不是特殊需要（比如有负边或者负环啦），最好还是用时间比较稳定的DJ。（PS:外国不承认SPFA，只认Bellman-ford，而SPFA就是在Bellman-ford的基础上加了个队列优化。）</p>

<p>最后对于最短路，再说一下路径还原的事情，以DJ为例，我们要还原出最短路来，只需要在更新最短路的过程中加上一个队父亲节点的更新（记录最短路上to节点的父亲节点是最短路上的from节点），最后从目标节点回溯回去即可。正好前些天CF的E题就用到了最短路的还原，实在是敲累了，思想说了，直接挂代码了（这里的代码是我最开始根据最短路DJ的思想敲的，没有板子，姿势可能有点丑，不过也懒得改了）</p>

<p><a href="http://codeforces.com/contest/507/problem/E">CF 507E</a></p>

<p>题意简单说以下，就是给你一个图，这个图中每条路的路径长度都是1，每条路有通(1)和不通(0)两种状态。你要从1号点到n号点，而且你所走的路径上的所有路都要修好（就是如果有0要变成1），其他的所有路都要拆断（就是所有不属于你走的路径上的路如果有1都要变成0），要求走最短路（距离最短），如果有多个最短路，走需要作出的改变最少的那一种路（如果还是有多种，任何一种都行）。要求输出最少的改变数和每个改变的信息！代码如下：</p>

<pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;

using namespace std;
const int maxv = 200100;
const int maxe = 200100;
struct Edge{
    int from, to, state, next;
    Edge(){}
    Edge(int from, int to, int state, int next):from(from),to(to),state(state),next(next){}
};
int head[maxv];
Edge E[maxe];
int v,cntedge;

void init()
{
    memset(head, -1, sizeof(head));
    cntedge = 0;
}

void addEdge(int u, int v, int state)
{
    E[cntedge] = Edge(u,v,state,head[u]);
    head[u] = cntedge++;
}

int d[maxv],father[maxv],dd[maxv];
priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; que;

void dijkstra(int s, int e)
{
   fill(d, d+e+1, maxv+1);
   fill(dd, dd+e+1, 0);
   fill(father, father+e, -1);
   d[s] = 0;
   pair&lt;int, int&gt; now = make_pair(0, s);
   while (now.second != e)
   {
        for (int v = head[now.second]; v != -1; v = E[v].next)
        {
            int from = E[v].from, to = E[v].to;
            if (d[to] &gt; d[from] + 1 || d[to] == d[from] + 1 &amp;&amp; dd[to] &lt; dd[from] + E[v].state)
            {
                dd[to] = dd[from] + E[v].state;
                d[to] = d[from] + 1;
                father[to] = v;
                que.push(make_pair(d[to], to));
            }
          //  cout&lt;&lt;to&lt;&lt;d[to]&lt;&lt;endl;
           // cout&lt;&lt;v&lt;&lt;" "&lt;&lt;to&lt;&lt;endl;
        }
      //  cout&lt;&lt;now.second&lt;&lt;endl;
        now = que.top();
        // cout&lt;&lt;now.second&lt;&lt;endl;
        que.pop();
        //system("pause");
   }
}
bool judge[maxe];
typedef pair&lt;int, int&gt; P;
typedef pair&lt;P, int&gt; PP;
vector&lt;PP&gt; ans;
void getAns(int aim)
{
    memset(judge, 0, sizeof(judge));
    ans.clear();
    int tp = aim;
    while (father[tp] != -1)
    {
        int e1 = father[tp];
        tp = E[e1].from;
        judge[e1] = true;
        judge[e1^1] = true;
    }
    for (int i = 0; i &lt; cntedge; i++)
    {
        if (judge[i])
        {
            if (E[i].state == 0 &amp;&amp; !(i&amp;1))
                ans.push_back(make_pair(make_pair(E[i].from, E[i].to), 1));
        }
        else
        {
            if (E[i].state == 1 &amp;&amp; !(i&amp;1))
                ans.push_back(make_pair(make_pair(E[i].from, E[i].to), 0));
        }
    }
}
int main()
{
    //freopen("in.txt", "r", stdin);
    int n,m;
    while (scanf("%d%d", &amp;n, &amp;m) == 2)
    {
        init();
        for (int i = 0; i &lt; m; i++)
        {
            int x,y,v;
            scanf("%d%d%d", &amp;x, &amp;y, &amp;v);
            addEdge(x,y,v);
            addEdge(y,x,v);
           // cout&lt;&lt;0&lt;&lt;endl;
        }
        while (!que.empty())
            que.pop();
        //cout&lt;&lt;0&lt;&lt;endl;
        dijkstra(1,n);
       // cout&lt;&lt;1&lt;&lt;endl;
        getAns(n);
       // cout&lt;&lt;2&lt;&lt;endl;
        printf("%d\n", ans.size());
        for (int i = 0; i &lt; ans.size(); i++)
        {
            printf("%d %d %d\n", ans[i].first.first, ans[i].first.second, ans[i].second);
        }

    }

}
</code></pre>

<p>最短路的总结暂时就告一段落了，这也是今天总结最主要的一部分，下面简单来说一说最小生成树！还是先来看例题。</p>

<ol>
<li><a href="http://poj.org/problem?id=3723">POJ 3723 Conscription</a></li>
</ol>


<p>题意：招募女兵n人，男兵m人，每人需要花费10000快，某些女兵同某些男兵之间有一定的亲密度（1–9999），招募某个人的费用是10000-（已经招募了的人之中和自己亲密度的最大值）。问你征募所有人所需的最小费用是多少。</p>

<p>首先，所有人都要招募，所以我就先把所有人都招募进来，总共花费(n+m)*10000，但是有些人花费的要少一些，我们只需要把少的这些从总费用里扣除掉就行。少多少实际上可以用亲密度的最大生成树来表示（或者有可能是最大生成森林），当然，如果权值取亲密度的相反数，那么就是最小生成树了。这里用Kurskal算法比较好，一是点比较多，20000，二是PRIM求最小生成森林也比较麻烦，当然，主要原因是第一点。不多说了，上代码：</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include&lt;vector&gt;

using namespace std;
const int maxv = 20020;
const int maxe = 100100;
const int INF = 0x3fffffff;
struct Edge{
    int x, y, d;
    bool operator &lt;(Edge p)const{return d &lt; p.d;}
};

int n,m,r;
Edge E[maxe];

int father[maxv];

void init(int n)
{
    for (int i = 0; i &lt; n; i++)
        father[i] = i;
}
int getfather(int i)
{
    if (father[i] == i)
        return i;
    return father[i] = getfather(father[i]);
}

bool judge(int i, int j)
{
    int a = getfather(i), b = getfather(j);
    if (a == b)
        return true;
    return false;
}

void getUnion(int i, int j)
{
    int a = getfather(i), b = getfather(j);
    father[a] = b;
}

int main()
{
     int t;
     scanf("%d", &amp;t);
     while(t--)
     {
         scanf("%d%d%d", &amp;n, &amp;m, &amp;r);
         init(n+m);
         for (int i = 0; i &lt; r; i++)
         {
             int x,y,d;
             scanf("%d%d%d", &amp;x, &amp;y, &amp;d);
             E[i] = (Edge){x, y+n, -d};
         }
         sort(E, E+r);
         int ans = (n+m)*10000;
         for (int i = 0; i &lt; r; i++)
         {
             if (!judge(E[i].x, E[i].y))
             {
                 ans += E[i].d;
                 getUnion(E[i].x,E[i].y);
             }
         }
         printf("%d\n", ans);
     }
}
</code></pre>

<p>最后，还找了一道PRIM的练习题，如下</p>

<p><a href="http://poj.org/problem?id=1251">POJ 1251 Jungle Roads</a></p>

<p>赤果果的一道最小生成树的题目，只不过读入的方式不太一样而已。这里只有不到30个点，所以用PRIM还是一点问题都没有的。还是挂一下代码吧！</p>

<p>PRIM代码</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include&lt;vector&gt;

using namespace std;
const int maxv = 1010;
const int maxe = 20200;
const int INF = 0x3fffffff;
typedef pair&lt;int, int&gt; P;

int a[30][30];
int n,m;
bool vis[30];
int PRIM()
{
    fill(vis, vis+n, false);
    int res = 0;
    priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que;
    for (int i = 0; i &lt; n; i++)
        if (a[0][i] &lt; INF)
            que.push(make_pair(a[0][i], i) );
    vis[0] = true;
    while(!que.empty())
    {
        P u = que.top();que.pop();
        if (vis[u.second]) continue;
        res += u.first;
        vis[u.second] = true;
        for (int i = 0; i &lt; n; i++)
        {
            if (!vis[i])
                que.push(make_pair(a[u.second][i], i));
        }
    }
    return res;
}
int main()
{
    while (scanf("%d", &amp;n))
    {
        if (n == 0)
            break;
        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt; n; j++)
                a[i][j] = INF;

        for (int i = 0; i &lt; n-1; i++)
        {
            char c;
            scanf("%s%d", &amp;c, &amp;m);
            int x = c-'A';
            for (int j = 0; j &lt; m; j++)
            {
                char ch;
                int len;
                scanf("%s%d", &amp;ch, &amp;len);
                a[x][ch-'A'] = len;
                a[ch-'A'][x] = len;
            }
         }
         int res = PRIM();
         printf("%d\n",res);
     }
}
</code></pre>

<p>KRUSKAL代码</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include&lt;vector&gt;

using namespace std;
const int maxv = 30;
const int maxe = 1000;
const int INF = 0x3fffffff;
typedef pair&lt;int, int&gt; P;
typedef pair&lt;int, P&gt; Edge;

Edge E[maxe];
int n,m;
int nume;
int father[maxv];

void init(int n)
{
    for (int i = 0; i &lt; n; i++)
        father[i] = i;
    nume = 0;
}

int getfather(int i)
{
    if (father[i] == i)
        return i;
    return father[i] = getfather(father[i]);
}

bool judge(int i, int j)
{
    int a = getfather(i), b = getfather(j);
    return a == b;
}

void getUnion(int i, int j)
{
    int a = getfather(i), b = getfather(j);
    father[a] = b;
}

int Kruskal()
{
    sort(E, E+nume);
    int res = 0;
    for (int i = 0; i &lt; nume; i++)
    {
        P tp = E[i].second;
        if (!judge(tp.first, tp.second))
        {
            res += E[i].first;
            getUnion(tp.first, tp.second);
        }
    }
    return res;
}
int main()
{
    while (scanf("%d", &amp;n))
    {
        if (n == 0)
            break;
        init(n);

        for (int i = 0; i &lt; n-1; i++)
        {
            char c;
            scanf("%s%d", &amp;c, &amp;m);
            int x = c-'A';
            for (int j = 0; j &lt; m; j++)
            {
                char ch;
                int len;
                scanf("%s%d", &amp;ch, &amp;len);
                E[nume++] = make_pair(len, make_pair(x, ch-'A'));
            }
        }

        int res = Kruskal();
        printf("%d\n",res);
     }
}
</code></pre>

<p>总结一下，一般情况下，就用Kruskal吧，除非是稠密图（点特别少，边特别多的时候），我确实Kruskal掌握地比PRIM好一些，但是今天敲了下PRIM，确实是PRIM敲起来更加简单，还是要知道怎么用的，必要的时候要能够会用！</p>

<p>好了，今天一天干的事情大概都在上面了，真是，一个这个总结都写了2个多小时，╮(╯▽╰)╭，忧伤！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BUPT暑假训练2013级个人排位赛]]></title>
    <link href="http://whn757397540.github.io/blog/2014/08/01/buptshu-jia-xun-lian-2013ji-ge-ren-pai-wei-sai-8/"/>
    <updated>2014-08-01T09:16:16+08:00</updated>
    <id>http://whn757397540.github.io/blog/2014/08/01/buptshu-jia-xun-lian-2013ji-ge-ren-pai-wei-sai-8</id>
    <content type="html"><![CDATA[<h2>第八场</h2>

<!-- more -->


<p>A题 <a href="http://code.bupt.edu.cn/problem/p/448/">BOJ 448. 游戏</a></p>

<p>枚举边就行了，我枚举的方法是，记录下第一个边的向量，然后设置一个变量来标记第一个边是否时被计数进去，然后再设置一个标记来标记之前一个边是否被记录进去，用向量判断钝角，注意别重就行。代码</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;


using namespace std;

double x1,y1,x2,y2,x3,y3;
bool judge=false;

int main()
{
    int n;
    while (scanf("%d",&amp;n)!=EOF)
    {
        int sum=0;
        bool judgeFirst=false;
        judge=false;
        scanf("%lf%lf",&amp;x1,&amp;y1);
        scanf("%lf%lf",&amp;x2,&amp;y2);
        scanf("%lf%lf",&amp;x3,&amp;y3);

        double x0=x2-x1,y0=y2-y1;
        double recx=x1,recy=y1;
        if (x0*(x3-x2)+y0*(y3-y2)&gt;0)
        {
            sum+=2;
            judge=true;
            judgeFirst=true;
        }
        x1=x2;y1=y2;x2=x3;y2=y3;
        for (int i=3;i&lt;=n;i++)
        {
            if (i!=n) scanf("%lf%lf",&amp;x3,&amp;y3);
            else
            {
                x3=recx;
                y3=recy;
            }
            if ((x2-x1)*(x3-x2)+(y2-y1)*(y3-y2)&gt;0)
            {
                if (judge)
                    sum+=1;
                else
                {
                    sum+=2;
                    judge=true;
                }
            }
            else
                judge=false;
            x1=x2;y1=y2;x2=x3;y2=y3;
        }
        if ((recx-x1)*x0+(recy-y1)*y0&gt;0)
            if (judge&amp;&amp;judgeFirst);
            else if (judge||judgeFirst)
                sum+=1;
            else
                sum+=2;
        printf("%d\n",sum);
    }
}
</code></pre>

<p>B题 <a href="http://code.bupt.edu.cn/problem/p/468/">BOJ 468. 小妹妹送快递</a></p>

<p>个人比较偏向并查集的做法，应该说是kruskal最小生成树的想法，挺简单的。就不具体分析了。代码</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;
#define N 10005
struct data
{
    int x,y,c;
}a[10*N];

int father[N];

int getfather(int);
bool PlusJudge(int,int);
void GetPlus(int,int);
bool cmp(data,data);

int main()
{
    int T;
    cin&gt;&gt;T;
    while (T--)
    {
        int n,m;
        int ans=1;
        cin&gt;&gt;n&gt;&gt;m;
        for (int i=1;i&lt;=n;i++)
            father[i]=i;
        for (int i=0;i&lt;m;i++)
            scanf("%d%d%d",&amp;a[i].x,&amp;a[i].y,&amp;a[i].c);
        sort(a,a+m,cmp);

        for (int i=0;i&lt;m;i++)
        {
            GetPlus(a[i].x,a[i].y);
            ans=max(ans,a[i].c);
            if (PlusJudge(1,n))
                break;
        }

        if (PlusJudge(1,n) )
            printf("%d\n",ans);
        else
            printf("shimatta!\n");
    }
    return 0;
}

int getfather(int i)
{

    if (father[i] != i) father[i] = getfather( father[i] );
    return father[i];
}

bool PlusJudge(int i,int j)
{
    if ( getfather( i ) == getfather( j ) )
        return true;
    else
        return false;
}

void GetPlus(int i,int j)
{
    int a = getfather( i );
    int b = getfather( j );
    father[b] = a;
}

bool cmp(data a,data b)
{
    return a.c&lt;b.c;
}
</code></pre>

<p>C题 <a href="http://code.bupt.edu.cn/problem/p/472/">BOJ  472. 学姐点名</a></p>

<p>卡代码量，卡时间，就酱紫。方法有两种。</p>

<p>算出学号之和（用公式就可以，求和也行），然后求出所给的数据之和，然后相减。代码</p>

<pre><code class="c++">#include &lt;cstdio&gt;
int main()
{
    int n;
    while (scanf("%d",&amp;n)!=EOF)
    {
        int i,sum=0;
        for (i=1;i&lt;n;i++)
        {
            int num;
            scanf("%d",&amp;num);
            sum+=num;
        }
        int a;
        if (n%2) a=(n+1)/2*n;
        else a=n/2*(n+1);
        printf("%d\n",a-sum);
    }
}
</code></pre>

<p>1到n求异或，然后读入的时候再异或回来，剩下的数就是要找的学弟编号，利用了异或的性质，代码就不附了，很简单。</p>

<p>D题 <a href="http://code.bupt.edu.cn/problem/p/452/">BOJ 452. 解码锦标赛</a></p>

<p>dp，我感觉难点在找对手身上。 先说dp关系式dp[i][j]，i代表选手编号，j代表当前轮数（我是把最开始的那一轮算作第0轮的。），dp[i][j]=dp[i][j-1]<em>(sigma(dp[k][j-1]</em>w[i][k])其中k代表i在当前轮可能遇到的对手（递推式应该很好理解）。</p>

<p>接下来就是找对手了，我在这里卡了好久。</p>

<p>首先，我们吧所有的选手编号转换为二进制，就会发现是1 vs 10 11 vs 100 101 vs 110 111 vs 1000……，这可能感觉还是不太好，可以尝试再把它减1，就会发现是酱紫：0 vs 1 10 vs 11 100 vs 101 110 vs 111 1000 vs 1001……，这就很好看了，因为一个数对1取异或，就是他的对手，这多好的性质 呀，所以，第一轮的对手很容易找到了就。但是第二轮呢，这就不是一个对手了，怎么办？ 咱们观察下，第二轮（以及更高的轮次）都可以看作是组与组之间的对战，对与第二轮，所有数都除以2（整除），把得到结果相同的归为一组，进行对战，就会发现，依然是 0 vs 1,10 vs 11,100 vs 101……，同理，下一轮，就再除以个2(就是原来的数除以4)，还会是这种对局，酱紫的话，对手的问题就解决了，哈哈，这题就可以做了。结合分析看代码吧！</p>

<p>。</p>

<pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;

using namespace std;
const int N=10;

double dp[1 &lt;&lt; N + 1][1 &lt;&lt; N + 1],w[1 &lt;&lt; N + 1][1 &lt;&lt; N + 1];

double others(int i,int j)
{
    int temp= 1 &lt;&lt; j ;
    double res=0.0;

    i-=1;
    int cnt=i/temp;

    for (int k = ((cnt^1)*temp+1); k &lt;= (((cnt^1)+1) * temp);k ++)
        res+=dp[k][j]*w[i+1][k];
    return res;
}
int main()
{
    int n;
    while (scanf("%d",&amp;n),n!=0)
    {
        for (int i = 1;i &lt;= ( 1 &lt;&lt; n );i ++)
        {
            dp[i][0]=1;
            for (int j = 1;j &lt;= (1 &lt;&lt; n);j++)
                scanf("%lf",&amp;w[i][j]);
        }
        for (int i = 1;i &lt;= ( 1 &lt;&lt; n);i ++)
            dp[i][1]=w[i][((i-1)^1)+1];

        for (int j = 2;j &lt;= n;j ++)
            for (int i = 1;i &lt;= (1&lt;&lt;n);i++)
                dp[i][j]=dp[i][j-1]*others(i,j-1);
        int ans;
        double winner=0;
        for (int i = 1;i &lt;= (1&lt;&lt;n) ;i ++)
        {
            if (dp[i][n] &gt; winner+0.001)
            {
                ans=i;
                winner = dp[i][n];
            }
        }
        printf("%d\n",ans);

    }
}
</code></pre>

<p>这次的E题，比赛时间全砸上了，思路没错，不过线段树可能写的有些毛病，而且我认为这次的E题有研究一下的必要，不光是因为他是可以用线段树做的（我最近在搞线段树），他还可以用树状数组（二次差分），用5个树状数组来维护就行。还可以用分块的思想来做。</p>

<p>E题 <a href="http://code.bupt.edu.cn/problem/p/451/">BOJ 451. 田田的算数题</a></p>

<p>有三种方法，线段树，树状数组，桶分（当然，也有可能还有其他方法）。</p>

<p>线段树方法。</p>

<p>原理其实很简单。</p>

<p>等差数列是可以叠加的（就是说，如果你在[ l , r ]区间先后加上一个首项为x1,公差为d1的等差数列和一个首项为x2公差为d2的等差数列，相当于直接加上一个首项为（x1+x2)公差为(d1+d2)的等差数列。）</p>

<p>等差数列，只需要知道首项x，公差d和元素个数n，就能根据公式求出和来，而元素个数n正好是[ l , r ]区间的长度r-l+1。</p>

<p>对于需要从中间截断的时候，我们也可以求出后一半区间的首项来。</p>

<p>有了以上两点保证，就很容易求了，维护一个区间求和的域，再在懒标记中维护一个区间首项的域和一个区间公差的域，就很容易写出来（满足第一条性质，所以不用判断是否有懒标记，直接叠加就可以了）。不过线段树写起来确实有点烦，注不要出错就行。这里附上我的代码</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#define N 100005
using namespace std;
typedef long long ll;
long long ans;

struct tree
{
    int l,r;
    ll data;
}a[4*N];

bool haveRec[4*N];
struct record
{
    ll x,d;
}rec[4*N];
long long getSum(ll x,ll d,ll n)
{
    return (n*x+n*(n-1)/2*d);
}
void buildTree(int now,int l,int r)
{
    int lson=2*now,rson=2*now+1;
    a[now].l=l;
    a[now].r=r;
    a[now].data=0;
    rec[now].x=rec[now].d=0;
    if (l==r) return;
    int mid= (l+r) &gt;&gt; 1;
    buildTree(lson,l,mid);
    buildTree(rson,mid+1,r);
}
void Insert(int now,int aim,ll det)
{
    int lson=2*now,rson=2*now+1;
    if (a[now].l==aim&amp;&amp;a[now].r==aim)
    {
        a[now].data+=det;
        return;
    }
    int mid=(a[now].l+a[now].r) &gt;&gt; 1 ;
    if (aim&lt;=mid)
        Insert(lson,aim,det);
    else
        Insert(rson,aim,det);
    a[now].data=a[lson].data+a[rson].data;

}
void InsertRec(int now,int l,int r,int x,int d)
{
    int lson=2*now,rson=2*now+1;
    if (a[now].l==l&amp;&amp;a[now].r==r)
    {
        rec[now].x+=x;
        rec[now].d+=d;
        return;
    }
    int mid=(a[now].l+a[now].r) &gt;&gt; 1;
    rec[lson].x+=rec[now].x;
    rec[lson].d+=rec[now].d;
    rec[rson].x+=(rec[now].x+(mid+1-a[now].l)*rec[now].d);
    rec[rson].d+=rec[now].d;
    if (r&lt;=mid)
        InsertRec(lson,l,r,x,d);
    else if (l&gt;mid)
        InsertRec(rson,l,r,x,d);
    else
    {
        InsertRec(lson,l,mid,x,d);
        InsertRec(rson,mid+1,r,x+(mid+1-l)*d,d);
    }
    a[now].data=a[lson].data+a[rson].data+getSum(rec[lson].x,rec[lson].d,a[lson].r-a[lson].l+1)+getSum(rec[rson].x,rec[rson].d,a[rson].r-a[rson].l+1);
    rec[now].x=0;
    rec[now].d=0;
}
void Search(int now,int l,int r)
{
    int lson=2*now,rson=2*now+1;
    if (a[now].l==l&amp;&amp;a[now].r==r)
    {
        ans+=a[now].data+getSum(rec[now].x,rec[now].d,r-l+1);
        return;
    }
    int mid=(a[now].l+a[now].r) &gt;&gt; 1;

    rec[lson].x+=rec[now].x;
    rec[lson].d+=rec[now].d;
    rec[rson].x+=(rec[now].x+(mid+1-a[now].l)*rec[now].d);
    rec[rson].d+=rec[now].d;
    if (r&lt;=mid)
        Search(lson,l,r);
    else if (l&gt;mid)
        Search(rson,l,r);
    else
    {
        Search(lson,l,mid);
        Search(rson,mid+1,r);
    }
    a[now].data=a[lson].data+a[rson].data+getSum(rec[lson].x,rec[lson].d,a[lson].r-a[lson].l+1)+getSum(rec[rson].x,rec[rson].d,a[rson].r-a[rson].l+1);
    rec[now].x=0;
    rec[now].d=0;
}
int main()
{
    int T;
    cin&gt;&gt;T;
    while(T--)
    {
        ll n,m;
        scanf("%lld%lld",&amp;n,&amp;m);
        buildTree(1,1,n);
        for (int i=1;i&lt;=n;i++)
        {
            ll num;
            scanf("%lld",&amp;num);
            Insert(1,i,num);
        }
        for (int i=1;i&lt;=m;i++)
        {
            int order;
            scanf("%d",&amp;order);
            if (order==1)
            {
                int l,r;
                ll x,d;
                scanf("%d%d%lld%lld",&amp;l,&amp;r,&amp;x,&amp;d);
                InsertRec(1,l,r,x,d);
            }
            else if(order==2)
            {
                int l,r;
                scanf("%d%d",&amp;l,&amp;r);
                ans=0;
                Search(1,l,r);
                printf("%lld\n",ans);
            }
   }
}
</code></pre>

<p>树状数组方法 我这里的树状数组方法，是利用了差分的思想，二次差分，看这个之前，你得先要知道如何用差分的思想用树状数组来来解决区间加减一个数的区间修改和查询的方法，不知道的可以去看我的<a href="">这篇博客</a>熟悉了这种推导方法，接下来的推导才能看得懂。好了，废话少说，来进入题解。 首先，通过以前的推导我们知道，如果设b[i]=a[i]-a[i-1] (设a[0]=0),我们会有</p>

<p>sigma(a[i])=n<em>b[1]+(n-1)</em>b[2]+……b[1]=(n+1)sigma(b[i])-sigma(i*b[i])——（1） (这个式子是接下來推导的基础)</p>

<p>同样我们设c[i]=b[i]-b[i-1] (同样设b[0]=0),酱紫的话，就可以通过维护c[i]的几个特定的值（应该是3个）来维护一段区间的公差d了，这个是怎么作用的请根据前面那片博客的做法来自行推导，不难。</p>

<p>前面用b[i]来维护区间加减一个数的思想是用b[i]来表示a[i]的前n项和，同理，这里也应该是用c[i]来表示a[i]的前n项和那么我们需要把（1）式化成用c[i]来表示的形式。我们看到，（1）式中有sigma(b[i])和sigma(i*b[i])，很容易知道</p>

<p>sigma(b[i])=(n+1)sigma(c[i])-sigma(i*c[i]———————————————(2)</p>

<p>那么关键就在于求sigma(i*b[i]),把它展开,并把b[i]=c[i]+b[i-1]代入会发现是这个样子</p>

<p>sigma(i*b[i])</p>

<p>=b[1]+2<em>b[2]+3</em>b[3]+……+n*b[n]</p>

<p>=c[1]+2<em>(c[2]+b[1])+3</em>(c[3]+b[2])+……+n*(c[n]+b[n-1])</p>

<p>=sigma(i<em>c[i])+sigma(b[i])(i=1..n-1)+sigma(i</em>b[i])(i=1..n-1)————————(3)</p>

<p>到这里，我们看最后一项，这不就是i*c[i]的前n-1项和吗？那么我们就可以一直递推下去了，就得到如下的式子</p>

<p>=sigma(i<em>c[i])+sigma(i</em>c[i])(i=1..n-1)+sigma(i<em>c[i])(i=1..n-1)+……+1</em>c[1]+sigma(b[i])(i=1..n-1)+sigma(b[i])(i=1..n-2)+……+b[1]</p>

<p>我们的目标是c，b什么的最讨厌了，所以我们要想办法把它搞掉，怎么办呢？别急，我们试下把它展开，就得到了下面的式子</p>

<p>=sigma(sigma(i<em>c[i]))+(n-1)</em>b[1]+(n-2)*b[2]+……+b[n-1]</p>

<p>看到后面的b的部分，我就感觉很高兴，我说过，（1)式很重要，熟悉（1)式了的花，会发现，后边的b的部分是可以化成n<em>sigma(b[i])-sigma(i</em>b[i])的，先化成这样不管它再去搞下c的部分，怎么也不能让它有两次求和吧？我们设d[i]=i<em>c[i]，会发现sigma(sigma(i</em>c[i]))=sigma(sigma(d[i]))，这不跟刚才的b是一样的吗？哈哈，看到这里就感觉世界真美好，那么就可以的到接下来的式子了</p>

<p>=(n+1)sigma(i<em>c[i])-sigma(i2</em>c[i])+n<em>sigma(b[i])(i=1..n-1)-sigma(i</em>b[i])——–(4)</p>

<p>到这里可能有人说了，怎么还有b[i]，不是要把b[i]干掉吗？b[i]一直在叫我怎么做？这个不用着急，没法继续往下化了，我们去看看前面，注意到前面有个(3)式，而且(3)式里有个+sigma(i<em>b[i])，而(4)式里有个-sigma(i</em>b[i])，我们把他俩加起来，不就把i*b[i]搞定了？那，还有个b[i]呢，怎么办？带公式直接变成c[i]不解释。经过整合以后，就会得到最终的式子，如下：</p>

<p>sigma(a[i])=(n+1)2<em>sigma(c[i])+(–(3</em>n+4)<em>sigma(i</em>c[i])+sigma(i2<em>c[i])-n</em>(n+1)sigma(c[i])(i=1..n-1)+(n+1)<em>sigma(i</em>c[i])(i=1..n-1))/2</p>

<p>具体的实现请参考那篇博客的思路，这里说一点就是，可以把x和d分开来维护，用b[i]来维护x，用c[i]来维护d,初始设c[i]为0就可以,这样应该是需要5个树状数组；当然，也可以全部都用c[i]来维护，这样可以用4个树状数组（一个原数组的，一个是维护d的3个跟c[i]有关的数组c[i],i<em>c[i]和i2</em>c[i],c[i]初始为0）或者3个树状数组（全部用c[i]来维护，输入原数组的时候更新c[i]的值）不过道理都是一样的，这份代码里有用4个和5个树状数组的代码。仅供参考。</p>

<pre><code class="c++">
/*维护5个树状数组，时间2500ms*/
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#define N 100005
using namespace std;
typedef long long ll;
ll ans;
ll A[N],B[N],C[N],D[N],E[N];
ll n;

ll lowbit(ll x)
{
    return x&amp;(-x);
}

void Update(ll x,ll det,ll a[])
{
    for (ll i = x;i&lt;= n; i+=lowbit(i))
        a[i]+=det;
}

ll GetSum(ll x,ll a[])
{
    ll res=0;
    for (ll i=x;i&gt;0;i-=lowbit(i))
        res+=a[i];
    return res;
}

ll dGetSum(ll n)
{
    ll res=0;
    res=(n+1)*(n+1)*GetSum(n,C)+((n+1)*GetSum(n-1,D)-(3*n+4)*GetSum(n,D)+GetSum(n,E)-n*(n+1)*GetSum(n-1,C))/2;
    return res;

}

ll xGetSum(ll n)
{
    ll res=0;
    res=(n+1)*GetSum(n,A)-GetSum(n,B);
    return res;
}
int main()
{
    int T;
    cin&gt;&gt;T;
    while(T--)
    {
        ll m,num1=0;
        scanf("%lld%lld",&amp;n,&amp;m);
        memset(A,0,sizeof(long long)*(n+2));
        memset(B,0,sizeof(long long)*(n+2));
        memset(C,0,sizeof(long long)*(n+2));
        memset(D,0,sizeof(long long)*(n+2));
        memset(E,0,sizeof(long long)*(n+2));

        for (ll i=1;i&lt;=n;i++)
        {
            ll num;
            scanf("%lld",&amp;num);
            Update(i,num-num1,A);
            Update(i,i*(num-num1),B);
            num1=num;
        }

        for (ll i=1;i&lt;=m;i++)
        {
            ll order;
            scanf("%d",&amp;order);
            if ( order==1 )
            {
                ll l,r,x,d;
                scanf("%lld%lld%lld%lld",&amp;l,&amp;r,&amp;x,&amp;d);
                Update(l,x,A);
                Update(l,l*x,B);
                Update(r+1,-x,A);
                Update(r+1,-(r+1)*x,B);
                if (r&gt;l)
                {
                    Update(l+1,d,C);
                    Update(r+1,-(r-l+1)*d,C);
                    Update(r+2,(r-l)*d,C);
                    Update(l+1,(l+1)*d,D);
                    Update(r+1,-(r-l+1)*(r+1)*d,D);
                    Update(r+2,(r-l)*(r+2)*d,D);
                    Update(l+1,(l+1)*(l+1)*d,E);
                    Update(r+1,-(r+1)*(r+1)*(r-l+1)*d,E);
                    Update(r+2,(r-l)*(r+2)*(r+2)*d,E);
                }
            }
            else if( order==2 )
            {
                ll l,r;
                scanf("%lld%lld",&amp;l,&amp;r);
                ans=xGetSum(r)-xGetSum(l-1)+dGetSum(r)-dGetSum(l-1);
                printf("%lld\n",ans);
            }
        }
    }
}
</code></pre>

<pre><code class="c++">/*维护4个树状数组,时间不到200ms*/

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#define N 100005
using namespace std;
typedef long long ll;
ll ans;
ll A[N],B[N],C[N],D[N],E[N];
ll n;

ll lowbit(ll x)
{
    return x&amp;(-x);
}

void Update(ll x,ll det,ll a[])
{
    for (ll i = x;i&lt;= n; i+=lowbit(i))
        a[i]+=det;
}

ll GetSum(ll x,ll a[])
{
    ll res=0;
    for (ll i=x;i&gt;0;i-=lowbit(i))
        res+=a[i];
    return res;
}

ll dGetSum(ll n)
{
    ll res=0;
    res=((n*n+3*n+2)*GetSum(n,C)-(2*n+3)*GetSum(n,D)+GetSum(n,E))/2;
//这个公式是列项找规律找出来的，由于都是前n项和，所以比我推导出来的公式快一点，至于怎么能把那个公式化成这个，我也不清楚。。。
    return res;

}

ll xGetSum(ll n)
{
    return GetSum(n,A);
}
int main()
{
    int T;
    cin&gt;&gt;T;
    while(T--)
    {
        ll m,num1=0;
        scanf("%lld%lld",&amp;n,&amp;m);
        memset(A,0,sizeof(ll)*(n+2));
        memset(C,0,sizeof(ll)*(n+2));
        memset(D,0,sizeof(ll)*(n+2));
        memset(E,0,sizeof(ll)*(n+2));

        for (ll i=1;i&lt;=n;i++)
        {
            ll num;
            scanf("%lld",&amp;num);
            Update(i,num,A);
        }

        for (ll i=1;i&lt;=m;i++)
        {
            ll order;
            scanf("%lld",&amp;order);
            if ( order==1 )
            {
                ll l,r,x,d;
                scanf("%lld%lld%lld%lld",&amp;l,&amp;r,&amp;x,&amp;d);
                Update(l,x,C);
                Update(l,l*x,D);
                Update(l,l*l*x,E);
                if (r&gt;l)
                {
                    Update(l+1,d-x,C);
                    Update(l+1,(l+1)*(d-x),D);
                    Update(l+1,(l+1)*(l+1)*(d-x),E);
                    Update(r+1,-x-(r-l+1)*d,C);
                    Update(r+1,(r+1)*(-x-(r-l+1)*d),D);
                    Update(r+1,(r+1)*(r+1)*(-x-(r-l+1)*d),E);
                }
                else
                {
                      Update(r+1,-2*x,C);
                    Update(r+1,(r+1)*(-2*x),D);
                    Update(r+1,(r+1)*(r+1)*(-2*x),E);
                }
                Update(r+2,x+(r-l)*d,C);
                Update(r+2,(r+2)*(x+(r-l)*d),D);
                Update(r+2,(r+2)*(r+2)*(x+(r-l)*d),E);
            }
            else if( order==2 )
            {
                ll l,r;
                scanf("%lld%lld",&amp;l,&amp;r);
                ans=xGetSum(r)-xGetSum(l-1)+dGetSum(r)-dGetSum(l-1);
                printf("%lld\n",ans);
            }
        }
    }
}
</code></pre>

<p>至于维护三个树状数组的，应该理解了的话，很容易搞出来的，我没改代码，大概也是2000ms左右的时间复杂度吧。</p>

<p>另外还有另外一种树状数组的做法，不是利用差分的思想。差分的思想是只有要加的元素通过有限次差分能够得到一个常数，才能用。那种思想应该是只要有公式就可以用的，这种做法我还没有去细致研究，等研究过了还会继续写一篇博客来介绍。具体请参考《挑战程序设计竞赛》这本书，或者去玮神<a href="http://blog.csdn.net/qq_16089147/article/details/38333965">这篇博客</a>看看，也是这道题，还有桶分的解法。</p>

<p><a href="/blog/archives/">&lt;&ndash;BACK</a></p>
]]></content>
  </entry>
  
</feed>
