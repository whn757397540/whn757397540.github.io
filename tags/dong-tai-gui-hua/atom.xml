<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 动态规划 | hnnwang's Blog]]></title>
  <link href="http://whn757397540.github.io/tags/dong-tai-gui-hua/atom.xml" rel="self"/>
  <link href="http://whn757397540.github.io/"/>
  <updated>2015-04-21T22:50:55+08:00</updated>
  <id>http://whn757397540.github.io/</id>
  <author>
    <name><![CDATA[hnnwang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[BUPT暑假训练 2013级个人排位赛]]></title>
    <link href="http://whn757397540.github.io/blog/2014/07/20/buptshu-jia-xun-lian-2013ji-ge-ren-pai-wei-sai/"/>
    <updated>2014-07-20T22:35:29+08:00</updated>
    <id>http://whn757397540.github.io/blog/2014/07/20/buptshu-jia-xun-lian-2013ji-ge-ren-pai-wei-sai</id>
    <content type="html"><![CDATA[<p>第二场</p>

<p>PS：这是我的第一篇octopress博客，是把CSDN上的第二场个人排位赛的题解搬了过来，并加上了第五题的题解，以后还会陆续写其他场次，好了，开始）</p>

<!--more-->


<p>这次训练的题目，两道水题（卡数据类型，有好多人不能1A，我也在内），还有3道题，不是很容易。</p>

<ol type="a">
<li><a href="http://code.bupt.edu.cn/problem/p/416/">BOJ 0416丁神去谷歌</a></li>
</ol>


<p>一道很水的题，因为我刚开始用了sort，T了一次，后来又忘了是什么原因RE了2次尴尬，最后，就直接读入的时候比较的，很水，想多了。</p>

<p>下面简单分析一下吧，由于是要求b/a的最大值，所以只需要把当前的b/a与之前最大的b/a比较就行，如果相同的话（在这了需要主语，如果你用的是交叉相乘来比较，记得用long long，如果你用的是b/a来比较，在判断是否相等的时候记得浮点型的精度问题，可以用abs(max-(double)b/a)&lt;=1e-9 之类的式子来判断，不要直接用等号），再去比较a的大小，由于本身序号就是从小到大的，所以也不用担心这个了（只要a相等的时候别更新答案就行），说的有点多了，附代码吧(C++)</p>

<pre><code class="C++">#include &lt;iostream&gt;  
#include &lt;string&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
#include &lt;cstdlib&gt;  
#include &lt;cmath&gt;  
#include &lt;algorithm&gt;  

#define N 100005  

using namespace std;

int main()
{
    int t;
    double MAX=0;
    cin&gt;&gt;t;
    while (t--)
    {
        int n;
        int ans,ansa;
        MAX=0;
        scanf("%d",&amp;n);
        for (int i=1;i&lt;=n;i++)
        {
            int a,b;
            scanf("%d%d",&amp;a,&amp;b);
            double c=(double)b/a;
            if (MAX&lt;c)
            {
                MAX=c;
                ans=i;
                ansa=a;
            }
            else if(abs(MAX-c)&lt;=1e-10)
            {
                if (a&lt;ansa)
                {
                ans=i;
                ansa=a;
                }
            }
        }
        printf("%d\n",ans);
    }
return 0;
}
</code></pre>

<ol type="a">
<li><a href="http://code.bupt.edu.cn/problem/p/417/">BOJ 0417 丁神又去谷歌</a></li>
</ol>


<p>赤果果的一道0-1背包，记得要用long long 就行，直接附代码</p>

<pre><code class="C++">#include &lt;iostream&gt;  
#include &lt;string&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
#include &lt;cstdlib&gt;  
#include &lt;cmath&gt;  
#include &lt;algorithm&gt;  

#define N 1005  

using namespace std;

long long dp[N];

int a[N],b[N];

int main()
{
    int T;
    cin&gt;&gt;T;
    while (T--)
    {
        int n,t;
        scanf("%d%d",&amp;t,&amp;n);
        memset(dp,0,sizeof(dp));
        for (int i=1;i&lt;=n;i++)
            scanf("%d%d",&amp;a[i],&amp;b[i]);

        for (int i=1;i&lt;=n;i++)
            for (int j=t;j&gt;=a[i];j--)
                dp[j]=max(dp[j],dp[j-a[i]]+b[i]);
        printf("%lld\n",dp[t]);
    }
    return 0;
}
</code></pre>

<ol type="a">
<li><a href="http://code.bupt.edu.cn/problem/p/426/">BOJ426 goblin</a></li>
</ol>


<p>这个题呀，昨天比赛时有思路（PS:今天想了一上午，发现我的思路是在是太难实现了），最终还是选择了lyz大神的思路。</p>

<p>题意大概是求n以内（1—n）的数的全排列中，符合交叉排列的情况（即&lt;>&lt;>&lt;>&lt;>&lt;>,大于号小于号交叉出现的情况）总共有多少种，结果对p取余。</p>

<p>我就来说说lyz大神的思路吧，用到了排列组合的思想。首先，为了方便叙述，我先来给交叉排列的两种情况命一下名, 假设：第一个数大于第二个数的情况叫做D情况，第一个数小于第二个数的情况叫做P情况，对于k个数的排列，我们记D情况共有D[k]种，P情况共有P[k]种,(记 P[0]=P[1]=P[2]=1 那么，就有D[k]=P[k]（至于怎么来证明，其实很简单）</p>

<p>所有D情况都可以抽象成W型（第一个数第二个数大的情况），所有的P情况都可以抽象成M型（第一个比第二个数的情况）。对于D情况，可以抽出n个数中的最大数，分别放到各个凸起点，经过一些排列组合的运算，可以得到一个一个结果；同理，对于P情况，可以抽出n个数中的最小数，分别放到各个凹陷点，根据对称的特性，就可以得到跟D情况相同的结果。</p>

<p>所以，我们只需考虑一种情况了，我选取的D情况，经过排列组合的运算，很容易得到如下的关系(sigma代表求和符号）</p>

<p>D[k]=sigma(D[i[D[k-1-i]C[k-1][k-1-i]) （可能看这个式子看不懂，自己推导一下吧，分别把最大的数放到凸起点就可以了，很容易的）</p>

<p>好了，下面附代码（PS:被memset坑了好久，也学到了一点，在程序中，你如果开了数组但是没有用到，提交交时内存是不算的，如果你用了memset（a,0,sizeof(a))来初始化数组，那么这个数组就算是全部被使用了。这题中，如果用memset来初始化组合数的存储数组，就会超出内存限制。算是学到了一点吧！还有就是，如果用动态数组来做的话，是擦边过得，我是第一次交1000ms, T了，第二次993ms过了。最后，注意D数组要用long long，即便不用，运算时也记得转化一下，否则会WA的）。</p>

<pre><code class="C++">#include &lt;iostream&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  

#define N 4205  
int C[N][N]={0};
long long g[N]={0};
int n,p;

void init()
{
    memset(g,0,sizeof(g));
    g[3]=2;
    g[2]=1;
    g[1]=1;
    g[0]=1;

    for (int i=1;i&lt;=n;i++)
    {
        C[i][0]=C[i][i]=1;
        for (int j=1;j&lt;i;j++)
            C[i][j]=(C[i-1][j-1]+C[i-1][j])%p;
    }
    for (int i=4;i&lt;=n;i++)
        for (int j=0;j&lt;=i-1;j+=2)
            g[i]=(g[i]+(g[j]*g[i-1-j]%p)*C[i-1][i-1-j])%p;
}

int main()
{
    while (~scanf("%d%d",&amp;n,&amp;p))
    {
        init();
        printf("%d\n",2*g[n]%p);//输出不用lld是因为取余以后就在int的范围内了。  
    }
}
</code></pre>

<ol type="a">
<li><a href="http://code.bupt.edu.cn/problem/p/427/">BOJ 0427 学姐逗学弟</a></li>
</ol>


<p>一道博弈题目，比赛时看错题了。。。今天下午基本上全花在这个题上了，根源还是memset尴尬，通过个题我了解到：用memset来初始化数组也是要花O(n）的时间的，它比直接赋值快大约4倍，但是计算复杂度时还是要按照O（n）的复杂度考虑进去的。在此感谢zsp同学帮我找到这个错误。</p>

<p>好了，进入正题。这是一个博弈问题，Every-Sg游戏，直接说思路吧，题目可以自己点开链接来看。</p>

<p>首先，我们定义每个节点的高度为所有人都采取最优策略，一直到游戏结束所需要走的步数。思路很简单，对于必败点，走这一步的人必输，那么他肯定想尽快结束这一个游戏，所以他会选择它的所有子节点中高度最小的来走；对于必胜点，走这一步的人，想要胜利，就必须走到必败点上去，而他又想把游戏时间尽量拉长，所以他肯定会选择所有必败子节点中高度最大的那个节点来走。这样分析的话，就很容易递归的定义出一个点的高度了。然后再根据给的石子的位置来判断，比较高度最大的必胜点和高度最大的必败点的大小，就可以判断是不是学姐赢了。</p>

<p>这个代码是有注释了（为了让zsp同学帮忙找下错误而标注的，再次进行感谢），贴代码</p>

<pre><code class="c++">include &lt;iostream&gt;  
#include &lt;string&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
#include &lt;cstdlib&gt;  
#include &lt;cmath&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#define N 100005  

using namespace std;
#define INF 10000000  
vector &lt;int&gt; tree[N];

bool judgeSg[N]={false};//判断子节点出现的sg值  
int father[N]={0};//记录某个节电的父亲节点  
int depth[N]={0};//记录“高度”（懒得改了）  
int sg[N]={0};//对于单个游戏来说的每个节点的sg值。  
int n,m;

void init()//初始化  
{
    memset(father,0,sizeof(father));
    memset(depth,0,sizeof(depth));
    memset(sg,0,sizeof(sg));
    for (int i=1;i&lt;=n;i++)
        tree[i].clear();
}

void solveSg(int now)//now代表当前节点，dfs     
{
    int MAX=0,MIN=INF;

    if (tree[now].size()==0)
    {
        sg[now]=0;
        depth[now]=0;
        return ;
    }//搜到叶子节点，叶子节点对应的高度为0,sg值为0;  
    for (int i=0;i&lt;tree[now].size();i++)
    {
        int son=tree[now][i];
        solveSg(son);//dfs  

        if (MIN&gt;depth[son])
            MIN=depth[son];//记录所有子节点中的最小高度（如果当前节点是必败节点的话用得到）  
        if (sg[son]==0)//子节点为必败态  
            if (MAX&lt;depth[son])
                MAX=depth[son];//记录所有必败子节点中的最大高度（如果当前节点是必胜节点用得到)  
    }
    memset(judgeSg,false,sizeof(tree[now].size()+10));//初始化sg判断数组  
    for (int i=0;i&lt;tree[now].size();i++)
    {
        int son=tree[now][i];
        judgeSg[sg[son]]=true;//记录出现的sg值  
    }
    int res=0;

    while (judgeSg[res]) res++;

    if (res==0)//此点为必败态  
        depth[now]=MIN+1;
    else //为必胜态  
        depth[now]=MAX+1;

    sg[now]=res;//当前节点的sg值  
}
int main()
{
    int T;
    cin&gt;&gt;T;
    while (T--)
    {
        int maxWin=0,maxFail=0;//分别记录必胜点和必败点的最大高度  

        scanf("%d%d",&amp;n,&amp;m);
        init();
        for (int i=2;i&lt;=n;i++)
        {
            scanf("%d",&amp;father[i]);
            tree[father[i]].push_back(i);
        }//动态数组建树（单向的）  
        solveSg(1);//dfs  
        for (int i=1;i&lt;=m;i++)
        {
            int stone;
            scanf("%d",&amp;stone);
            if (sg[stone]==0)
                maxFail=max(maxFail,depth[stone]);
            else
                maxWin=max(maxWin,depth[stone]);
        }
        if (maxWin&gt;maxFail)//必胜的游戏时间长，学姐赢  
            printf("MengMengDa!\n");
        else
            printf("So sad...\n");
    }
    return 0;
}
</code></pre>

<p>最后，是今天写的东西。</p>

<ol type="a">
<li><a href="http://code.bupt.edu.cn/problem/p/425/">BOJ 0425 木头人足球赛</a></li>
</ol>


<p>是一道很恶心的几何题目。说简单，不简单；说难倒也不难，主要这题的测试数据不是很变态，有一种很恶心的状态，测试数据里没有，一会解释。（PS：学长说这个题的原型是个非常OP的题。。。）</p>

<p>首先，求出球门的角度范围（我选的是以x轴负方向为0度，范围是-180到180，后同），记作gate；然后，求出每个个球员的拦截角度范围(求起来也很简单，求出圆心连线与x轴负方向的夹角，再求出圆心连线与切线的夹角，然后进行加减就行，求角时记得根据角度范围来决定用什么三角函数，这个逻辑关系要弄清楚），记作player[i];然后根据player[i]的下界进行排序。</p>

<p>前面的准备工作做好了以后，接下来思路就很明确了。首先，判断上下界，就是是否存在球员，他的拦截上界大于球门上界并且他的拦截下界小于球门上界，下界最低的球员是否低于球门下界，其中任意一个条件不符合，就肯定能进球；然后，就是从下界小于球门上界的第一个球员开始，每次找上界大于或等于这个球员下界的，下界最低的球员（这样可以最地拉深区间），如果这个最低的下界大于或等于他所比较的那个球员的下界（事实上，从下界低的开始找，如果出现这种情况，只可能是那个球员本身），那就说明没有可以进球，如果这个下界球门下界低，那么说明防守很严，不能进球。</p>

<p>根据上面的分析，就有了如下的代码：</p>

<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;   
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#define N 12
using namespace std;

struct  ANGLE_SECTION
{
    double left;
    double right;
    int num;
}gate,player[N];

ANGLE_SECTION getGateSection(int x,int y)
{
    ANGLE_SECTION result;
    if (x==0) return {(acos(-1))/2,(acos(-1))/2};
    result.left=atan((double)(30-y)/x);
    result.right=atan((double)(38-y)/x);
    return result;
}

ANGLE_SECTION getPlayerSection(int x1,int y1,double r,int x0,int y0)
{
    ANGLE_SECTION result;
    double length=sqrt(pow(x1-x0,2)+pow(y1-y0,2));//与圆心连线长度
    double angle=asin(r/length);//连线与切线的夹角
    double Angle;//连线与水平射线的夹角

    if (y1&gt;=y0) Angle=acos((double)(x0-x1)/length);
    else if(x1&lt;x0)
        Angle=atan((double)(y1-y0)/(x0-x1));
    else
        Angle=-acos(-1)-asin((double)(y1-y0)/length);
    result.left=Angle-angle;
    result.right=Angle+angle;
    return result;
}

bool cmp(ANGLE_SECTION a,ANGLE_SECTION b)
{
    return (a.left&lt;b.left);
}

int main()
{
    int T;
    int x0,y0;
    cin&gt;&gt;T;
    while (T--)
    {
        bool ans=false;
        memset(player,0,sizeof(player));
        scanf("%d%d",&amp;x0,&amp;y0);
        gate=getGateSection(x0,y0);
        for (int i=1;i&lt;=11;i++)
        {
            int x,y;
            double r;
            scanf("%d%d%lf",&amp;x,&amp;y,&amp;r);
            player[i]=getPlayerSection(x,y,r,x0,y0);
        }
        sort(&amp;player[1],&amp;player[1]+11,cmp);
        int n=11;
        if (player[1].left&gt;gate.left) ans=true;
        else
        {
            while (player[n].left&gt;gate.right) n--;
            double MAX=-100;
            for (int i=1;i&lt;=n;i++)
                MAX=max(player[i].right,MAX);
            if (MAX&lt;gate.right)
                ans=true;
            else
            {
                while (1)
                {
                    int i=1;
                    while (player[i].right&lt;player[n].left)
                        i++;
                    if (i==n)
                    {
                        ans=true;
                        break;
                    }
                    while (i&gt;=1&amp;&amp;player[i].right&gt;=player[n].left) i--;
                    i++;
                    if (i&lt;=1||player[i].left&lt;=gate.left) break;
                    n=i;
                }
            }
        }
        if (ans) printf("Shoot!\n");
        else printf("Poor Mays!\n");
    }
}
</code></pre>

<p>接下来，我来谈谈那种很恶心的情况，题目数据中没有出现，如果出现了我的代码应该是A不了的。 就是那种球员的防守范围跟球场边界有交点的情况（你们可以自己画一下），在这种情况下，可能出现实际防守范围小于你根据上述方法求出来的防守范围的情况(也可能不小于）。这样求防守范围就很麻烦了。我的想法是先根据几何知识求切点，然后看切点是否在球场内，最后根据切点状态来求范围，很麻烦是不是？如果你们谁有好的办法的话记得告诉我一声，谢谢！！ （PS：到此，这篇博客算是写完了）</p>

<p>之前写这个文章的那个博客早就废了，从今天开始一篇一篇的移植过来，每天一篇慢慢来！今天第一篇（至于今天是什么日子，看地址就知道了！）</p>

<p><a href="/blog/archives">&lt;&ndash;BACK</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BUPT暑假训练 2013级个人排位赛]]></title>
    <link href="http://whn757397540.github.io/blog/2014/06/20/buptshu-jia-xun-lian-2013ji-ge-ren-pai-wei-sai/"/>
    <updated>2014-06-20T22:36:48+08:00</updated>
    <id>http://whn757397540.github.io/blog/2014/06/20/buptshu-jia-xun-lian-2013ji-ge-ren-pai-wei-sai</id>
    <content type="html"><![CDATA[<p>第三场</p>

<p>A题 <a href="http://code.bupt.edu.cn/problem/p/429/">BOJ 429 学姐的数码管</a></p>

<p>纯模拟题，看清楚要求就行，不要因为要求看错而WA好几次，附我交了6次才A的代码</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;

#define N 1005

using namespace std;

int n;
int start,End;
char s[5];
char board[150][150];

void buildNum(char s[],int n)
{
    for (int i=0;i&lt;=2*n;i++)
        for (int j=0;j&lt;=4*(n+1);j++)
            board[i][j]=' ';
    start=0;End=-2;
    for (int i=0;i&lt;4;i++)
    {
        switch (s[i]-'0')
        {
            case 0:
            {
                start=End+2;
                End=start+n-1;
                for (int y=0;y&lt;=2*n;y++)
                    for (int x=start;x&lt;=End;x++)
                    {
                        if (x==start||x==End||y==0||y==2*n)
                            board[y][x]='#';
                        else
                            board[y][x]=' ';
                    }

            }break;
             case 1:
            {
                start=End+2;
                End=start+n-1;
                for (int y=0;y&lt;=2*n;y++)
                    for (int x=start;x&lt;=End;x++)
                    {
                        if (x==End)
                            board[y][x]='#';
                        else
                            board[y][x]=' ';
                    }
            }break;
            case 2:
            {
                start=End+2;
                End=start+n-1;
                for (int y=0;y&lt;=2*n;y++)
                    for (int x=start;x&lt;=End;x++)
                    {
                        if ((x==End&amp;&amp;y&gt;=0&amp;&amp;y&lt;=n)||(x==start&amp;&amp;y&gt;=n&amp;&amp;y&lt;=2*n)||y==0||y==n||y==2*n)
                            board[y][x]='#';
                        else
                            board[y][x]=' ';
                    }
            }break;
            case 3:
            {
                start=End+2;
                End=start+n-1;
                for (int y=0;y&lt;=2*n;y++)
                    for (int x=start;x&lt;=End;x++)
                    {
                        if (x==End||y==0||y==n||y==2*n)
                            board[y][x]='#';
                        else
                            board[y][x]=' ';
                    }
            }break;
            case 4:
            {
                start=End+2;
                End=start+n-1;
                for (int y=0;y&lt;=2*n;y++)
                    for (int x=start;x&lt;=End;x++)
                    {
                        if (x==End||y==n||x==start&amp;&amp;y&lt;=n)
                            board[y][x]='#';
                        else
                            board[y][x]=' ';
                    }
            }break;
           case 5:
            {
                start=End+2;
                End=start+n-1;
                for (int y=0;y&lt;=2*n;y++)
                    for (int x=start;x&lt;=End;x++)
                    {
                        if ((x==start&amp;&amp;y&gt;=0&amp;&amp;y&lt;=n)||(x==End&amp;&amp;y&gt;=n&amp;&amp;y&lt;=2*n)||y==0||y==n||y==2*n)
                            board[y][x]='#';
                        else
                            board[y][x]=' ';
                    }
            }break;
            case 6:
            {
                start=End+2;
                End=start+n-1;
                for (int y=0;y&lt;=2*n;y++)
                    for (int x=start;x&lt;=End;x++)
                    {
                        if (x==start||(x==End&amp;&amp;y&gt;=n&amp;&amp;y&lt;=2*n)||y==0||y==n||y==2*n)
                            board[y][x]='#';
                        else
                            board[y][x]=' ';
                    }
            }break;
            case 7:
            {
                start=End+2;
                End=start+n-1;
                for (int y=0;y&lt;=2*n;y++)
                    for (int x=start;x&lt;=End;x++)
                    {
                        if (x==End||y==0)
                            board[y][x]='#';
                        else
                            board[y][x]=' ';
                    }
            }break;
            case 8:
            {
                start=End+2;
                End=start+n-1;
                for (int y=0;y&lt;=2*n;y++)
                    for (int x=start;x&lt;=End;x++)
                    {
                        if (x==start||x==End||y==0||y==n||y==2*n)
                            board[y][x]='#';
                        else
                            board[y][x]=' ';
                    }
            }break;
             case 9:
            {
                start=End+2;
                End=start+n-1;
                for (int y=0;y&lt;=2*n;y++)
                    for (int x=start;x&lt;=End;x++)
                    {
                        if (x==End||(x==start&amp;&amp;y&gt;=0&amp;&amp;y&lt;=n)||y==0||y==n||y==2*n)
                            board[y][x]='#';
                        else
                            board[y][x]=' ';
                    }
            }break;
             default:
            {
                start=End+2;
                End=start;
                for (int y=0;y&lt;=2*n;y++)
                    for (int x=start;x&lt;=End;x++)
                    {
                        if (y==2*n)
                            board[y][x]='#';
                        else
                            board[y][x]=' ';
                    }
            }break;

        }
    }
}
int main()
{
    while(~scanf("%d%s",&amp;n,s))
    {
        buildNum(s,n);
        for (int i=0;i&lt;=2*n;i++)
        {
            for (int j=0;j&lt;=End;j++)
                printf("%c",board[i][j]);
            printf("\n");
        }
        printf("\n");

    }
}
</code></pre>

<p>B题 <a href="http://code.bupt.edu.cn/problem/p/430/">BOJ 430 学姐的旋转图像</a></p>

<p>这题很简单，就是倒腾一下公式，然后做一下旋转就行。注意题目中的坑，写的是逆时针，但是他是让你从旋转后的图形再旋转回来，所以应该是顺时针。还有就是注意当行数和列数不同时，进行翻转的时候记得交换行数和列数。貌似还有一点，这个度数不一定在360度的范围内。附代码</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;

#define N 505

using namespace std;

int h,w;
int endi,endj,d;
int board[4][N][N];

void Solve()
{
    for (int k=1;k&lt;=3;k++)
    {
        if (k==1||k==3)
        {
            endi=h;
            endj=w;
        }
        else
        {
            endi=w;
            endj=h;
        }
        for (int i=1;i&lt;=endi;i++)
            for (int j=1;j&lt;=endj;j++)
                board[k][j][endi-i+1]=board[k-1][i][j];
    }
}

int main()
{
    while (~scanf("%d%d%d",&amp;h,&amp;w,&amp;d))
    {
        for (int i=1;i&lt;=h;i++)
        for (int j=1;j&lt;=w;j++)
            scanf("%d",&amp;board[0][i][j]);
        Solve();
        int ans=(d/90)%4;
        if (ans==0||ans==2)
        {
            endi=h;
            endj=w;
        }
        else
        {
            endi=w;
            endj=h;
        }
        for (int i=1;i&lt;=endi;i++)
        {
            for (int j=1;j&lt;endj;j++)
                printf("%d ",board[ans][i][j]);
            printf("%d\n",board[ans][i][endj]);
        }
    }
}
</code></pre>

<p>C题 <a href="http://code.bupt.edu.cn/problem/p/408/">BOJ 408 字符串</a></p>

<p>字符串匹配的问题，用hash来做就行，选择一个质数，算出每个数对应的hash值（我是直接用unsigned long long 来表示的，毕竟自动取余嘛，而且范围很大，不容易重），然后选择一个适当大小的质数（质数取余，重复的几率小），将hash值取余后存到一个vertor 数组中，数组下标代表余数，然后查找对应余数下面的项就好。还有一点需要注意的，如果有多组数据，最好记录一下用到了哪些下标，在初始化vector数组的时候,只对这些用过的下标就行初始化代码在这里</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#define N 10007
using namespace std;

typedef unsigned long long ull;

const ull B = 1000000007;

vector &lt;ull&gt; a[N];

ull searchHs(char b[])//求字符串的hash值；
{
    ull t=1;
    int len=strlen(b);
    ull bh=0;
    for (int i=0;i&lt;len;i++)
        bh=bh*B+b[i];
    return bh;
}

int main()
{
    char str[105];
    int cnt=0;
    while (scanf("%s",str)!=EOF)
    {
        int sum=0;
        ull hs=searchHs(str);

        int mod=hs%N;
        a[mod].push_back(hs);
        for (int i=0;i&lt;a[mod].size();i++)
            if (a[mod][i]==hs)
                sum++;
        printf("%d\n",sum);
    }
}
</code></pre>

<p>D题 <a href="http://code.bupt.edu.cn/problem/p/428/">BOJ 428 田田的帐号</a></p>

<p>这题，有人打表找规律，我由于刚开始少考虑一些东西，打表打错了，后来推出了公式，在此我推一下。</p>

<p>还是一个排列组合问题,不考虑a,b的数量问题，那么对于n个数，总共有 4n 种可能；在所有的排列中，有奇数个b的总共有 4n/2 种，有偶数个a的总共有 4n/2,有奇数个b和偶数个a的总共有 4n/4种可能，那么就很容易知道，最终符合条件的应该有 4n-4n/2-4n/2+4n/4=4n-1 种可能。</p>

<p>好了，结果算出来了，可是还是有点问题，数据范围是n&lt; 109,直接求解的话，无论是从时间上来说，还是从空间上来说，都是不现实的。对此，大部分人的解法是快速幂，我由于没有用过快速幂，所以也就没有用。我想到了当初看背包九讲时对多重背包的二进制优化，其实跟快速幂的原理差不多，只不过这个是递推的而已。附代码</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

#define N 10000
#define MOD 1000000007
using namespace std;
int dp[5]={0};
int main()
{
    int n;
    int T;
    int ans;
    cin&gt;&gt;T;
    while (T--)
    {
        scanf("%d",&amp;n);
        ans=1;
        long long fang=4;
        int k=1,cnt=1;
        while (cnt!=n)
        {
            ans=(long long)ans*fang%MOD;
            cnt+=k;
            fang=(long long)fang*fang%MOD;
            k*=2;
            if (k&gt;n-cnt)
            {
                k=1;
                fang=4;
            }
        }
        printf("%d\n",ans);

    }
}
</code></pre>

<p>E <a href="http://code.bupt.edu.cn/problem/p/419/">BOJ 419 学姐的数列</a></p>

<p>一道dp，其实可以看成是很多小的平衡二叉树组成的大的平衡二叉树。dp[i][j][k]来代表总和为 $$ 2k $$ 的，从i到j区间的平衡二叉树最多可能的元素数。因为每个dp[i][j][k]所代表的状态都是平衡二叉树，也就是符合题意的。所以既有dp[i][j][k]=max{ i=&lt;mid&lt;j | dp[i][mid][k-1]+dp[mid+1][j][k-1] } 初始化的时候，每个区间存在的所有k的值赋值为1(不知道怎么才能说清楚，看不懂这句话的就看代码吧)</p>

<pre><code class="c++">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#define N 150
using namespace std;

int dp[N][N][17];
int a[N];
int n;

void init()
{
    memset(dp,0,sizeof(dp));

}

int main()
{
    int T;
    cin&gt;&gt;T;
    while (T--)
    {
        int n,ans=1;
        scanf("%d",&amp;n);
        for (int i=1;i&lt;=n;i++)
            scanf("%d",&amp;a[i]);
        init();
        for (int i=1;i&lt;=n;i++)
            for (int j=i;j&lt;=n;j++)
                for (int k=i;k&lt;=j;k++)
                    dp[i][j][a[k]]=1;
        for (int k=1;k&lt;=15;k++)
            for (int i=1;i&lt;n;i++)
                for (int j=i+1;j&lt;=n;j++)
                    for (int mid=i;mid&lt;j;mid++)
                        {
                            if (dp[i][mid][k-1]==0||dp[mid+1][j][k-1]==0) continue;
                            dp[i][j][k]=max(dp[i][j][k],dp[i][mid][k-1]+dp[mid+1][j][k-1]);
                            if (ans&lt;dp[i][j][k]) ans=dp[i][j][k];
                        }
        printf("%d\n",ans);
    }
}
</code></pre>

<p><a href="/blog/archives">&lt;-BACK</a></p>
]]></content>
  </entry>
  
</feed>
