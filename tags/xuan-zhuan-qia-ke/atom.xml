<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 旋转卡壳 | hnnwang's Blog]]></title>
  <link href="http://whn757397540.github.io/tags/xuan-zhuan-qia-ke/atom.xml" rel="self"/>
  <link href="http://whn757397540.github.io/"/>
  <updated>2015-08-10T18:00:30+08:00</updated>
  <id>http://whn757397540.github.io/</id>
  <author>
    <name><![CDATA[hnnwang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[旋转卡壳总结]]></title>
    <link href="http://whn757397540.github.io/blog/2015/08/10/xuan-zhuan-qia-ke-zong-jie/"/>
    <updated>2015-08-10T17:31:57+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/08/10/xuan-zhuan-qia-ke-zong-jie</id>
    <content type="html"><![CDATA[<h2>POJ 2187 and POJ 3608</h2>

<p>这些天刷了几道旋转卡壳的题，被卡了一些时间，现在先就两道题对旋转卡壳的两个用法进行一个总结</p>

<!--more-->


<p>有关旋转卡壳的介绍，<a href="http://hnnwang.github.io/blog/2014/09/06/xuan-zhuan-qia-ke-1/">这里</a>说的挺全的.所以题解里就不去解释这种思想了</p>

<p>这里我说2道旋转卡壳的基础题！</p>

<p><a href="http://poj.org/problem?id=2187">POJ 2187 Beauty Contest</a></p>

<p>一道基础的旋转卡壳题，求凸包直径，很简单的一道题，直接套板子就好（一个凸凸包模板，一个旋转卡壳模板）。这里说下，在求直径的时候，由于是一个凸多边形，所以求三角形面积（事实上，求平行四边形面积就好，因为只比较大小）。这题的题目都是整点，可以用int，其实，求出凸包来以后直接暴力枚举来判断就能过（而且，竟然会比旋转卡壳还快），不过最好是用旋转卡壳来过吧，毕竟如果凸包上点多的花，暴力还是很慢的！暴力的代码就不挂了，旋转卡壳代码在这里</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#define next (i+1)%n
const double eps = 1e-10;
using namespace std;
int dcmp(double x)//精度比较
{
    if (x &lt; -eps) return -1;
    else if (x &gt; eps) return 1;
    else return 0;
}


double add(double a, double b)//考虑到精度的加法
{
    if (dcmp(a+b) == 0) return 0;
    return a + b;
}


struct Point//也可看做向量
{
    int x,y;
    Point() {}
    Point(int x,int y) : x(x),y(y){}
    Point operator + (Point p) {return Point(x + p.x, y + p.y); }//向量 + 向量 = 向量
    Point operator - (Point p) {return Point(x - p.x, y - p.y); } // 向量 - 向量 = 向量
    bool operator &lt; (const Point p) const {return x &lt; p.x  || x == p.x &amp;&amp; y &lt; p.y; } //字典序比较，重定义&lt;
    bool operator == (const Point p) const {return x == p.x &amp;&amp; y == p.y; }//重定义 ==
    int dot(Point p) {return x * p.x + y * p.y; }//点积
    int det(Point p) {return x * p.y - y * p.x; }//叉积,旋转方向取逆时针
    int sqrDis(Point p){return (x - p.x)*(x - p.x) + (y - p.y)*(y - p.y);}
};
typedef Point Vector;
int u;
int ConvexHull(Point* p,int n, Point* ch)
{
    sort(p,p+n);
    int m = 0;
    for (int i = 0; i &lt; n ; i ++)
    {
        while (m &gt; 1 &amp;&amp; (ch[m-1] - ch[m-2]).det(p[i] - ch[m-2]) &lt;= 0) m --;
        ch[m++] = p[i];
    }
    int k = m;
    for (int i = n-2; i &gt;= 0; i--)
    {
        while (m &gt; k &amp;&amp;(ch[m-1] - ch[m-2]).det(p[i] - ch[m-2]) &lt;= 0) m--;
        ch[m++] = p[i];
    }
    if (n &gt; 1) m--;
    return m;
}

int Area(Point a, Point b, Point c)
{
  Vector v = b - a;
  return abs(v.det(c - a));
}

int RotatingCalipers(Point *ch, int n, int s)
{
  int q = s;
  int ans = ch[0].sqrDis(ch[s]);
  for (int i = 0; i &lt; n; i ++)
  {
      while (Area(ch[i], ch[next], ch[(q+1)%n]) &gt; Area(ch[i], ch[next], ch[q]))
          q = (q+1) % n;
      ans = max(ans,max(ch[i].sqrDis(ch[q]), ch[next].sqrDis(ch[(q+1)%n])));
  }
  return ans;
}
Point a[55555],Hull[100000];
int main()
{
  int n;
  scanf("%d", &amp;n);
  for (int i = 0; i &lt; n; i++)
      scanf("%d%d", &amp;a[i].x, &amp;a[i].y);
  int m = ConvexHull(a, n, Hull);
  int u = 0;
  for (int i = 1; i &lt; m; i++)
      if (Hull[u].x &lt; Hull[i].x || Hull[u].x == Hull[i].x &amp;&amp; Hull[u].y &lt; Hull[i].y)
          u = i;
  int ans = RotatingCalipers(Hull, m, u);
  printf("%d\n", ans);
  // system("pause");
  return 0;
}
</code></pre>

<p>另外，还有就是求多边形宽度的，暂时没有找到题，不过看起来貌似挺简单的！</p>

<p><a href="http://poj.org/problem?id=3608">POJ 3608 Bridge Across Islands</a></p>

<p>这道题就稍微复杂一点了，求两个凸包的最近距离，不过同样也是用旋转卡壳很容易解决，只不过这次必须得用有向面积了，因为旋转的基点是不同的2个多边形，所以会出现负面积，把逻辑捣清楚就好。跟那个博客里说到的一样的方法，判断平行的时候，只求得对应平行四边形的面积为相等就行了，不平行的时候，用点到线段的距离来更新就行了，平行的时候，我的方法就跟那里说到的不太一样，我是为了省事儿，直接用4个顶点和对应线段之间的距离最短的来更新答案，其他就没什么不同了。还有就是这个题可以不求凸包，只需要选一个内部的点，然后根据其他点跟这个点连线的极角按照逆时针方向来排序就好。具体的看看代码来理解下吧</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
const double eps = 1e-9;
using namespace std;
const int N=10005;
int dcmp(double x)//精度比较
{
    if (x &lt; -eps) return -1;
    else if (x &gt; eps) return 1;
    else return 0;
}


double add(double a, double b)//考虑到精度的加法
{
    if (abs(a + b) &lt; eps * (abs(a) + abs(b))) return 0;
    return a + b;
}


struct Point//也可看做向量
{
    double x,y;
    Point() {}
    Point(double x,double y) : x(x),y(y){}
    Point operator + (Point p) {return Point(add(x, p.x),add(y, p.y)); }//向量 + 向量 = 向量
    Point operator - (Point p) {return Point(add(x, -p.x),add(y, -p.y)); } // 向量 - 向量 = 向量
    Point operator / (double d) {return Point(x/d, y/d);}
    bool operator &lt; (const Point p) const {return dcmp(x - p.x) &lt; 0 || dcmp(x - p.x) == 0 &amp;&amp; dcmp(y - p.y) &lt; 0; } //字典序比较，重定义&lt;
    bool operator == (const Point p) const {return dcmp(x - p.x) == 0 &amp;&amp; dcmp(y - p.y) == 0; }//重定义 ==
    bool operator &gt; (const Point p) const {return dcmp(x - p.x) &gt; 0 || dcmp(x - p.x) == 0 &amp;&amp; dcmp(y - p.y) &gt; 0;}
    double dot(Point p) {return add(x * p.x, y * p.y); }//点积
    double det(Point p) {return add(x * p.y, -y * p.x); }//叉积,旋转方向取逆时针
    double length() {return sqrt(x*x + y*y); }//向量长度
    double Angle() {return atan2(y, x);}//极角
    Point Rotate(double rad) {return Point(add(x * cos(rad),- y * sin(rad)), add(x * sin(rad), y * cos(rad))); }//逆时针旋转rad
    Point Normal() {return Point(-y / length(), x / length()); }//求单位法向量
};
typedef Point Vector;
Point a1[N],a2[N],p;
double Area(Point a, Point b, Point c)
{
  return (b-a).det(c-a);
}

double DisToSeg(Point A, Point B, Point P)
{
  if (A == B) return (P-A).length();
    Vector v1 = B - A, v2 = P - A, v3 = P - B;
    if (dcmp(v1.dot(v2)) &lt; 0) return v2.length();
    else if (dcmp(v1.dot(v3)) &gt; 0) return v3.length();
    else return fabs(v1.det(v2) / v1.length()) ;
}
double RotatingJam(int p0, int q0, int n, int m,Point a[], Point b[])
{
  int p = p0, q = q0;
  double ans = (a[p] - b[q]).length();
  while (dcmp(Area(a[p], a[(p+1)%n], b[q]) - Area(a[p], a[(p+1)%n], b[(q+1)%m])) &lt; 0)
  {
      int next = (q+1)%m;
      ans = min(ans,min(DisToSeg(b[q], b[next], a[(p+1)%n]), DisToSeg(b[q], b[next], a[p])));
      q = next;
  }
  int next = (p+1)%n;
  ans =  min(ans, DisToSeg(a[p], a[next], b[q]));
  if (dcmp(Area(a[p], a[next], b[q]) -Area(a[p], a[next], b[(q+1)%m])) == 0)
  {
      ans = min(ans, min(DisToSeg(b[q], b[(q+1)%m], a[p]),min(DisToSeg(b[q], b[(q+1)%m], a[next]),DisToSeg(a[p], a[next], b[(q+1)%m]))));
  }
  p = next;
  while (p!=p0)
  {
      while (dcmp(Area(a[p], a[(p+1)%n], b[q]) - Area(a[p], a[(p+1)%n], b[(q+1)%m])) &lt; 0)
      {
          int next = (q+1)%m;
          ans = min(ans,min(DisToSeg(b[q], b[next], a[(p+1)%n]), DisToSeg(b[q], b[next], a[p])));
          q = next;
      }
      int next = (p+1)%n;
      ans =  min(ans, DisToSeg(a[p], a[next], b[q]));
      if (dcmp(Area(a[p], a[next], b[q]) -Area(a[p], a[next], b[(q+1)%m])) == 0)
      {
          ans = min(ans, min(DisToSeg(b[q], b[(q+1)%m], a[p]),min(DisToSeg(b[q], b[(q+1)%m], a[next]),DisToSeg(a[p], a[next], b[(q+1)%m]))));
      }
      p = next;
  }
  return ans;
}
int ConvexHull(Point* p,int n, Point* ch)
{
    sort(p,p+n);
    int m = 0;
    for (int i = 0; i &lt; n ; i ++)
    {
        while (m &gt; 1 &amp;&amp; (ch[m-1] - ch[m-2]).det(p[i] - ch[m-2]) &lt;= 0) m --;
        ch[m++] = p[i];
    }
    int k = m;
    for (int i = n-2; i &gt;= 0; i--)
    {
        while (m &gt; k &amp;&amp;(ch[m-1] - ch[m-2]).det(p[i] - ch[m-2]) &lt;= 0) m--;
        ch[m++] = p[i];
    }
    if (n &gt; 1) m--;
    return m;
}
Point Hulla[N],Hullb[N];
int main()
{
  int n,m;
  while (scanf("%d%d", &amp;n, &amp;m))
  {
      if (n==0 &amp;&amp; m==0) break;
      p = Point(0,0);
      for (int i = 0; i &lt; n; i++)
      {
          scanf("%lf%lf", &amp;a1[i].x, &amp;a1[i].y);
          p = p + a1[i];
      }
      for (int i = 0; i &lt; m; i++)
      {
          scanf("%lf%lf", &amp;a2[i].x, &amp;a2[i].y);
          p = p + a2[i];
      }
      int nn = ConvexHull(a1, n, Hulla);
      int mm = ConvexHull(a2, m, Hullb);
      int min1 = 0,max2 = 0;
      for (int i = 1; i &lt; nn; i++)
          if (Hulla[min1] &lt; Hulla[i])
              min1 = i;
      for (int i = 1; i &lt; mm; i++)
          if (Hullb[max2] &gt; Hullb[i])
              max2 = i;
      double ans = RotatingJam(min1, max2, nn, mm, Hulla, Hullb);
      printf("%.5f\n",ans);
  }
  return 0;
}
</code></pre>

<p><a href="/blog/archives/">&lt;&ndash;Back</a></p>
]]></content>
  </entry>
  
</feed>
