<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 二分答案 | hnnWang's Blog]]></title>
  <link href="http://whn757397540.github.io/tags/er-fen-da-an/atom.xml" rel="self"/>
  <link href="http://whn757397540.github.io/"/>
  <updated>2015-02-21T01:42:36+08:00</updated>
  <id>http://whn757397540.github.io/</id>
  <author>
    <name><![CDATA[hnnWang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[树状数组以及线段树总结]]></title>
    <link href="http://whn757397540.github.io/blog/2015/02/20/shu-zhuang-shu-zu-yi-ji-xian-duan-shu-zong-jie/"/>
    <updated>2015-02-20T23:12:12+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/02/20/shu-zhuang-shu-zu-yi-ji-xian-duan-shu-zong-jie</id>
    <content type="html"><![CDATA[<p>大年初一初二两天，除了玩儿，也就看了看这些，zkw线段树看了看，想了想还是放弃了；二维线段树看了看，马马虎虎敲了几道题，规范了下二维线段树的代码；二维树状数组重新回顾了一下，其实跟一维树状数组是完全一样的；然后重新看了看书上的树状数组，也是有一些收获的，接下来就谈一谈！</p>

<!--more-->


<p>这次先把该说的说了，最后集中看题。</p>

<p>首先，线段树我就不多做介绍了,只是来介绍下二维线段树的写法：二维线段树，简单来说，就是树套树，一个线段树的域是值，另一个线段树的域是那个线段树。具体的写法一会儿看我做的最后一道二维线段树的题目的代码，那时我整理过姿势后的板子！这里说下思路，就是通过第一个树来建树（域是线段树的树），这棵树维护的是第一维的区间，然后对应再每一个节点上建立一个线段树（域是值的树，假如称它为子树），这个维护的是第二位的区间；也就是说，子树是嵌套再外围的线段树里面的；其实不管是建树，更新还是查找，都是一棵树套一棵树，这些具体需要看着代码来理解会比较好，这里要说的一点，就是更新的时候，以单点更新为例，因为你要找到(x,y)这个点，我们想一下1维线段树，只需要找到目标节点更新值，然后递归更新回去就好；类比下二维，一样也应该是找到目标节点然后更新值，然后递归更新回去，但是关键就是，这个点除了要再第二维坐标上更新，还得在第一维坐标上更新，而且你找目标节点的时候，也不是只是l == r == y就好，还需要注意第一维坐标必须是在x处，但是又不能值更新第一维坐标是x的线段树，那么怎么办呢？其实看看代码就知道了，就是再更新的第一维的区间不是[x,x]，而是包含[x,x]区间的时候，记得在找到y这个位置的时候，更新下第一维的值就好！说的有点乱，还是等一会儿看代码好一些！</p>

<p>另外，zkw线段树放弃了，但是也不见得以后也不会看，只不过现在没有那个时间取研究而已！</p>

<p>接着，关于树状数组，我在之前的博客里面有讲过,<a href="http://hnnwang.github.io/blog/2014/07/23/shu-zhuang-shu-zu-zong-jie/">链接在这里</a>,里面提到了利用树状数组进行单点修改，区间查询、区间修改，单点查询、区间修改，区间查询的方法，但是那里面的区间修改，区间查询的方法，利用的是差分的思想，这里再来说一个再《挑战程序设计竞赛》中提到的多项式的方法，还是以<a href="http://poj.org/problem?id=3468">poj3468</a>为例，这个题在之前那个博客里面也有，那里面有利用差分方法的代码，这道题就是简单的一道区间修改区间查询的问题，我们进行如下推导：</p>

<p>如果给区间[l,r]同时加上x的话，那么每个节点的值将如何变化呢？我们设</p>

<p>s(i) = 加上x之前的sigma(a[1……i])；</p>

<p>ss(i) = 加上x之后的sigma(a[1……i])；</p>

<p>那么我们就有</p>

<p>i &lt; l            →     ss(i) = s(i);//区间里面的东西没有被改变</p>

<p>l &lt;= i &lt;= r   →     ss(i) = s(i) + (i-l+1) = s(i) + x<em>i - x</em>(l-1);</p>

<p>i > r        →     ss(i) = s(i) + x*(r-l+1)</p>

<p>那么下面我们如果及sum(bit, i)为树状数组bit的前i项和。我们构建两个树状数组bit0和bit1，并且设</p>

<p>sigma(a[1..i]) = sum(bit1,i)*i + sum(bit0,i);</p>

<p>那么再[l,r]区间上同时加上x就可以看成是</p>

<ul>
<li><p>在bit0的l位置加上-x(l-1);//对应上面第二条的-x*(l-1)</p></li>
<li><p>在bit1的l位置加上x ;//在l之后(包括l)，每个都多加一个x</p></li>
<li><p>在bit0的r+1位置加上xr；//在i>r之后的式子中，跟在bit0的中加上的那个式子相比，少一个xr，所以加上xr，以保证再这之后的计算都是算的x*(r-l+1);</p></li>
<li><p>在bit1的r+1位置加上-x；在r+1之后(包括r+1)，每一个都减一个x，跟之前加的那个x抵消，从而达到指示[l,r]区间加的目的</p></li>
</ul>


<p>这4个操作。因此，查询和更新的操作都可以在O（logn）的时间里完成。</p>

<p>更一般的，如果操作得到的结果可以用i的n次多项式来表示的话，那么就可以使用n+1个树状数组来进行维护了！至于代码就不贴了，这个只要推出公式来就简单了！</p>

<p>至于二维树状数组，非常简单，根本不用说。只要一会看一下一道题的代码就知道了，其实就是再一维树状数组的基础上加上了一维。</p>

<p>好了，接下来进入题目环节，简单的讲解几道题就好！</p>

<p>首先，一维线段树的，也是书上的例题</p>

<p><a href="http://poj.org/problem?id=2991">POJ 2991 Crane</a></p>

<p>这道题稍微用到了一些计算几何的知识，也就是个旋转而已；来说下怎么建树和维护，建树维护下面两个域: 一是第一条线段起点指向最后一条线段终点的向量； 二是（如果该节点有儿子节点），右儿子节点绕左儿子节点逆时针旋转的角度！</p>

<p>有了以上那两个域，就可以利用计算几何中的旋转公式来维护线段树了，这里说下计算几何上的旋转公式以及其推导方法！</p>

<p>假如向量p = (x,y) 绕原点旋转角度 β 到向量q = (x&#8217;, y&#8217;)，我们把直角坐标转换为极坐标，那么就应该是p=(lcosα， lsinα） 转动 β 到 q=(lcos(α+β), lsin(α+β)）， 运用三角函数和差公式可以得到 q = (lcosαcosβ - lsinαsinβ， lsinαcosβ + lcosαsinβ) = (xcosβ - ysinβ， xsinβ + ycosβ), 这可得旋转公式！</p>

<p>具体的维护细节就不说了，自己思考思考把，我的<a href="/acm/poj/poj2991/">参考代码</a>挂出来</p>

<p>然后，二维线段树：</p>

<p><a href="http://poj.org/problem?id=2155">poj2155 Matrix</a></p>

<p>这道题，解法十分简单，是道基础题，用到了一个思想，就是对于区间的更新，可以不用懒标记，只是重新维护一个域，然后不下传，最后求结果的时候从最底层回溯上去，或者在从上向下找结果的时候，顺便根据维护的那个域进行更新。这道题就是，因为操作一次就改变一次0或者1，所以只需要找到操作的区间，然后记录次数，最后算结果的时候看找结果总共操作了多少次，从而求出答案，（当然，不用记录次数，直接跟1取异或即可），这是我的第一个<a href="/acm/poj/poj2155">代码</a>,有点丑，必经是自己写的,还是第一次，不要以这个为参考。</p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4819">hdu4819 Mosaic</a></p>

<p>这是一道简单的二维线段树RMQ问题，就是利用二维线段树更新的思想进行更新，参考一维线段树的RMQ的方法就好，注意在前面说的那几点。这道题的<a href="/acm/hdu/hdu4819/">代码</a>是经过我的整理的，虽然很麻烦，但也应该很清楚。</p>

<p>还有一道题，也是RMQ的，不打算写出来了，白白浪费了我好久的时间，总感觉自己没错，但是总也过不了，后来拿网上题解的代码去交，百度前2页的都过不了，我就郁闷了，怀疑是那道题的数据或者什么的出现了问题，后来放弃了，上面那个hdu4819就是我放弃这个之后重新找的一道题，由于都是RMQ，所以也差不多啦！</p>

<p>然后，二维树状数组，一道基础题：</p>

<p><a href="http://poj.org/problem?id=1195">POJ1195 Mobile phones</a></p>

<p>题意简单，代码也简单，不讲了，就挂个<a href="/acm/poj/poj1195/">代码</a>,纯属为了给一个二维树状数组的例子</p>

<p>最后，K-th Number问题：</p>

<p><a href="http://poj.org/problem?id=2104">poj2104 K-th Number</a></p>

<p>这也是桶分法，平方分割那一节的例题，这里说两种方法。</p>

<p>第一是平方分割（桶分）法.首先，我们需要转换一下问题，直接去求某个区间的第k大数是很难的，但是，它只有100000个数，我们可以先假定一个数，然后看它是第几大数，用二分答案法来找到答案。（当然，这个得要求是有序的），这样，我们就变成了求k是要求区间的第几大数这个问题，接下来我们要想怎么解决这个问题。</p>

<p>先把所有的数分到几个桶里，每个桶的容量都是一样的，然后对每个桶里数进行排序；之后查询的时候，假如区间为[l,r]，没有完全被包含再[l,r]内的区间（最多2个）直接暴力判断，包含在内的，在排好序的桶里面用二分法比x小的总共有多少个。</p>

<p>具体复杂度看桶的大小而定，设桶的大小为B,则复杂度为O（(n/B)logB + B）;</p>

<p>总体算法的复杂度为O(nlogn + mlogn*((n/B)logB + B)));</p>

<p>第二种方法，线段树，或者说，归并树。这次的线段树不是动态的，而是静态的，直接说说方法吧！</p>

<p>线段树存储一个域，这个域存的是对应区间排好序的数组（<strong>是数组</strong>），要计算再某个区间中不超过x的数的个数，只需要递归的进行下面的操作就行：</p>

<ul>
<li><p>如果所给区间与当前节点区间没交集，返回0；</p></li>
<li><p>如果所给区间完全包含当前节点对应的区间，那么就使用二分法对该点上保存的数组进行查找；</p></li>
<li><p>否则对两个儿子递归的进行计算求得结果；</p></li>
</ul>


<p>时间复杂度是O(nlogn + mlog<sup>3n</sup>).</p>

<p>两种方法的参考代码都在<a href="/acm/poj/poj2104/">这里</a></p>

<p>这里提一下，再第二种方法里面用到的一个STL函数，merge.</p>

<p>merge(a, a+n, b, b+n, c) 进行的操作是把数组a和数组b的前n项合并，存在数组c中！</p>

<p>还有，《统计的力量》中也有提到这个，不过我没太看懂怎么去敲！</p>

<p>好了，这次就到这里吧！</p>

<p><a href="/blog/archives">戳我返回</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二分查找及其应用总结]]></title>
    <link href="http://whn757397540.github.io/blog/2015/02/13/er-fen-cha-zhao-ji-qi-ying-yong/"/>
    <updated>2015-02-13T14:26:37+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/02/13/er-fen-cha-zhao-ji-qi-ying-yong</id>
    <content type="html"><![CDATA[<p>二分搜索法，是通过不断缩小解可能存在的范围，从而求的问题最优解的方法。经常会出现的是二分搜索和其他算法结合的题目。</p>

<p>(PS:有关二分姿势的选取，可以看看<a href="http://blog.csdn.net/u012139398/article/details/38637311">峰霸这短小精悍的博文</a>)</p>

<!--more-->


<p>1.首先，最基本的，从有序数组中查找某个值。</p>

<p>这个问题，再stl中有lower_bound()和upper_bound()来解决，这里给出一个内部算法结构，再简单说说STL的用法</p>

<pre><code class="c++">int lowerBound(int a[], int n, int aim)//返回值是&gt;=aim的第一个位置，如果不存在，返回最后一个元素之后的一个位置（也就是n）
{
    int l = -1, r = n;//初始化解的存在范围，这里求lower_bound的时候采取的是左闭右开的

    while(r-l &gt; 1)//重复循环，一知道解的范围足够小
    {
        int mid = (l+r)/2;
        if (a[mid] &gt;= aim)//如果mid满足条件
            r = mid;//解的存在范围变为(l, mid]
        else
            l = mid;//解的存在范围变为(mid, r]
    }
    return r;
}
</code></pre>

<p>当然，这只是针对整数的情况，而根据实际情况，还会有可能是其他的元素，或者其他的要求，要视情况而定。不再多说，提一下STL库里的两个函数的用法:</p>

<p>首先，lower_bound(a, a+n, d)返回的是数组a里面（a可以是任何有序的数组）,元素值>=d的第一个元素的位置，如果不存在，则返回的是最后一个元素之后的第一个位置，<strong><strong>注意，他的返回值是指针！</strong></strong></p>

<p>然后，upper_bound(a, a+n, d)，与lower_bound（）类似，不过这里找的是>d的第一个元素的位置，不包括等于，不存在的情况与lowerbound相同，返回值也是<strong>指针</strong></p>

<p>2.假定一个解并判断是否可行（二分答案法）</p>

<p>这种解题方法并不是第一次用了，什么情况下用这种方法呢？如果在求解<strong>最大化或最小化的问题中</strong>，能够<strong>比较简单的判断</strong>条件是否满足，那么使用二分搜索法就可以很好得解决问题。</p>

<p>举个简单的例子：</p>

<p><a href="http://poj.org/problem?id=1064">POJ 1064 Cable master</a></p>

<p>我们如果假定答案是x的话，那么每条绳子最多可以切成floor(L[i] / x)段，那么我们只需要判断所有的绳子最多可以切成多少段，如果能切得比K段更多（或者相等），那么就能知道有可能切得更长，这个判断就对应了之前代码的a[mid] >= aim的条件了；同样，反之就说明切得太长了，需要往短了切。所以呢，参考下之前的代码，很容易能写出这一题的代码！我的<a href="/acm/poj/poj1064/">代码</a>仅供参考。</p>

<p>这种类型的题目还很多，记住两个要点：<strong>最大化或者最小化问题中</strong>;<strong>能够比较简单地判断条件是否满足</strong>；在满足以上两个条件的情况下，二分搜索法是一个很好的办法，复杂度是O（判断的复杂度×log(maxans)）.</p>

<p>3.最大化最小值问题</p>

<p>类似最大化最小值或者最小化最大值的问题，通常用二分搜索法就可以很好的解决（实际上，跟2的二分答案法是差不多的）。不多说，挂个例题和解法就过了。</p>

<p><a href="http://poj.org/problem?id=2456">POJ 2456 Aggressive cows</a></p>

<p>定义一个canMake(int d)函数,代表可以安排牛的位置使离得最近的互相仇恨的牛的距离不小于d。这个问题只用贪心法就很容易判断了（具体过程不说了）。之后进行二分答案就好！</p>

<p>参考<a href="/acm/poj/poj2456/">代码</a></p>

<p>4.最大化平均值</p>

<p>这种题呢，说实话，还没有太多印象遇到过，不过既然书上提到了，这里就来讲一讲罗！先来看问题：</p>

<p>有n个物品的重量和价值分别为wi和vi，要从中选出k个物品是的单位重量的价值最大。</p>

<p>这个问题，我刚开始看到的想法就是直接贪心按照单价排序不就好了嘛，可是后来发现这种贪心是错误的（给的样例就能证明）。那么我们可以这样来假设，定义:</p>

<p>C(x) = 可以选择使得单位重量的价值不小于x。</p>

<p>那么原问题就等于是求满足C(x)的最大的x。那么解决了判断问题，就又可以二分答案了。关键我们是怎么判断C(x)呢？假设我们选了某个物品的集合S那么它们的单位重量的价值就是 sigma(vi)/sigma(wi)。</p>

<p>因此就变成了判断是否存在S满足下面的条件</p>

<p>sigma(vi)/sigma(wi) >= x;</p>

<p>把这个不等式变形就得到</p>

<p>sigma(vi - x*wi) >= 0.</p>

<p>因此，我们只需要对vi-x*wi的值进行排序贪心的选取，判断从大到小前k个的和不小于0就行了。每次判断的复杂度是O（nlogn）.</p>

<p>通过上面的内容，我们会发现，不管怎么样，用到二分答案的时候，我们需要先找到一个判断条件，然后对答案进行二分。二分，更重要的是这种思想，它不仅仅是能够搜索数值，还能有更广阔的应用！</p>

<p><a href="/blog/archives">&lt;&ndash;返回</a></p>
]]></content>
  </entry>
  
</feed>

