<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 最大流 | hnnwang's Blog]]></title>
  <link href="http://whn757397540.github.io/tags/zui-da-liu/atom.xml" rel="self"/>
  <link href="http://whn757397540.github.io/"/>
  <updated>2015-08-10T13:04:28+08:00</updated>
  <id>http://whn757397540.github.io/</id>
  <author>
    <name><![CDATA[hnnwang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[最小割的介绍及应用]]></title>
    <link href="http://whn757397540.github.io/blog/2015/03/14/zui-xiao-ge-de-jie-shao-ji-ying-yong/"/>
    <updated>2015-03-14T18:55:31+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/03/14/zui-xiao-ge-de-jie-shao-ji-ying-yong</id>
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=3469">POJ 3469 Dual Core CPU</a></p>

<p>这是一个典型的最小割问题，不再陈述题意。</p>

<!--more-->


<p>这里先介绍一下割的概念。所谓图的割，就是指对于某个定点几何S（属于V），从S出发指向S外部的那些边的几何，记作割（S, V/S）。这些边的容量之和被称为割的容量。如果有s∈S，t∈V/S，那么此时的割又可以称为s-t割。</p>

<p>好好理解下割的概念，然后，记住一个定理：一个图从s到t的最大流，等于s-t的最小割。这个被称为最大流最小割定理。</p>

<p>像这道题这种<strong>用最小的费用将对象划分成两个集合的问题，常常可以转换成最小割问题后顺利解决</strong>，本题就是一个非常典型的例子。（要不本来我还不知道最小割怎么来用呢，算是第一次遇到用最小割的题目吧！）</p>

<p>这道题，就可以记在A上执行的模块的几何为S，在B上执行的模块的几何为T，并加一个虚拟的源点s在S中和一个虚拟的汇点t在T中。我们很容易知道，花费的总和是</p>

<p>sigma(A[i],i∈S) + sigmasigma(B[i],i∈T) + sigma（wi,ai属于S，bi属于T） + sigma（wi,ai属于s，bi属于t）.</p>

<p>我们需要构建一个图，使得花费的综合等价于图的割的容量，那么我们就可以通过求最小割来求最小花费了。关键是图怎么构？这是一个问题。</p>

<p>我们要明确一个方向，我们要做的是让图的割等于花费，也就是让从S到T的各个边的权值和等于上面的式子，那么实际上还是蛮简单的，一个一个来考虑就好了，对于式子的第一项sigma(A[i],i∈S),首先，我们确定i∈S，我们只需要从S指向T就好，所以只需要从每个模块向t连一条容量为A[i]的边就好；同样，对于第二项，i属于T，所以只要有一个从S中指出来的边指向i就好，所以就从s指向每个模块一条容量为B[i]的边；最后，第三项，ai∈S，bi∈T，记住目的是连从S到T的边，所以连的应该是从ai到bi的边，容量为wi，同理，第四项只是把第三项的边反过来就好。</p>

<p>这样我们构完图，这个图的割就代表着花费，那么最小割自然就代表着最小花费了！而通过最大流最小割定理我们又知道，最小割等于最大流，所以我们只需要求从s到t的最大流即可。 代码如下</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 22222;

const int INF = 0x3f3f3f3f;
struct Edge{
    int to,cap, rev;
    Edge(int to, int cap, int rev):to(to), cap(cap), rev(rev){}
};

vector&lt;Edge&gt; G[maxv];
int level[maxv];//¶¥µãµ½Ô´µãµÄ¾àÀë±êºÅ
int iter[maxv];//µ±Ç°»¡£¬ÔÚÆäÖ®Ç°µÄ±ßÒÑ¾­Ã»ÓÐÓÃÁË

void addEdge(int from, int to, int cap)
{
    G[from].push_back(Edge(to, cap, G[to].size()));
    G[to].push_back(Edge(from, 0, G[from].size()-1));
}

void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for (int i = 0; i &lt; G[v].size(); i++)
        {
            Edge &amp;e = G[v][i];
            if (e.cap&gt;0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

int dfs(int v, int t, int f)
{
    if(v == t)
        return f;
    for (int &amp;i = iter[v]; i &lt; G[v].size(); i++)
    {
        Edge &amp;e = G[v][i];
        if (e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if (d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

int max_flow(int s, int t)
{
    int flow = 0;
    while(true)
    {
        bfs(s);
        if (level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while ((f = dfs(s, t, INF)) &gt; 0)
            flow += f;
    }
}

vector&lt;int&gt; rec[maxv];
int main()
{
    int n,m;
    scanf("%d%d", &amp;n, &amp;m);
    int s = 0, t = n+1;
    for (int i = 1; i &lt;= n; i++)
    {
        int a,b;
        scanf("%d%d", &amp;a, &amp;b);
        addEdge(s, i, b);
        addEdge(i, t, a);
    }
    for (int i = 1; i &lt;= m; i++)
    {
        int a,b,w;
        scanf("%d%d%d", &amp;a, &amp;b, &amp;w);
        addEdge(a,b,w);
        addEdge(b,a,w);
    }

    printf("%d\n", max_flow(s,t));
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图论总结(三)]]></title>
    <link href="http://whn757397540.github.io/blog/2015/03/14/tu-lun-zong-jie-san/"/>
    <updated>2015-03-14T18:54:30+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/03/14/tu-lun-zong-jie-san</id>
    <content type="html"><![CDATA[<h5>二分图匹配问题</h5>

<!--more-->


<p>今天一整天就做了三道题，二分图匹配和网络流的问题，感觉一些建图方式还是非常巧妙的。这次的总结写在前面，题写在后面吧，因为有些题用到了总结中的东西。</p>

<p>首先，解释一下什么叫做匹配，图G=（V,E）的匹配就是在G中两两没有公共端点的边的集合M（M属于E）。(匹配数就是|M|)。说得通俗一点，就是集合中的点两两配对，最大匹配数就是最多能配成多少对。当最大匹配数|M|manzu 2|M| = |V|(也就是所有的点都配对了)时，又称为完美匹配。</p>

<p>然后我们思考一下，怎么去求匹配数？考虑一下，事实上我们可以通过最大流来求匹配数，怎么做呢？试想一下我们这样构图，把原图中所有的无向边改成有向边，方向从顶点集U->V，容量为1，那么这个二分图匹配问题是不是就转化成了多个源点（U里面的点，每个源点的最大流出量为1）到多个汇点（V里面的点，每个汇点的最大流入量为1）的问题了？这种问题，通过之前对最大流的总结我们知道怎么解决了，设立超级源点S和超级汇点T呀，这样从S流向T的最大流就是原图的最大匹配数了。U->V的流量为正的边的几何就是最大匹配。算法复杂度为（O(|V|||E)）。</p>

<p>利用所有边的容量都是1以及二分图的性质，我们可以的到匈牙利求最大二分匹配的算法（这个一会给代码）。</p>

<p>接下来，再来说几条可能用到的概念，<strong>注意区分</strong>，在图G = (V,E) 中：</p>

<ul>
<li>匹配…………………………在G中两两没有公共端点的边的几何M（M属于E）。</li>
<li>边覆盖……………………G中的任意顶点都至少是F中某条边的端点的边的集合F（F属于E）。</li>
<li>独立集……………………在G中两两互不相连的顶点集合S（S属于V）</li>
<li>顶点覆盖…………………G中的任意边都有至少一个端点属于S的顶点集合S（S属于V）。</li>
</ul>


<p>单单是看不太容易记住，画个图理解一下就好，自行画图吧！</p>

<p>针对匹配，有最大匹配；针对边覆盖，有最小边覆盖；针对独立集，有最大独立集；针对顶点覆盖，有最小顶点覆盖。（搞清楚这几个概念，是有用的）</p>

<p>**以上几者之间存在如下的关系：</p>

<ul>
<li>对于不存在孤立点的图，最大匹配数+最小边覆盖数 = |V|；</li>
<li>最大独立集数+最小顶点覆盖数 = |V|；</li>
<li>对于二分图来说，有最大匹配数 = 最小顶点覆盖数；**</li>
</ul>


<p>知道以上几个关系，我们就可以通过求二分图的最大匹配数来求出剩下的3项了，这在有些时候是用的到的</p>

<p>看完了最小费用流，终于可以接着写了：</p>

<blockquote><p>常见的二分图匹配（2种）</p>

<blockquote><p>针对无权图的，需要求出包含变数最多的匹配，而二分图最大基数匹配 + 这种问题上面个说的就是，不在赘述了。</p>

<p>针对带权图的，需要求出边权之和的尽量大的匹配，有些题目要求这个匹配本身是完美匹配（即每个点都被匹配到），而有些题目并不对边的数量做出要求，只要权和最大就行，</p>

<blockquote><p>最大权完美匹配 + 这种问题和最大基数匹配类似，图中所有边的费用取反，然后其他边费用为0。如果从s出发的所有弧并不是全部满载，则说明完美匹配不存在，问题无解；否则原图中所有流量为1的弧对应最大权完美匹配 + 用上面的方法也可以求解第二种情况，即匹配边数没有限制的最大权匹配，只需要在求解s-t最小费用流的过程中记录下流量为0,1,2,3…………时的最小费用流，然后加以比较。 +</p></blockquote></blockquote></blockquote>

<p>接下来我们看例题：</p>

<p><a href="http://poj.org/problem?id=3041">POJ3041 Asteroids</a></p>

<p>题意：在N*N的网络中有K颗小行星。小行星i的位置在（R[i],C[i]）。有一台强力激光炮，一炮可以轰掉一整排或者一整列的小行星，问轰掉所有的小行星最少需要开几炮？</p>

<p>这道题，如果以正常的思维去想，把小行星当成点的话，那不是非常好做，但是我们可以换个思维方式去想，假如我们把行和列当成点，把小行星当成边来构图，那么跟每个点相邻的边都会被那个点所代表的那一行或者列的激光小灭掉，所以我们只需要知道要包括所有的边，至少需要几个点就好，这不正好是最小顶点覆盖吗？而这个又恰好是一个二分图，所以，我们就只需要求出以行列为点，小行星为边（(r,c)位置的小行星从第r行指向第c列）的图的最大匹配数即可。代码很简单，我这里有一份ISAP的最大流代码，还有一份匈牙利求最大二分匹配的代码，都挂出来。</p>

<p>ISAP求二分匹配</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include&lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 10000;
const int maxe = 55555;
const int INF = 0x3f3f3f3f;
struct Edge{
    int from, to, cap, flow;
    Edge(int u, int v, int c, int f): from(u), to(v), cap(c),flow(f){}
};

vector&lt;Edge&gt; edges;
vector&lt;int&gt; G[maxv];
int a[maxv];//µ±Ç°½ÚµãÄóÁ÷Á¿
int p[maxv];//¸¸Ç×½Úµã£¬»ØËÝÂ·¾¶ÓÃµ½
int d[maxv];//µ½ÖÕµã¾àÀë
int iter[maxv];//µ±Ç°»¡ÏÂ±ê
int num[maxv];
int nume;
void init(int n)
{
    for (int i = 0; i &lt; n; i++) G[i].clear();
    edges.clear();
}

void addEdge(int from, int to, int cap)
{
    edges.push_back(Edge(from, to, cap, 0));
    edges.push_back(Edge(to, from, 0, 0));
    nume = edges.size();
    G[from].push_back(nume-2);
    G[to].push_back(nume-1);
}


void bfs(int t)
{
    memset(d, -1, sizeof(d));
    d[t] = 0;
    queue&lt;int&gt; que;
    que.push(t);
    while(!que.empty())
    {
        int u = que.front();que.pop();
        for (int i = 0; i &lt; G[u].size(); i++)
        {
            Edge &amp;e = edges[G[u][i]^1];
            if (e.cap &gt; e.flow &amp;&amp; d[e.from] &lt; 0)
            {
                d[e.from] = d[u] + 1;
                que.push(e.from);
            }
        }
    }
}

int add(int s, int t)
{
    int u = t,df = INF;
    //´Ó»ãµãµ½Ô´µãÍ¨¹ýp×·×ÙÔö¹ãÂ·¾¶£¬dfÎªÒ»Â·ÉÏ×îÐ¡µÄ²ÐÁ¿
    while(u != s)
    {
        Edge &amp;e = edges[p[u]];
        df = min(df, e.cap - e.flow);
        u = edges[p[u]].from;
    }
    u = t;
    //´Ó»ãµãµ½Ô´µã¸üÐÂÁ÷Á¿
    while(u != s)
    {
        edges[p[u]].flow += df;
        edges[p[u]^1].flow -= df;
        u = edges[p[u]].from;
    }
    return df;
}


int max_flow(int s, int t)
{
    int flow = 0;
    bfs(t);
    memset(num, 0, sizeof(num));
    for (int i = 0; i &lt;= t; i++)
        num[d[i]]++;
    int u = s;
    memset(iter, 0, sizeof(iter));
    while(d[s] &lt;= t)
    {
        //cout&lt;&lt;d[s]&lt;&lt;endl;
       // system("pause");
        if (u == t)
        {
            flow += add(s, t);
            u = s;
        }
        bool flag = false;
        for (int i = iter[u]; i &lt; G[u].size(); i++)
        {
            Edge &amp;e = edges[G[u][i]];
            if (e.cap &gt; e.flow &amp;&amp; d[u] == d[e.to] + 1)
            {
                flag = true;
                p[e.to] = G[u][i];
                iter[u] = i;
                u = e.to;
                break;
            }
        }
        if (!flag) // restart
        {
           // cout&lt;&lt;1&lt;&lt;endl;
            int m = t;
            for (int i = 0; i &lt; G[u].size(); i++)
            {
                Edge &amp;e = edges[G[u][i]];
                if (e.cap &gt; e.flow)
                    m = min(m, d[e.to]);
            }
            if (--num[d[u]] == 0)
                break;//gapÓÅ»¯
            num[d[u] = m+1] ++;
            iter[u] = 0;
            if (u != s)
                u = edges[p[u]].from;
        }
    }
    return flow;
}

int main()
{
    int n,k;
    scanf("%d%d", &amp;n, &amp;k);
    for (int i = 0; i &lt; k; i++)
    {
        int r,c;
        scanf("%d%d", &amp;r, &amp;c);
        addEdge(r,c+n,1);
    }
    int s = 0, t = 2*n+1;
    for (int i = 1; i &lt;= n; i++)
    {
        addEdge(0,i,1);
        addEdge(i+n,t,1);
    }
    printf("%d\n", max_flow(s,t));

    return 0;
}
</code></pre>

<p>匈牙利二分匹配</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 10000;
const int maxe = 55555;
const int INF = 0x3f3f3f3f;
int V;
vector&lt;int&gt; G[maxv];
int match[maxv];
bool used[maxv];

void addEdge(int u, int v)
{
    G[u].push_back(v);
    G[v].push_back(u);
}

bool dfs(int v)
{
    used[v] = true;
    for (int i = 0; i &lt; G[v].size(); i++)
    {
        int u = G[v][i], w = match[u];
        if (w &lt; 0 || !used[w] &amp;&amp; dfs(w))
        {
            match[v] = u;
            match[u] = v;
            return true;
        }
    }
    return false;
}

int bipartite_matching()
{
    int res = 0;
    memset(match, -1, sizeof(match));
    for (int v = 1; v &lt;= V; v++)
    {
        if (match[v] &lt; 0)
        {
            memset(used, 0, sizeof(used));
            if (dfs(v))
                res++;
        }
    }
    return res;
}

int main()
{
    int n,k;
    scanf("%d%d", &amp;n, &amp;k);
    V = 2*n;
    for (int i = 0; i &lt; k; i++)
    {
        int r,c;
        scanf("%d%d", &amp;r, &amp;c);
        addEdge(r,c+n);
    }
    printf("%d\n", bipartite_matching());

    return 0;
}
</code></pre>

<p><a href="http://poj.org/problem?id=3057">POJ 3057 Evacuation</a></p>

<p>唔~~，这题我做了6个小时，中途还看了题解的思路，哎，真是</p>

<p>好了，来说题意：X*Y大的房子着火，给一个字符表格，‘X’代表墙,‘.’代表房子内空地，‘D’代表门。房子内所有的空地上都站着一个人，现在房子着火了，人要出来，每个房门1秒钟只能出一个人，人只能上下左右四个方向移动，每移动一个格子花费1秒钟，问：房间里所有人都出来，最少需要多长时间，如果有人出不来（四周都是墙），输出impossible。</p>

<p>这个我是实在没有一点构图的思路，最后还是参考了下题解，题解先给出一种方法，二分答案法，这里简单说下思路，很简单，先确定一个答案的范围（0–X*Y可以吧），然后，对于每个门，通过BFS求得所有能到达这个门的空地与门之间的距离，记录下来。然后检查是否存在一个空地不能到达任意一个门，如果存在，肯定是impossible；不存在，那么就肯定能出来。接下来就是求出来的时间，我们先假定一种答案然后判断在答案这种时间内，是否可以逃出。二分答案法就不用多说了，关键在于判断能否逃出的过程。对于一个特定的时间T，我们构图就会感到比较容易了，因为每秒钟每个门只能出来一个人，所以我们应该把门d分成：1秒钟的门d，2秒钟的门d，3秒钟的门d…………T秒钟的门d几种门，然后就是一个最大匹配数问题了。我们怎么连边呢？对于一个门d，假设他距离空地v的距离为dis[d][v],加入是t秒钟的门，那么哪些点可以连到这个门上呢？自然是dis[d][v]&lt;=t的点了。这样连了图以后，就求一下最大匹配数，看是否等于空地的总数即可。依次二分答案得到最终结果。代码就不挂了，根据这个思路自己写一写吧</p>

<p>这种方法呢，确实是可以的，不过还有更好的方法，因为我们仔细想一想，对于每一个T都要构图，重新计算二分图，我们重复计算了好多次，造成了大量的时间浪费。事实上，更好的方法是，我们确定一个有可能是答案的最小的t，然后构图（构图方法跟上面相同），求最大匹配数，比较得到的最大匹配数是否跟空地总数相等，如果不等，就把时间加一，这样只是再多加门的个数那么多个点，按照同样的规则连边，然后继续求二分匹配，不过要注意，不是重新求，而是在原来的基础上求。如果你用最大流的话，就相当于加了几条边，在原来的残余网络的基础上进行增广就好；如果你用的是匈牙利二分匹配的话，就更简单了，观察一下他的代码。他是按照顺序从一侧的顶点开始寻找增广路增广的，所以我们只需要从新加的那些顶点开始寻找增广路就好了。我用的是后者。</p>

<p>我在写的时候，犯了一些数组开小了,初始化不全面之类的错误，还有一些细节没有注意好，BFS刚开始写的有点问题，不过思路就是这个样子的，感觉想不到就是做的不够多练得不够多，不多讲了，上我自己的代码</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 10000;
const int maxe = 55555;
const int INF = 0x3f3f3f3f;
int V;
vector&lt;int&gt; G[maxv];
int match[maxv];
bool used[maxv];

void init(int n)
{
    for (int i = 1; i &lt;= n; i++)
        G[i].clear();

}
void addEdge(int u, int v)
{
    G[u].push_back(v);
    G[v].push_back(u);
}

bool dfs(int v)
{
    used[v] = true;
    for (int i = 0; i &lt; G[v].size(); i++)
    {
        int u = G[v][i], w = match[u];
        if (w &lt; 0 || !used[w] &amp;&amp; dfs(w))
        {
            match[v] = u;
            match[u] = v;
            return true;
        }
    }
    return false;
}

int bipartite_matching(int bg, int ed)
{
    int res = 0;
    for (int v = bg; v &lt;= ed; v++)
    {
        if (match[v] &lt; 0)
        {
            memset(used, 0, sizeof(used));
            if (dfs(v))
                res++;
        }
    }
    return res;
}

const int dd[4][2] = { {0, -1}, {1, 0}, {0, 1}, {-1, 0} };
char board[15][15];
int cnt[15][15];
int numd,nump;//分别指出口的数量和点的数量
int dis[150][150];
int X,Y;
void BFS(int x, int y)
{
    queue&lt;pair&lt;int, int&gt; &gt; que;
    int *tp = dis[cnt[x][y]];
    dis[cnt[x][y]][0] = 0;
    for (int i = 0; i &lt; 4; i++)
    {
        int nx = x + dd[i][0], ny = y + dd[i][1];
        if (nx &gt;= 0 &amp;&amp; nx &lt; Y &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; X &amp;&amp; board[nx][ny] == '.' &amp;&amp; tp[cnt[nx][ny]] &lt; 0)
        {
            tp[cnt[nx][ny]] =  1;
            que.push(make_pair(nx, ny));
        }
    }
    while(!que.empty())
    {
        int xx = (que.front()).first, yy = (que.front()).second; que.pop();

        for (int i = 0; i &lt; 4; i++)
        {
            int nx = xx + dd[i][0], ny = yy + dd[i][1];
            if (nx &gt;= 0 &amp;&amp; nx &lt; Y &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; X &amp;&amp; board[nx][ny] == '.' &amp;&amp; tp[cnt[nx][ny]] &lt; 0)
            {
                tp[cnt[nx][ny]] = tp[cnt[xx][yy]] + 1;
                que.push(make_pair(nx, ny));
            }
        }
    }
}


int main()
{
    int kase;
   /* freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);*/
    cin&gt;&gt;kase;
    while(kase--)
    {
        scanf("%d%d", &amp;Y, &amp;X);
        for (int i = 0; i &lt; Y; i++)
            scanf("%s", board[i]);
        memset(dis, -1, sizeof(dis));
        numd = 0, nump = 0;
        for (int i = 0; i &lt; Y; i++)
            for (int j = 0; j &lt; X; j++)
            {
                if (board[i][j] == '.')
                    cnt[i][j] = ++nump;
                else if (board[i][j] == 'D')
                    cnt[i][j] = ++numd;
            }

        for (int i = 0; i &lt; Y; i++)
            for (int j = 0; j &lt; X; j++)
                if (board[i][j] == 'D')
                    BFS(i,j);
       /*for (int i = 1; i &lt;= numd; i++)
        for (int j = 1; j &lt;= nump; j++)
                printf("%d%c", dis[i][j], j == nump ? '\n' : ' ');*/
        int ans = 0;
        for (int i = 1; i &lt;= nump; i++)
        {
            int tmp = INF;
            for (int j = 1; j &lt;= numd; j++)
            {
                if (dis[j][i] != -1)
                    tmp = min(tmp, dis[j][i]);
            }
            if (tmp &lt; 0 || tmp == INF)
            {
                ans = -1;
                break;
            }
            ans = max(ans,tmp);
            //cout&lt;&lt;ans&lt;&lt;endl;
        }
        if (ans  == -1)
            printf("impossible\n");
        else
        {
            for (int T = 0; T &lt; ans; T++)
                for (int i = 1; i &lt;= numd; i++)
                {
                    int pp = nump+T*numd+i;
                    for (int j = 1; j &lt;= nump; j++)
                        if (dis[i][j] &lt;= T+1 &amp;&amp; dis[i][j] &gt; 0)
                            addEdge(j, pp);
                }
            int bg = 1;
            int max_match = 0;
            memset(match, -1, sizeof(match));
            while(true)
            {
                V = nump+ans*numd;
                max_match += bipartite_matching(bg, V);
                if (max_match == nump)
                    break;
                ans++;
                for (int i = 1; i &lt;= numd; i++)
                {
                    int pp = nump+(ans-1)*numd+i;
                    for (int j = 1; j &lt; nump; j++)
                        if (dis[i][j] &lt;= ans &amp;&amp; dis[i][j] &gt; 0)
                            addEdge(j, pp);
                }
                bg = V+1;
                V += numd;
              //  cout&lt;&lt;max_match&lt;&lt;endl;
            }
            printf("%d\n", ans);
        }
        init(nump+ans*numd);
        memset(cnt, 0 ,sizeof(cnt));
        memset(board, 0,sizeof(board));
    }

   // system("pause");

    return 0;
}
</code></pre>

<p><a href="http://poj.org/problem?id=3281">POJ 3281 Dining</a></p>

<p>题意，共有F种中食物和D种饮料，农场里每头牛都有自己喜欢的食物和饮料（不一定只有一个），但每种食物或饮料最多只能分配给一头牛，问最多有多少头牛可以同时得到自己喜欢的饮料和食物？</p>

<p>这题的难点在于，他分的不只是一种东西，假如分的东西只有食物，那么我们就可以用二分匹配来做，但是，他分的东西还有饮料。那怎么办呢？自然是2个二分匹配啦！2个2分匹配怎么搞？唔~~，用网络流就很容易搞定了。我们这样建图。从源点指向食物（或者饮料，二者选其一），权值为1的边；从食物（或饮料）指向牛，权值为1的边；从牛指向牛，权值为1的边（因为这个相当于是牛这个顶点的容量是1，顶点有容量，就需要拆成2个点，所以是一头牛拆成2头牛），权值为1；从牛指向饮料（或者食物，跟前面相对），权值为1的边；从饮料（或者食物）指向汇点，权值为1的边。当然，食物饮料和牛之间的关系自然是题目中给出了。</p>

<p>下面是代码</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include&lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 10000;
const int maxe = 55555;
const int INF = 0x3f3f3f3f;
struct Edge{
    int from, to, cap, flow;
    Edge(int u, int v, int c, int f): from(u), to(v), cap(c),flow(f){}
};

vector&lt;Edge&gt; edges;
vector&lt;int&gt; G[maxv];
int a[maxv];//µ±Ç°½ÚµãÄóÁ÷Á¿
int p[maxv];//¸¸Ç×½Úµã£¬»ØËÝÂ·¾¶ÓÃµ½
int d[maxv];//µ½ÖÕµã¾àÀë
int iter[maxv];//µ±Ç°»¡ÏÂ±ê
int num[maxv];
int nume;
void init(int n)
{
    for (int i = 0; i &lt; n; i++) G[i].clear();
    edges.clear();
}

void addEdge(int from, int to, int cap)
{
    edges.push_back(Edge(from, to, cap, 0));
    edges.push_back(Edge(to, from, 0, 0));
    nume = edges.size();
    G[from].push_back(nume-2);
    G[to].push_back(nume-1);
}


void bfs(int t)
{
    memset(d, -1, sizeof(d));
    d[t] = 0;
    queue&lt;int&gt; que;
    que.push(t);
    while(!que.empty())
    {
        int u = que.front();que.pop();
        for (int i = 0; i &lt; G[u].size(); i++)
        {
            Edge &amp;e = edges[G[u][i]^1];
            if (e.cap &gt; e.flow &amp;&amp; d[e.from] &lt; 0)
            {
                d[e.from] = d[u] + 1;
                que.push(e.from);
            }
        }
    }
}

int add(int s, int t)
{
    int u = t,df = INF;
    //´Ó»ãµãµ½Ô´µãÍ¨¹ýp×·×ÙÔö¹ãÂ·¾¶£¬dfÎªÒ»Â·ÉÏ×îÐ¡µÄ²ÐÁ¿
    while(u != s)
    {
        Edge &amp;e = edges[p[u]];
        df = min(df, e.cap - e.flow);
        u = edges[p[u]].from;
    }
    u = t;
    //´Ó»ãµãµ½Ô´µã¸üÐÂÁ÷Á¿
    while(u != s)
    {
        edges[p[u]].flow += df;
        edges[p[u]^1].flow -= df;
        u = edges[p[u]].from;
    }
    return df;
}


int max_flow(int s, int t)
{
    int flow = 0;
    bfs(t);
    memset(num, 0, sizeof(num));
    for (int i = 0; i &lt;= t; i++)
        num[d[i]]++;
    int u = s;
    memset(iter, 0, sizeof(iter));
    while(d[s] &lt;= t)
    {
        //cout&lt;&lt;d[s]&lt;&lt;endl;
       // system("pause");
        if (u == t)
        {
            flow += add(s, t);
            u = s;
        }
        bool flag = false;
        for (int i = iter[u]; i &lt; G[u].size(); i++)
        {
            Edge &amp;e = edges[G[u][i]];
            if (e.cap &gt; e.flow &amp;&amp; d[u] == d[e.to] + 1)
            {
                flag = true;
                p[e.to] = G[u][i];
                iter[u] = i;
                u = e.to;
                break;
            }
        }
        if (!flag) // restart
        {
           // cout&lt;&lt;1&lt;&lt;endl;
            int m = t;
            for (int i = 0; i &lt; G[u].size(); i++)
            {
                Edge &amp;e = edges[G[u][i]];
                if (e.cap &gt; e.flow)
                    m = min(m, d[e.to]);
            }
            if (--num[d[u]] == 0)
                break;//gapÓÅ»¯
            num[d[u] = m+1] ++;
            iter[u] = 0;
            if (u != s)
                u = edges[p[u]].from;
        }
    }
    return flow;
}

int main()
{
    int n,f,d;
    scanf("%d%d%d", &amp;n, &amp;f, &amp;d);
    for (int i = 1; i &lt;= n; i++)
    {
        int a,b;
        scanf("%d%d", &amp;a, &amp;b);
        addEdge(i, i+n, 1);
        for (int j = 0; j &lt; a; j++)
        {
            int food;
            scanf("%d", &amp;food);
            addEdge(2*n+food, i, 1);
        }
        for (int k = 0; k &lt; b; k++)
        {
            int dish;
            scanf("%d", &amp;dish);
            addEdge(i+n, 2*n+f+dish, 1);
        }
    }
    int s = 0, t = 2*n+d+f+1;
    for (int i = 1; i &lt;= f; i++)
        addEdge(0, 2*n+i, 1);
    for (int i = 1; i &lt;= d; i++)
        addEdge(2*n+f+i,t,1);
    printf("%d\n", max_flow(s,t));
   // system("pause");

    return 0;
}
</code></pre>

<p>之所以用isap是因为我昨天是最后敲的isap，今天就没有毁直接用的。</p>

<p>好了，题解大概就这样了，接下来该最小费用流了！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图论总结(二)]]></title>
    <link href="http://whn757397540.github.io/blog/2015/03/14/tu-lun-zong-jie-er/"/>
    <updated>2015-03-14T18:54:17+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/03/14/tu-lun-zong-jie-er</id>
    <content type="html"><![CDATA[<h5>最大流的几种方法总结</h5>

<!--more-->


<p>这里总结一下最大流的几种算法的区别，以及最大流的一些使用技巧。</p>

<p>这里以一道例题来比较一下这几种方法。先放题</p>

<p><a href="http://poj.org/problem?id=1149">POJ1149 PIGS</a></p>

<p>先来说下题意和构图。</p>

<p>题意： 有人买猪，买主带着钥匙，卖猪的人没有钥匙。有以下几张限制条件：1.只有买猪的人能开门，且买猪的人可能带有多把钥匙；2.买猪的人每天只来一个；3.卖猪的人可以在买猪的人带来钥匙的那一天在打开的猪圈之间任意调动猪（也就是说，买猪的人走后猪圈重新关上）；4.猪圈的容量无上限；5.给出每个猪圈初始有的猪的个数；6.卖猪的人可以决定是否卖给买猪的人；7.给出每个人要买的猪的个数（可以少不可以多）。</p>

<p>首先，我们应该解决怎么构图的问题。分析下题意，容易看出是一个最大流问题，流体是猪，流向是从猪圈流向人。那么我们建图肯定是从猪圈指向人了。我们可以这样来建图。首先，虚拟一个源点s，s指向所有的猪圈，边的权值就是猪圈初始的猪的数量；然后，虚拟一个汇点t，所有的人最终指向t（因为他问的是最多能卖多少只猪，跟是谁买的没有关系），边的权值就是那个人想要的猪的数量。最后，也是最关键的，中间的图怎么建。关于这点，分析一下，我们知道，对于一个人来说，他有那个猪圈的钥匙，就可以从哪个猪圈里面选猪，猪是从猪圈流向人的，而且人选猪的数量也是没有限制的（多选了可以放回去，重点在于这个边是没有限制的），所以这个边应该是从猪圈指向持有猪圈钥匙的人，权值是INF；最后要解决的一点就是，卖猪的人可以在猪圈打开的时候任意调整猪的位置这个条件怎么用，很容易知道，假如两个人拥有同一个猪圈的钥匙，那么后来的那个人就可以从先来的那个人那里得到猪（先来的那个人手头的猪放到那个公共猪圈中，再流向后来的那个人），所以，还应该有这样一条边，对于拥有同一个猪圈钥匙的人，有一条从先来的指向后来的的边，权值是INF（因为猪圈的容量是无上限的）。</p>

<p>有了上面的分析，图就建好了，接下来就是求从s到t的最大流了。我用了4种方法来敲，其中Full-Fulkerson算法和Dinic是借鉴《挑战程序设计竞赛》书上的写法，Edmonds-Karp算法和ISAP算法是借鉴的刘汝佳《算法竞赛入门经典》上的写法。接下来挂出四种方法的代码。</p>

<p>Full-Fulkerson</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include&lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 10000;
const int maxe = 55555;
const int INF = 0x3f3f3f3f;
struct Edge{
    int to,cap,rev;

    Edge(){}
    Edge(int to, int cap, int rev):to(to),cap(cap),rev(rev){}
};

vector&lt;Edge&gt; G[maxv];
bool used[maxv];

void addEdge(int from, int to, int cap)
{
    G[from].push_back(Edge(to,cap,G[to].size()));
    G[to].push_back(Edge(from,0,G[from].size()-1));
}

int dfs(int v, int t, int f)
{
    if (v == t) return f;
    used[v] = true;
    for (int i = 0; i &lt; G[v].size(); i++)
    {
        Edge &amp;e = G[v][i];
        if (!used[e.to] &amp;&amp; e.cap &gt; 0)
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if (d&gt;0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

int max_flow(int s, int t)
{
    int flow = 0;
    while(true)
    {
        memset(used, 0 ,sizeof(used));
        int f = dfs(s,t,INF);
        if (f == 0) return flow;
        flow += f;
    }
}

vector&lt;int&gt; rec[maxv];
int main()
{
    int m,n;
    scanf("%d%d", &amp;m, &amp;n);
    int t = m+n+1, s = 0;
    for (int i = 1; i &lt;= m; i++)
    {
        int x;
        scanf("%d", &amp;x);
        addEdge(s,i,x);
    }
    for (int i = m+1; i &lt;= m+n; i++)
    {
        int nn;
        scanf("%d", &amp;nn);
        for (int j = 0; j &lt; nn; j++)
        {
            int mm;
            scanf("%d", &amp;mm);
            rec[mm].push_back(i);
            addEdge(mm, i, INF);
        }
        int tt;
        scanf("%d", &amp;tt);
        addEdge(i,t,tt);
    }
  for (int i = 1; i &lt;= m; i++)
        for (int j = 1; j &lt; rec[i].size(); j++)
                addEdge(rec[i][j-1], rec[i][j], INF);
    printf("%d\n", max_flow(s,t));
    return 0;
}
</code></pre>

<p>EK</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include&lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 10000;
const int maxe = 55555;
const int INF = 0x3f3f3f3f;
struct Edge{
    int from, to, cap, flow;
    Edge(int u, int v, int c, int f): from(u), to(v), cap(c),flow(f){}
};

vector&lt;Edge&gt; edges;
vector&lt;int&gt; G[maxv];
int a[maxv];
int p[maxv];
int nume;
void init(int n)
{
    for (int i = 0; i &lt; n; i++) G[i].clear();
    edges.clear();
}

void addEdge(int from, int to, int cap)
{
    edges.push_back(Edge(from, to, cap, 0));
    edges.push_back(Edge(to, from, 0, 0));
    nume = edges.size();
    G[from].push_back(nume-2);
    G[to].push_back(nume-1);
}

int max_flow(int s, int t)
{
    int flow = 0;
    while(true)
    {
        memset(a, 0 , sizeof(a));
        queue&lt;int&gt; Q;
        Q.push(s);
        a[s] = INF;
        while(!Q.empty())
        {
            int x = Q.front();Q.pop();
            for (int i = 0; i &lt; G[x].size(); i++)
            {
                Edge&amp; e = edges[G[x][i]];
                if(!a[e.to] &amp;&amp; e.cap &gt; e.flow)
                {
                    p[e.to] = G[x][i];
                    a[e.to] = min(a[x], e.cap - e.flow);
                    Q.push(e.to);
                }
            }
            if (a[t])
                break;
        }
        if(!a[t]) break;
        for (int u = t; u != s; u = edges[p[u]].from)
        {
            edges[p[u]].flow += a[t];
            edges[p[u]^1].flow -= a[t];
        }
        flow += a[t];
    }
    return flow;
}

vector&lt;int&gt; rec[maxv];
int main()
{
    int m,n;
    scanf("%d%d", &amp;m, &amp;n);
    int t = m+n+1, s = 0;
    for (int i = 1; i &lt;= m; i++)
    {
        int x;
        scanf("%d", &amp;x);
        addEdge(s,i,x);
    }
    for (int i = m+1; i &lt;= m+n; i++)
    {
        int nn;
        scanf("%d", &amp;nn);
        for (int j = 0; j &lt; nn; j++)
        {
            int mm;
            scanf("%d", &amp;mm);
            rec[mm].push_back(i);
            addEdge(mm, i, INF);
        }
        int tt;
        scanf("%d", &amp;tt);
        addEdge(i,t,tt);
    }
   /* for (int i = 0; i &lt;= n+m+1; i++)
    {
        printf("%d:\n", i);
        for (int j = 0; j &lt; G[i].size(); j++)
            printf("\t%d %d\n",G[i][j].to, G[i][j].cap);
        cout&lt;&lt;endl;
    }*/
  for (int i = 1; i &lt;= m; i++)
        for (int j = 1; j &lt; rec[i].size(); j++)
                addEdge(rec[i][j-1], rec[i][j], INF);
    printf("%d\n", max_flow(s,t));
    return 0;
}
</code></pre>

<p>Dinic</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include&lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 10000;
const int maxe = 55555;
const int INF = 0x3f3f3f3f;
struct Edge{
    int to,cap, rev;
    Edge(int to, int cap, int rev):to(to), cap(cap), rev(rev){}
};

vector&lt;Edge&gt; G[maxv];
int level[maxv];//顶点到源点的距离标号
int iter[maxv];//当前弧，在其之前的边已经没有用了

void addEdge(int from, int to, int cap)
{
    G[from].push_back(Edge(to, cap, G[to].size()));
    G[to].push_back(Edge(from, 0, G[from].size()-1));
}

void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for (int i = 0; i &lt; G[v].size(); i++)
        {
            Edge &amp;e = G[v][i];
            if (e.cap&gt;0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

int dfs(int v, int t, int f)
{
    if(v == t)
        return f;
    for (int &amp;i = iter[v]; i &lt; G[v].size(); i++)
    {
        Edge &amp;e = G[v][i];
        if (e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if (d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

int max_flow(int s, int t)
{
    int flow = 0;
    while(true)
    {
        bfs(s);
        if (level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while ((f = dfs(s, t, INF)) &gt; 0)
            flow += f;
    }
}

vector&lt;int&gt; rec[maxv];
int main()
{
    int m,n;
    scanf("%d%d", &amp;m, &amp;n);
    int t = m+n+1, s = 0;
    for (int i = 1; i &lt;= m; i++)
    {
        int x;
        scanf("%d", &amp;x);
        addEdge(s,i,x);
    }
    for (int i = m+1; i &lt;= m+n; i++)
    {
        int nn;
        scanf("%d", &amp;nn);
        for (int j = 0; j &lt; nn; j++)
        {
            int mm;
            scanf("%d", &amp;mm);
            rec[mm].push_back(i);
            addEdge(mm, i, INF);
        }
        int tt;
        scanf("%d", &amp;tt);
        addEdge(i,t,tt);
    }
   /* for (int i = 0; i &lt;= n+m+1; i++)
    {
        printf("%d:\n", i);
        for (int j = 0; j &lt; G[i].size(); j++)
            printf("\t%d %d\n",G[i][j].to, G[i][j].cap);
        cout&lt;&lt;endl;
    }*/
  for (int i = 1; i &lt;= m; i++)
        for (int j = 1; j &lt; rec[i].size(); j++)
                addEdge(rec[i][j-1], rec[i][j], INF);
    printf("%d\n", max_flow(s,t));
    return 0;
}
</code></pre>

<p>ISAP</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include&lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

const int maxv = 10000;
const int maxe = 55555;
const int INF = 0x3f3f3f3f;
struct Edge{
    int from, to, cap, flow;
    Edge(int u, int v, int c, int f): from(u), to(v), cap(c),flow(f){}
};

vector&lt;Edge&gt; edges;
vector&lt;int&gt; G[maxv];
int a[maxv];//当前节点捏流量
int p[maxv];//父亲节点，回溯路径用到
int d[maxv];//到终点距离
int iter[maxv];//当前弧下标
int num[maxv];
int nume;
void init(int n)
{
    for (int i = 0; i &lt; n; i++) G[i].clear();
    edges.clear();
}

void addEdge(int from, int to, int cap)
{
    edges.push_back(Edge(from, to, cap, 0));
    edges.push_back(Edge(to, from, 0, 0));
    nume = edges.size();
    G[from].push_back(nume-2);
    G[to].push_back(nume-1);
}


void bfs(int t)
{
    memset(d, -1, sizeof(d));
    d[t] = 0;
    queue&lt;int&gt; que;
    que.push(t);
    while(!que.empty())
    {
        int u = que.front();que.pop();
        for (int i = 0; i &lt; G[u].size(); i++)
        {
            Edge &amp;e = edges[G[u][i]^1];
            if (e.cap &gt; e.flow &amp;&amp; d[e.from] &lt; 0)
            {
                d[e.from] = d[u] + 1;
                que.push(e.from);
            }
        }
    }
}

int add(int s, int t)
{
    int u = t,df = INF;
    //从汇点到源点通过p追踪增广路径，df为一路上最小的残量
    while(u != s)
    {
        Edge &amp;e = edges[p[u]];
        df = min(df, e.cap - e.flow);
        u = edges[p[u]].from;
    }
    u = t;
    //从汇点到源点更新流量
    while(u != s)
    {
        edges[p[u]].flow += df;
        edges[p[u]^1].flow -= df;
        u = edges[p[u]].from;
    }
    return df;
}


int max_flow(int s, int t)
{
    int flow = 0;
    bfs(t);
    memset(num, 0, sizeof(num));
    for (int i = 0; i &lt;= t; i++)
        num[d[i]]++;
    int u = s;
    memset(iter, 0, sizeof(iter));
    while(d[s] &lt;= t)
    {
        //cout&lt;&lt;d[s]&lt;&lt;endl;
       // system("pause");
        if (u == t)
        {
            flow += add(s, t);
            u = s;
        }
        bool flag = false;
        for (int i = iter[u]; i &lt; G[u].size(); i++)
        {
            Edge &amp;e = edges[G[u][i]];
            if (e.cap &gt; e.flow &amp;&amp; d[u] == d[e.to] + 1)
            {
                flag = true;
                p[e.to] = G[u][i];
                iter[u] = i;
                u = e.to;
                break;
            }
        }
        if (!flag) // restart
        {
           // cout&lt;&lt;1&lt;&lt;endl;
            int m = t;
            for (int i = 0; i &lt; G[u].size(); i++)
            {
                Edge &amp;e = edges[G[u][i]];
                if (e.cap &gt; e.flow)
                    m = min(m, d[e.to]);
            }
            if (--num[d[u]] == 0)
                break;//gap优化
            num[d[u] = m+1] ++;
            iter[u] = 0;
            if (u != s)
                u = edges[p[u]].from;
        }
    }
    return flow;
}

vector&lt;int&gt; rec[maxv];
int main()
{
    int m,n;
    scanf("%d%d", &amp;m, &amp;n);
    int t = m+n+1, s = 0;
    for (int i = 1; i &lt;= m; i++)
    {
        int x;
        scanf("%d", &amp;x);
        addEdge(s,i,x);
    }
    for (int i = m+1; i &lt;= m+n; i++)
    {
        int nn;
        scanf("%d", &amp;nn);
        for (int j = 0; j &lt; nn; j++)
        {
            int mm;
            scanf("%d", &amp;mm);
            rec[mm].push_back(i);
            addEdge(mm, i, INF);
        }
        int tt;
        scanf("%d", &amp;tt);
        addEdge(i,t,tt);
    }
   /* for (int i = 0; i &lt;= n+m+1; i++)
    {
        printf("%d:\n", i);
        for (int j = 0; j &lt; G[i].size(); j++)
            printf("\t%d %d\n",G[i][j].to, G[i][j].cap);
        cout&lt;&lt;endl;
    }*/
  for (int i = 1; i &lt;= m; i++)
        for (int j = 1; j &lt; rec[i].size(); j++)
                addEdge(rec[i][j-1], rec[i][j], INF);
    printf("%d\n", max_flow(s,t));
    return 0;
}
</code></pre>

<p>简单总结一下几种方法的区别，如果有说得不好不对的地方，还请指正。</p>

<p>首先，Full-Fulkerson算法，就是运用dfs随意找一条可以达到的路径，然后求增广路一直到没有增广路为止。复杂度（O(V<sup>2</sup> E)），这道题的运行时间200多ms;</p>

<p>然后，Edmonds-Karp算法（我看百度百科上说就是SAP算法，搞得我很混乱），其实就是把原来的深搜换成了广搜,记录下路径来更新当前选择的路径的流量就行，能保证每次选的都是最短路，相比如Full-Fulkerson算法，比较不容易被卡，复杂度（O（VE<sup>2</sup>））这道题的运行时间150ms左右;</p>

<p>再之后，Dinic算法，是对Full-Fulkerson算法的一种改进，先把图进行分层（用bfs给每个节点标明深度），然后用dfs找最短路的路径流，更新。完了之后重新bfs分层，dfs，一直到源点和汇点分离为止。这个就优化了好多了，还有一个当前弧优化，事实上就是对于一次dfs来说，用过一次的弧就不要再用了，能省好多时间的！复杂度与Full-Fulkerson相同，但是要快很多很多，这道题加上当前弧优化不到20ms，不加90ms左右。</p>

<p>最后，ISAP算法，说实话，还不是非常清楚，原理大概明白了，这个<a href="http://blog.csdn.net/pi9nc/article/details/11848245">博客</a>说得不错感觉说得挺清楚的。时间复杂度桶EK算法，但是要快好多，这道题的时间50ms左右。</p>

<p>总之，理解算法的内涵，然后找到一些好的板子就好，这些算法事实上不需要多熟悉，能够会用板子就行，关键是要能够构出图来，这个就需要多练了。</p>

<p>今天的完成度跟我计划出入有点大，还有一些应用以及变形没写。</p>

<p>好，继续补完网络流的这一部分，下面这部分很重要！（当然，也是来自于书本）</p>

<blockquote><p>专栏：最大流的各种变体</p>

<blockquote><p>多个源点和汇点的情况：</p>

<blockquote><p>上面那道题实际上就可以看成是这样的情况，就是有多个源点和汇点，不用细说了吧 。因为我们只知道单个源点和单个汇点的最大流的算法，所以对于这种情况，我们采取的办法就是增加一个超级源点S和一个超级汇点T，从S向每个源点连一条容量为对应在那个点的最大流出容量的边，从每个汇点向T连一条熔炼为定影那个点的最大流入容量的那个边。不过，如果有特殊要求（比如从某个源点流出的必须流入某些指定的汇点）时，是不能这样求解的，（PS:这种情况被称为多物网络流问题，目前尚未有已知的高效算法，竞赛中也几乎不会出现）。</p></blockquote>

<p>无向图的情况：</p>

<blockquote><p>我们常用到的是求有向图的的最大流，对于无向图怎么来求呢？记住一点，一个无向的边，跟两个流量相同方向相反的有向边是等效的，把一个无向边拆成两个有向边建图就好。</p></blockquote>

<p>顶点上也有容量限制的情况：</p>

<blockquote><p>这种情况下，我们只需要把一个点拆成2个点即可，例如原图中有一个点p，顶点限制为lim，我们只需要把他拆成p1和p2两个点，然后把本来指向p的边指向p1，把从p指出的边改为从p2指出，然后再连一条从p1指向p2的权威lim的边即可！应该比较容易想明白.</p></blockquote>

<p>有最小流量限制的情况：</p>

<blockquote><p>这个比较复杂，不太好说，参考周源《有上下界的网络流》吧（虽然我还没看），那上面也有2到例题，就在群里。</p></blockquote>

<p>图发生部分变化的情况</p>

<blockquote><p>这个指的是，在有些时候，我们求完某个图的最大流之后，需要对原图中的一部分做一些变化，再对新图求最大流。这种情况下，有些时候我们不需要重新计算最大流，而是可以重复利用前一步的结果，高效地求出新的最大流。主要考虑两种情况</p>

<p>首先，我们考虑边e(u,v)的容量增加的情况，我们只需要在原图最大流f的基础上，不断寻求增广路增广，就可以求得新图的最大流。当有多条边的容量同时增加的情况也是一样的，可以在原图的流的基础上进行求解。（我感觉，再多加一条边也是一样的）</p>

<p>然后，我们再来考虑一下变e(u,v)的容量减少1的情况。如果原图的最大六中，有f(e)&lt;=c(e)-1的话，那么它也是新图的最大流。否则，如果f(e)=c(e)，为了让新图满足流量限制，需要将多出的部分流退回去。加入f的残余网络中存在从u到v的路径，那么就可以沿着这条路径增广1并把f(e)减小1之后，而保持最大流流量不变。否则，需要找t->v和u->s的路径，沿他们增广1并把f（e）减小1之后，最大流流量也减小1.当有多条边的流量同时减小或者减小量不止1时，也可以做同样处理。（删边也可以吧！）这一般在求字典序最小的最大流之类的问题中会用到着这种技巧。</p></blockquote>

<p>容量为负数的情况</p>

<blockquote><p>通常不会出现。出现了的话，目前没有有效的算法，但是在某些情况下可以采取适当的变形额避免出现负容量的边。</p></blockquote></blockquote></blockquote>

<p>好了，到此，最大流的总结算是真的完了，重点还是在于建图上，还需要多加练习！</p>
]]></content>
  </entry>
  
</feed>
