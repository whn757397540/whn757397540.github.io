<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 凸包 | hnnwang's Blog]]></title>
  <link href="http://whn757397540.github.io/tags/tu-bao/atom.xml" rel="self"/>
  <link href="http://whn757397540.github.io/"/>
  <updated>2015-08-10T18:00:30+08:00</updated>
  <id>http://whn757397540.github.io/</id>
  <author>
    <name><![CDATA[hnnwang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[旋转卡壳总结]]></title>
    <link href="http://whn757397540.github.io/blog/2015/08/10/xuan-zhuan-qia-ke-zong-jie/"/>
    <updated>2015-08-10T17:31:57+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/08/10/xuan-zhuan-qia-ke-zong-jie</id>
    <content type="html"><![CDATA[<h2>POJ 2187 and POJ 3608</h2>

<p>这些天刷了几道旋转卡壳的题，被卡了一些时间，现在先就两道题对旋转卡壳的两个用法进行一个总结</p>

<!--more-->


<p>有关旋转卡壳的介绍，<a href="http://hnnwang.github.io/blog/2014/09/06/xuan-zhuan-qia-ke-1/">这里</a>说的挺全的.所以题解里就不去解释这种思想了</p>

<p>这里我说2道旋转卡壳的基础题！</p>

<p><a href="http://poj.org/problem?id=2187">POJ 2187 Beauty Contest</a></p>

<p>一道基础的旋转卡壳题，求凸包直径，很简单的一道题，直接套板子就好（一个凸凸包模板，一个旋转卡壳模板）。这里说下，在求直径的时候，由于是一个凸多边形，所以求三角形面积（事实上，求平行四边形面积就好，因为只比较大小）。这题的题目都是整点，可以用int，其实，求出凸包来以后直接暴力枚举来判断就能过（而且，竟然会比旋转卡壳还快），不过最好是用旋转卡壳来过吧，毕竟如果凸包上点多的花，暴力还是很慢的！暴力的代码就不挂了，旋转卡壳代码在这里</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#define next (i+1)%n
const double eps = 1e-10;
using namespace std;
int dcmp(double x)//精度比较
{
    if (x &lt; -eps) return -1;
    else if (x &gt; eps) return 1;
    else return 0;
}


double add(double a, double b)//考虑到精度的加法
{
    if (dcmp(a+b) == 0) return 0;
    return a + b;
}


struct Point//也可看做向量
{
    int x,y;
    Point() {}
    Point(int x,int y) : x(x),y(y){}
    Point operator + (Point p) {return Point(x + p.x, y + p.y); }//向量 + 向量 = 向量
    Point operator - (Point p) {return Point(x - p.x, y - p.y); } // 向量 - 向量 = 向量
    bool operator &lt; (const Point p) const {return x &lt; p.x  || x == p.x &amp;&amp; y &lt; p.y; } //字典序比较，重定义&lt;
    bool operator == (const Point p) const {return x == p.x &amp;&amp; y == p.y; }//重定义 ==
    int dot(Point p) {return x * p.x + y * p.y; }//点积
    int det(Point p) {return x * p.y - y * p.x; }//叉积,旋转方向取逆时针
    int sqrDis(Point p){return (x - p.x)*(x - p.x) + (y - p.y)*(y - p.y);}
};
typedef Point Vector;
int u;
int ConvexHull(Point* p,int n, Point* ch)
{
    sort(p,p+n);
    int m = 0;
    for (int i = 0; i &lt; n ; i ++)
    {
        while (m &gt; 1 &amp;&amp; (ch[m-1] - ch[m-2]).det(p[i] - ch[m-2]) &lt;= 0) m --;
        ch[m++] = p[i];
    }
    int k = m;
    for (int i = n-2; i &gt;= 0; i--)
    {
        while (m &gt; k &amp;&amp;(ch[m-1] - ch[m-2]).det(p[i] - ch[m-2]) &lt;= 0) m--;
        ch[m++] = p[i];
    }
    if (n &gt; 1) m--;
    return m;
}

int Area(Point a, Point b, Point c)
{
  Vector v = b - a;
  return abs(v.det(c - a));
}

int RotatingCalipers(Point *ch, int n, int s)
{
  int q = s;
  int ans = ch[0].sqrDis(ch[s]);
  for (int i = 0; i &lt; n; i ++)
  {
      while (Area(ch[i], ch[next], ch[(q+1)%n]) &gt; Area(ch[i], ch[next], ch[q]))
          q = (q+1) % n;
      ans = max(ans,max(ch[i].sqrDis(ch[q]), ch[next].sqrDis(ch[(q+1)%n])));
  }
  return ans;
}
Point a[55555],Hull[100000];
int main()
{
  int n;
  scanf("%d", &amp;n);
  for (int i = 0; i &lt; n; i++)
      scanf("%d%d", &amp;a[i].x, &amp;a[i].y);
  int m = ConvexHull(a, n, Hull);
  int u = 0;
  for (int i = 1; i &lt; m; i++)
      if (Hull[u].x &lt; Hull[i].x || Hull[u].x == Hull[i].x &amp;&amp; Hull[u].y &lt; Hull[i].y)
          u = i;
  int ans = RotatingCalipers(Hull, m, u);
  printf("%d\n", ans);
  // system("pause");
  return 0;
}
</code></pre>

<p>另外，还有就是求多边形宽度的，暂时没有找到题，不过看起来貌似挺简单的！</p>

<p><a href="http://poj.org/problem?id=3608">POJ 3608 Bridge Across Islands</a></p>

<p>这道题就稍微复杂一点了，求两个凸包的最近距离，不过同样也是用旋转卡壳很容易解决，只不过这次必须得用有向面积了，因为旋转的基点是不同的2个多边形，所以会出现负面积，把逻辑捣清楚就好。跟那个博客里说到的一样的方法，判断平行的时候，只求得对应平行四边形的面积为相等就行了，不平行的时候，用点到线段的距离来更新就行了，平行的时候，我的方法就跟那里说到的不太一样，我是为了省事儿，直接用4个顶点和对应线段之间的距离最短的来更新答案，其他就没什么不同了。还有就是这个题可以不求凸包，只需要选一个内部的点，然后根据其他点跟这个点连线的极角按照逆时针方向来排序就好。具体的看看代码来理解下吧</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
const double eps = 1e-9;
using namespace std;
const int N=10005;
int dcmp(double x)//精度比较
{
    if (x &lt; -eps) return -1;
    else if (x &gt; eps) return 1;
    else return 0;
}


double add(double a, double b)//考虑到精度的加法
{
    if (abs(a + b) &lt; eps * (abs(a) + abs(b))) return 0;
    return a + b;
}


struct Point//也可看做向量
{
    double x,y;
    Point() {}
    Point(double x,double y) : x(x),y(y){}
    Point operator + (Point p) {return Point(add(x, p.x),add(y, p.y)); }//向量 + 向量 = 向量
    Point operator - (Point p) {return Point(add(x, -p.x),add(y, -p.y)); } // 向量 - 向量 = 向量
    Point operator / (double d) {return Point(x/d, y/d);}
    bool operator &lt; (const Point p) const {return dcmp(x - p.x) &lt; 0 || dcmp(x - p.x) == 0 &amp;&amp; dcmp(y - p.y) &lt; 0; } //字典序比较，重定义&lt;
    bool operator == (const Point p) const {return dcmp(x - p.x) == 0 &amp;&amp; dcmp(y - p.y) == 0; }//重定义 ==
    bool operator &gt; (const Point p) const {return dcmp(x - p.x) &gt; 0 || dcmp(x - p.x) == 0 &amp;&amp; dcmp(y - p.y) &gt; 0;}
    double dot(Point p) {return add(x * p.x, y * p.y); }//点积
    double det(Point p) {return add(x * p.y, -y * p.x); }//叉积,旋转方向取逆时针
    double length() {return sqrt(x*x + y*y); }//向量长度
    double Angle() {return atan2(y, x);}//极角
    Point Rotate(double rad) {return Point(add(x * cos(rad),- y * sin(rad)), add(x * sin(rad), y * cos(rad))); }//逆时针旋转rad
    Point Normal() {return Point(-y / length(), x / length()); }//求单位法向量
};
typedef Point Vector;
Point a1[N],a2[N],p;
double Area(Point a, Point b, Point c)
{
  return (b-a).det(c-a);
}

double DisToSeg(Point A, Point B, Point P)
{
  if (A == B) return (P-A).length();
    Vector v1 = B - A, v2 = P - A, v3 = P - B;
    if (dcmp(v1.dot(v2)) &lt; 0) return v2.length();
    else if (dcmp(v1.dot(v3)) &gt; 0) return v3.length();
    else return fabs(v1.det(v2) / v1.length()) ;
}
double RotatingJam(int p0, int q0, int n, int m,Point a[], Point b[])
{
  int p = p0, q = q0;
  double ans = (a[p] - b[q]).length();
  while (dcmp(Area(a[p], a[(p+1)%n], b[q]) - Area(a[p], a[(p+1)%n], b[(q+1)%m])) &lt; 0)
  {
      int next = (q+1)%m;
      ans = min(ans,min(DisToSeg(b[q], b[next], a[(p+1)%n]), DisToSeg(b[q], b[next], a[p])));
      q = next;
  }
  int next = (p+1)%n;
  ans =  min(ans, DisToSeg(a[p], a[next], b[q]));
  if (dcmp(Area(a[p], a[next], b[q]) -Area(a[p], a[next], b[(q+1)%m])) == 0)
  {
      ans = min(ans, min(DisToSeg(b[q], b[(q+1)%m], a[p]),min(DisToSeg(b[q], b[(q+1)%m], a[next]),DisToSeg(a[p], a[next], b[(q+1)%m]))));
  }
  p = next;
  while (p!=p0)
  {
      while (dcmp(Area(a[p], a[(p+1)%n], b[q]) - Area(a[p], a[(p+1)%n], b[(q+1)%m])) &lt; 0)
      {
          int next = (q+1)%m;
          ans = min(ans,min(DisToSeg(b[q], b[next], a[(p+1)%n]), DisToSeg(b[q], b[next], a[p])));
          q = next;
      }
      int next = (p+1)%n;
      ans =  min(ans, DisToSeg(a[p], a[next], b[q]));
      if (dcmp(Area(a[p], a[next], b[q]) -Area(a[p], a[next], b[(q+1)%m])) == 0)
      {
          ans = min(ans, min(DisToSeg(b[q], b[(q+1)%m], a[p]),min(DisToSeg(b[q], b[(q+1)%m], a[next]),DisToSeg(a[p], a[next], b[(q+1)%m]))));
      }
      p = next;
  }
  return ans;
}
int ConvexHull(Point* p,int n, Point* ch)
{
    sort(p,p+n);
    int m = 0;
    for (int i = 0; i &lt; n ; i ++)
    {
        while (m &gt; 1 &amp;&amp; (ch[m-1] - ch[m-2]).det(p[i] - ch[m-2]) &lt;= 0) m --;
        ch[m++] = p[i];
    }
    int k = m;
    for (int i = n-2; i &gt;= 0; i--)
    {
        while (m &gt; k &amp;&amp;(ch[m-1] - ch[m-2]).det(p[i] - ch[m-2]) &lt;= 0) m--;
        ch[m++] = p[i];
    }
    if (n &gt; 1) m--;
    return m;
}
Point Hulla[N],Hullb[N];
int main()
{
  int n,m;
  while (scanf("%d%d", &amp;n, &amp;m))
  {
      if (n==0 &amp;&amp; m==0) break;
      p = Point(0,0);
      for (int i = 0; i &lt; n; i++)
      {
          scanf("%lf%lf", &amp;a1[i].x, &amp;a1[i].y);
          p = p + a1[i];
      }
      for (int i = 0; i &lt; m; i++)
      {
          scanf("%lf%lf", &amp;a2[i].x, &amp;a2[i].y);
          p = p + a2[i];
      }
      int nn = ConvexHull(a1, n, Hulla);
      int mm = ConvexHull(a2, m, Hullb);
      int min1 = 0,max2 = 0;
      for (int i = 1; i &lt; nn; i++)
          if (Hulla[min1] &lt; Hulla[i])
              min1 = i;
      for (int i = 1; i &lt; mm; i++)
          if (Hullb[max2] &gt; Hullb[i])
              max2 = i;
      double ans = RotatingJam(min1, max2, nn, mm, Hulla, Hullb);
      printf("%.5f\n",ans);
  }
  return 0;
}
</code></pre>

<p><a href="/blog/archives/">&lt;&ndash;Back</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POJ1912 a Highway and the Seven Dwarfs]]></title>
    <link href="http://whn757397540.github.io/blog/2015/08/10/poj1912-a-highway-and-the-seven-dwarfs/"/>
    <updated>2015-08-10T16:56:06+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/08/10/poj1912-a-highway-and-the-seven-dwarfs</id>
    <content type="html"><![CDATA[<p>又被卡了一整天，实在是弱爆了！计算几何的问题，虽然过了，不过感觉还是有点问题，不管了，先写题解，之后想到再改！</p>

<!--more-->


<p><a href="http://poj.org/problem?id=1912">题目链接</a></p>

<p>题意：给你n个点，然后输入直线（用2个点来表示），对于输入的每一条直线，判断所有点是否在直线的一侧。是就输出GOOD，否则输出BAD；</p>

<p>首先，先求一个凸包，然后求凸包上的点是不是都在直线的一侧！（这个自己去证明一下就好！）</p>

<p>然后，我刚开始是直接暴力判断直线是不是穿过其中某一个边的！最次的情况是O(询问数*n)的复杂度，T掉了！然后我就想，怎么样优化下。就想到了二分法！但是二分需要有一个有序的序列，什么是有序的呢？角度，沿一个方向的边的极角是有序的！</p>

<p>之后，我们假设一种特殊情况，假如所询问的直线是跟x轴平行的，那么我们只需要找凸包的最高点和最低点，判断这两点是不是在直线的两侧就行了（我的判断方法是求有向距离，看是否是异号就行了！),而最高点和最低点也很好找，找第一个极角大于0(因为x轴正方向的极角就是0)的点就是最低点，反过来，找第一个大于PI的点就是最高点。那么我们把这个方法一般化，其他的直线不就相当于把凸包旋转了一下吗？所以，就能类比到一般的了。不过这样还存在一个问题，就是如何找大于PI的点？（其实，对于极角为a的直线，应该是如何找大于a+PI的点）。最终AC的代码是参考网上的，把极角的范围调整成了(-PI/2,3*PI/2),而实际上，这种方法也是不对的！只不过数据没有卡掉这个范围而已！至于正确的该如何去找，目前逻辑还没有理清楚，等理清楚了再改下吧，这里先把思路写出来。（PS：这题不卡精度）</p>

<p>最后，注意n&lt;=1的情况。</p>

<p>下面是AC的代码</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#define next (i+1)%m
const double eps = 1e-8;
using namespace std;
const double PI = acos(-1.0);

int dcmp(double x)//精度比较
{
    if (x &lt; -eps) return -1;
    else if (x &gt; eps) return 1;
    else return 0;
}


double add(double a, double b)//考虑到精度的加法
{
    if (abs(a + b) &lt; eps * (abs(a) + abs(b))) return 0;
    return a + b;
}


struct Point//也可看做向量
{
    double x,y;
    Point() {}
    Point(double x,double y) : x(x),y(y){}
    Point operator + (Point p) {return Point(add(x, p.x),add(y, p.y)); }//向量 + 向量 = 向量
    Point operator - (Point p) {return Point(add(x, -p.x),add(y, -p.y)); } // 向量 - 向量 = 向量
    Point operator * (double a) {return Point(x * a, y * a); }// 向量 * 数 = 向量
    Point operator / (double a) {return Point(x / a, y / a); }//向量 / 数 = 向量
    bool operator &lt; (const Point p) const {return dcmp(x - p.x) &lt; 0 || dcmp(x - p.x) == 0 &amp;&amp; dcmp(y - p.y)&lt;0; } //字典序比较，重定义&lt;
    bool operator == (const Point p) const {return dcmp(x - p.x) == 0 &amp;&amp; dcmp(y - p.y) == 0; }//重定义 ==
    double dot(Point p) {return add(x * p.x, y * p.y); }//点积
    double det(Point p) {return add(x * p.y, -y * p.x); }//叉积,旋转方向取逆时针
    double length() {return sqrt(x*x + y*y); }//向量长度
    double Angle(){double A = atan2(y,x); if (A &lt; -PI/2) A+=2*PI; return A; }//极角
    Point Rotate(double rad) {return Point(add(x * cos(rad),- y * sin(rad)), add(x * sin(rad), y * cos(rad))); }//逆时针旋转rad
    Point Normal() {return Point(-y / length(), x / length()); }//求单位法向量
};

typedef Point Vector;
int ConvexHull(Point* p,int n, Point* ch)
{
    sort(p,p+n);
    int m = 0;
    for (int i = 0; i &lt; n ; i ++)
    {
        while (m &gt; 1 &amp;&amp; (ch[m-1] - ch[m-2]).det(p[i] - ch[m-2]) &lt;= 0) m --;
        ch[m++] = p[i];
    }
    int k = m;
    for (int i = n-2; i &gt;= 0; i--)
    {
        while (m &gt; k &amp;&amp;(ch[m-1] - ch[m-2]).det(p[i] - ch[m-2]) &lt;= 0) m--;
        ch[m++] = p[i];
    }
    if (n &gt; 1) m--;
    return m;
}
double DistanceToLine(Point P, Point A, Point B)
{
    Vector v1 = B - A, v2 = P - A;
    return v1.det(v2)/v1.length();
}
Point a[100005],Hull[200000];
double Ang[100005];
bool cmp(double a, double b)
{
    //if (a - b &gt; PI) b += 2*PI;
   // else if (b - a &gt; PI) a += 2*PI;
    return a &lt; b;
}
int main()
{
   // freopen("in.txt","r",stdin);
    int n;
    scanf("%d", &amp;n);
    for (int i = 0; i &lt; n; i++)
        scanf("%lf%lf", &amp;a[i].x, &amp;a[i].y);
    int m = ConvexHull(a, n, Hull);
    for (int i = 0 ; i &lt; m; i ++)
        Ang[i] = (Hull[next] - Hull[i]).Angle();
    Point p1,p2;
    while (scanf("%lf%lf%lf%lf", &amp;p1.x, &amp;p1.y, &amp;p2.x, &amp;p2.y) != EOF)
    {
        bool flag = true;
        int aa = upper_bound(Ang, Ang+m, (p2-p1).Angle(), cmp) - Ang;
        int bb = upper_bound(Ang, Ang+m, (p1-p2).Angle(), cmp) - Ang;
        double d1 = DistanceToLine(Hull[aa], p1, p2);
        double d2 = DistanceToLine(Hull[bb], p1, p2);
        if (n &gt; 1 &amp;&amp; dcmp(d1*d2) &lt; 0) flag = false;
        if (flag) printf("GOOD\n");
        else printf("BAD\n");
    }
}
</code></pre>

<p><a href="/blog/archives/">&lt;&ndash;Back</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POJ1133]]></title>
    <link href="http://whn757397540.github.io/blog/2015/08/10/poj1133/"/>
    <updated>2015-08-10T16:55:42+08:00</updated>
    <id>http://whn757397540.github.io/blog/2015/08/10/poj1133</id>
    <content type="html"><![CDATA[<p>这次被%lf卡了，学乖了，查了一下！</p>

<p>先说查到的东西。</p>

<!--more-->


<blockquote><blockquote><p>printf的%f说明符的确既可以输出float型又可以输出double型。根据“默认参数提升”规则（在printf这样的函数的可变参数列表中，不论作用域内有没有原型，都适用这一规则）float型会被提升为double型。因此printf()只会看到双精度数。（严格地讲，%lf在printf下是未定义的，但是很多系统可能会接受它。要确保可移植性，就要坚持使用%f。）</p></blockquote></blockquote>

<p>对于scanf，情况就完全不同了，它接受指针，这里没有类似的类型提升。（通过指针）向float存储和向double存储大不一样，因此，scanf区别%f和%lf。（以上摘自poj1113讨论区）</p>

<p>总的来说，就是输入的时候，float用%f,double用%lf，输出都用%f；</p>

<p>至于这道题，就是一道很简单的凸包问题，求一个凸包，然后求凸包周长，加上一个半径为L的圆的周长！至于证明，简单说一下，题目其实就是要求转角为弧线，而这个弧线的圆心角应该是凸包的外角，而凸包的外角就是凸多边形的外角，多边形外角和为360度，所以必定要增加的是一个圆的周长。</p>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define next (i+1)%m
const double eps = 1e-8;
int dcmp(double a)
{
    if (fabs(a) &lt; eps) return 0;
    return a &lt; 0 ? -1 : 1;
}
double add(double a, double b)
{
    if (fabs(a+b) &lt; eps * (fabs(a) + fabs(b)))
        return 0;
    return a+b;
}
struct Point{
    double x,y;
    Point(){}
    Point(double x, double y) : x(x),y(y){}
    bool operator &lt; (const Point p) const{return dcmp(x-p.x) &lt; 0 || dcmp(x-p.x) == 0 &amp;&amp; dcmp(y-p.y) &lt; 0;}
    bool operator == (const Point p) const{return dcmp(x-p.x) == 0 &amp;&amp; dcmp(y-p.y) == 0;}
    Point operator + (Point p) {return Point(add(x, p.x), add(y, p.y));}
    Point operator - (Point p) {return Point(add(x, -p.x), add(y, -p.y));}
    double dot(Point p) {return add(x*p.x, y*p.y);}
    double det(Point p) {return add(x*p.y, -y*p.x);}
    double length() {return sqrt(add(x*x, y*y));}
    double Angle(Point p) {return acos(add(x*p.x, y*p.y)/length()/p.length());}
};

int ConverHull(Point *a, int n, Point *res)
{
    std::sort(a,a+n);
    int m = 0;
    for (int i = 0; i &lt; n; i ++)
    {
        while (m &gt; 1 &amp;&amp; (res[m-1] - res[m-2]).det(a[i] - res[m-1]) &lt;= 0) m--;
        res[m++] = a[i];
    }
    int k = m;
    for (int i = n-2; i &gt;= 0 ; i --)
    {
        while (k &gt; m &amp;&amp; (res[k-1] - res[k-2]).det(a[i] - res[k-1]) &lt;= 0) k--;
        res[k++] = a[i];
    }
    if (n &gt; 1) k--;
    return k;
}

Point a[1005],Hull[2000];
int main()
{
    int n,r;
    scanf("%d%d",&amp;n, &amp;r);
    const double PI = acos(-1);
    const double L = 2*acos(-1)*r;
    for (int i = 0; i &lt; n ; i ++)
        scanf("%lf%lf", &amp;a[i].x, &amp;a[i].y);
    int m = ConverHull(a,n,Hull);
    double ans = 0;
    for (int i = 0; i &lt; m; i ++)
    {
        Point now = Hull[next] - Hull[i];
        ans += now.length();
    }
    ans += L;
    printf("%.0f\n",ans);
}
</code></pre>

<p><a href="/blog/archives/">&lt;&ndash;Back</a></p>
]]></content>
  </entry>
  
</feed>
