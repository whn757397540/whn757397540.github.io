---
layout: post
title: "算法设计与分析期末复习总结"
date: 2015-07-01 15:50:30 +0800
comments: true
categories: 
---

<!--more-->

几个例子的算法分析：

1. 二分搜索：

* 算法目的：在一个已经排好序的序列中找到一个特定元素x（其实更准确说，还可以是满足某个有序条件比如说 >=x的元素的位置）

* 基本思想：把n各元素分成个数大致相等的两部分，取中间值跟x进行比较，由于序列是有序的，所以根据比较的结果就能够得到要找的元素或者位置是在前半部分还是后半部分，然后对那一部分进行二分搜索。

* 策略：分治

* 算法步骤：1.确定下界lb和上界ub，选取中间值与要求值比较；2.根据比较结果选择合适的区间，如果找到结果则返回结果，否则重新执行第一步。

* 复杂度分析：搜索范围每次减少一半，最坏的情况下搜索范围只有一个，一共缩小了logn次，每次只有一次比较，复杂度为O(1).即T(n)=T(n/2)+O(1),T(1)=O(1).因此总复杂度为O（logn）；

* 姿势问题：
- 找>某个元素的，那么搜索的区间为左开右闭，即(lb,ub],最终得到一个只有一个元素的区间。找<=某个元素的可以用找到的位置-1。
- 找>=某个元素的，那么搜索区间为左闭右开，即[lb,ub),最终得到一个只有一个元素的区间。找<某个元素的可以用找到的位置-1。

2. 归并（合并）排序:

* 算法目的：把一个可排序的序列变成有序的（也就是将序列排序）

* 基本思想：将待排序的序列元素分成大小大致相同的2个子集（按照原数组标号分），分别对2个子集进行排序，最后将排好序的子集进行有序合并得到最终排好序的序列。

* 策略：分治

* 算法基本步骤：1.将原序列分成大致相同的两个子集；2.对于每一个子集，递归地进行如下操作：如果子集大小为1，则返回，否则将这个子集的两个子集有序合并得到一个有序的序列。其中合并的操作原理如下：分别设置两个指针指向两个有序子集的头（其实用一个数字标示即可），然后选取这两个子集的头之中较小的一个加到一个新开的数组中，对应的指针后移，直到所有的的元素都加入到了新的数组中，再把新的数组重新赋值回去。由于每个元素只扫到一次，所以对于长度为n（子集长度为n/2）的序列，合并的复杂度为O（n）

* 复杂度分析：每次取一半，合并复杂度为O(n),所以T(n) = 2*T(n/2)+O(n). T(1) = O(1) 所以总复杂度为O(logn)

3. 快速排序

* 基本思想：对于每一个序列，以某一个元素为基准，这个元素可以随机选取（随机版本的快速排序法），然后把比这个元素小的放到这个元素的左边，不比这个元素小的放到这个元素的右边，然后分别对左边和右边进行递归求解。

* 策略：分治

* 步骤：1.随机选取待排序列中的一个基准元素（随机快速排序），并将其跟第一个元素交换（非随机的快速排序选择的基准元素是第一个）；2.从右往左找到第一个小于这个元素的元素的位置（设置一个右指针，从最后一个元素开始），从左往右找到第一个大于等于这个元素的元素的位置（设置一个左指针，从第二个元素开始），将这两个位置的元素进行交换；3.当左指针和右指针相遇时停止操作，否则重复执行2操作；4.将相遇的位置（即当时左指针或者右指针指向的位置）和首位置的元素互换，得到左半部分小于基准元素，右半部分不小于基准元素的序列；5.递归地分别对左半部分和右半部分进行快速排序操作，直到集合中只有一个元素。

* 复杂度分析：最好的情况下，每次都只有一半的元素需要交换位置（选的基准恰好为所有元素的中位数），交换后的元素部分像差不多，为n/2，所以，T(n) = 2*T(n/2)+O(n), T(1) = 1, 所以T(n) = O(nlogn);最坏的情况下，原数组是基本逆序排好序的情况下，如果每次选择第一个元素，那么每次都要有n-1个数要交换，所以复杂度为T(n) = T(n-1)+O(n),T(1)=1,所以T(n) = O(n^2);不过在随机选择的情况下，基本可以避免最坏的情况，每次的选择落在中间的可能性会比较大，所以快速排序是一个平均复杂度为O（nlogn）的算法。

4. 线性时间选择：

* 问题描述：给定线性集中的n各元素和一个正整数k，k<=n,找出这n各元素中第k小的元素。

* 基本思想：跟快速排序类似，只不过分好左右两边之后，看k跟左边元素个数相比的大小，如果k大则更新k(k = k-左边元素个数)然后在右边找，否则在左边找.

* 策略：分治

* 步骤: 类似快排，根据基本思想的变动做相应的改变即可。

* 复杂度分析：也跟快排类似，只不过每次只需要找一半，所以T(n) = T(n/2)+O(n)（最好）,总体复杂度为O(n);最坏是O（n^2)，比如说;.

* 优化：主要是选择基准的问题，基准的选取如下，把n个元素分成5个一组的m = n/5组，对每组进行排序（冒泡之类的排序法即可），然后再找到每组数据的中位数组成一个序列，递归地进行同样的操作，直到只剩下一个数为止（由于最后一组可能不是5个数，所以当为偶数的时候选取两个数之中较大的那个）。




















